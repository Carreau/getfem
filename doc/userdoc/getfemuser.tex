\documentclass[11pt,a4paper]{article}
% allow both latex and PDFlatex compatibility  (from pdfTeX FAQ)
\usepackage{hyperlatex}

\usepackage{pifont}
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{psfig}
\usepackage{array}
\usepackage{supertabular}
%\usepackage{fancyheadings}
%\usepackage{here}
%\usepackage{pslatex}
\usepackage{eepic,epic}
%\usepackage{pslatex}%{ç}a serait cens{é} corriger le pb de fontes dans les pdfs mais le fichier produit est pas beau
\usepackage[english]{babel}
\usepackage{alltt}

\texonly{\usepackage{graphicx}
\usepackage{makeidx}
\usepackage[pdftex,pageanchor=true,hyperindex=true,pagebackref=true,pdfhighlight=/O,pdfauthor={Yves Renard}]{hyperref}%pour le pdf
\usepackage{xspace} % insere un espace si necessaire 
\usepackage{underscore}
 %\input{persdf}
\newcommand{\ds}{\displaystyle}
\newcommand{\Frac}[2]{{\ds \frac{\ds #1}{\ds #2}}}
\oddsidemargin -0.9cm
\evensidemargin -0.9cm
\topmargin -1cm
\textheight 22.5cm
\textwidth 17.6cm
\headheight 1.0cm
}
\makeindex

% \W .. is equivalent to \htmlonly{..}
\W \newcommand{\HlxIcons}{./}
%\W \usepackage{frames} % navigation panel
\W \htmldirectory{getfemuser}
\W \htmlname{getfemuser}
\W \setcounter{htmldepth}{2}
\W \setcounter{htmlautomenu}{2}
\W \renewcommand{\HlxMeta}{\xml{META description="getfem++ user manual"}}
\htmlonly{%
  \htmlpanelfield{Index}{getfemuser}
  \htmlcss{docstyle.css}
  \newcommand{\text}[1]{\mathrm{#1}}
  \newcommand{\WEB}[2]{\xlink{#2}{#1}}
  \newcommand{\nabla}{\htmlsym{nabla}}%renamed \xmlent by lastest version of hyperlatex
  \newcommand{\ell}{\htmlsym{tau}}
  \newcommand{\lambda}{\htmlsym{lambda}}
  \newcommand{\varepsilon}{\htmlsym{epsilon}}
  \newcommand{\phi}{\htmlsym{phi}}
  \newcommand{\varphi}{\htmlsym{phi}}
  \newcommand{\psi}{\htmlsym{psi}}
  \newcommand{\sigma}{\htmlsym{sigma}}
  \newcommand{\nu}{\htmlsym{nu}}
  \newcommand{\beta}{\htmlsym{beta}}
  \newcommand{\gamma}{\htmlsym{gamma}}
  \newcommand{\Gamma}{\htmlsym{Gamma}}
  \newcommand{\Delta}{\htmlsym{Delta}}
  \newcommand{\delta}{\htmlsym{delta}}
  \newcommand{\Omega}{\htmlsym{Omega}}
  \newcommand{\omega}{\htmlsym{omega}}
  \newcommand{\partial}{\htmlsym{part}}
  \newcommand{\sum}{\htmlsym{sum}}
  \newcommand{\int}{{\Large\htmlsym{int}}}
}
\T \newcommand{\Div}{\textrm{div}}
\W \newcommand{\Div}{div}
\T \newcommand{\Grad}{\textrm{grad}}
\W \newcommand{\Grad}{grad}
\T \newcommand{\Rot}{\textrm{curl}}
\W \newcommand{\Rot}{curl}

\W \newcommand{\gf}{getfem++}
\T \newcommand{\gf}{{\sc Getfem++}\xspace}

\W \newcommand{\newpage}{}
\W \newcommand{\hspace}[1]{ }
\W \newcommand{\left}{} % pour les left\(i\right) 
\W \newcommand{\right}{}
\W \newenvironment{alltt}{\begin{example}}{\end{example}}
\T \newenvironment{cppcode}{\begin{alltt}}{\end{alltt}}
\W \newenvironment{cppcode}{\begin{rawxml}<div class="cppcode">\end{rawxml}\begin{example}}{\end{example}\begin{rawxml}</div>\end{rawxml}}
\T \newcommand{\cpp}[1]{\texttt{#1}}
\T \newcommand{\filename}[1]{\texttt{#1}}
\W \newcommand{\cpp}[1]{\xmlattributes*{tt}{class="inlinecppcode"}\texttt{#1}}
\W \newcommand{\filename}[1]{\xmlattributes*{tt}{style="color:red"}\texttt{#1}}

\T \newenvironment{ctableau}[2]{\begin{center}\begin{supertabular}{#1}}{\end{supertabular}\end{center}}
\W \newenvironment{ctableau}[2]{\xmlattributes*{table}{border=1 align="center"}\begin{tabular}{#2}}{\end{tabular}}
\begin{document}
\htmltitle{Getfem User Guide}
\htmlpanel{0}%disable navigation panel

\begin{center}
\texonly{
  \includegraphics[width=10cm,angle=0]{logogetfemwhitebg}\\[0.2cm]
  a Generic Finite Element library in C++ \\[0.5cm]
  {\LARGE Documentation, part \Huge 2} \\[0.5cm]
  \fbox{\Huge \sc Short User Documentation} \\[0.5cm]
  { \large Yves {\sc Renard}, Julien {\sc Pommier} \footnote{ \it MIP, INSAT, Complexe scientifique de Rangueil, 31077 Toulouse, France, Yves.Renard@gmm.insa-tlse.fr } } \\[1.0cm]
  \today \\[1.0cm]
}
\htmlonly{
  \xlink{\htmlimg{logogetfem.png}{The Getfem++ logo}}{http://www.gmm.insa-tlse.fr/getfem}\\[2cm]
  a Generic Finite Element library in C++ \par\par
  {\LARGE Documentation, part \Huge 2} \par\par
  {\Huge Short User Documentation } \par
  { \large \xlink{Yves Renard}{mailto:Yves.Renard@gmm.insa-tlse.fr}, \xlink{Julien Pommier}{mailto:Julien.Pommier@gmm.insa-tlse.fr}}\\
  {\it MIP, INSAT, Complexe scientifique de Rangueil, 31077 Toulouse, France.}\par
  \today \par\par
}
\end{center}

% \begin{abstract}
% Basic user documentation for \gf .
% \end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          INTRODUCTION                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Introduction}

The \gf project focuses on the development of a generic and efficient elementary computations C++ library for finite element methods. The goal is to build a library which allows to compute any elementary matrix (even for mixed methods) on the largest class of methods and elements and for arbitrary dimension. It offers a complete separation between integration methods (exact or approximated), geometric transformations (linear or not) and finite element methods of arbitrary degrees. It allows to write finite element code which are independent of the particular method, and thus to test easily various finite element method on the same problem.

Moreover, the library includes other tools for computation with finite element such as assembling methods for classical PDEs, interpolation methods, computation of norms, mesh operations, boundary conditions... This library allows to build finite elements codes which are completely independent of the dimension, the particular method or element. Examples are provided.\\[2cm]
\htmlonly{\\\\\\}
\begin{quote}
\input{../license.tex}
\end{quote}

\newpage
\tableofcontents
\newpage

\section{How to install}
\index{Install}
Since we used standard GNU tools, the installation of the \gf  library is somewhat standard. If the \gf  archive is on your current directory you can unpack it and enter inside the directory of the distribution  with the commands
\begin{alltt}
  gunzip -c getfem-x.xx.tar.gz | tar xvf -
  cd  getfem-x.xx
\end{alltt}
Then you you have to run the configure script just typing
\begin{alltt}
  ./configure
\end{alltt}
or if you want to set the prefix directory where to install the library you can use the {\tt {-}{-}prefix} option (the default prefix directory is {\tt /usr/local}):
\begin{alltt}
  ./configure --prefix=\textit{dest_dir}
\end{alltt}
then start the compilation with
\begin{alltt}
  make
\end{alltt}
(or preferably with {\tt gmake}) and the installation with
\begin{alltt}
  make install
\end{alltt}
You can also check if the compilation is correct with
\begin{alltt}
  make check
\end{alltt}

If you want to use a different compiler than the one chosen
automatically by the \texttt{./configure} script, just specify its
name on the command line:
\begin{alltt}
  ./configure CXX=mycompiler
\end{alltt}
More specific instructions can be found in the \texttt{README*} files of
the distribution.

\section{Build a mesh}
\index{mesh}
\gf  has it own structure to store meshes defined in the files \filename{bgeot\_mesh\_structure.h}, \filename{bgeot\_mesh.h} and \filename{getfem\_mesh.h}. The main structure is defined in \filename{getfem\_mesh.h} by the object\\[0.5cm]
\cpp{getfem::getfem\_mesh }\\[0.5cm]
This object is able to store any element in any dimension even if you mix elements with different dimensions.\\[0.5cm]

There is no meshing procedures in \gf  to mesh complex geometries. This is not the goal of this package. But you can easily load a mesh from any format (some procedures are in \filename{getfem_import.h} to load meshes from some public domain mesh generator).

\subsection{Add an element to a mesh}
Suppose the variable mesh has been declared by
\index{GETFEM!getfem::getfem_mesh}
\begin{cppcode}
  getfem::getfem\_mesh mesh;
\end{cppcode}
then you have two ways to insert a new element to this mesh : from a list of points or from a list of indexes of already existing points.\\[0.5cm]
To enter a new point on a mesh use the method\\[0.5cm]
\index{GETFEM!mesh.add_point(pt)}
\cpp{i = mesh.add\_point(pt);}\\[0.5cm]
where \cpp{pt} is of type \cpp{bgeot::base\_node}. The index \cpp{i} is the index of this point on the mesh. If the point already exists in the mesh, a new point is not inserted and the index of the already existing point is returned. A mesh has a principal dimension, which is the dimension of its points. It is not possible to have points of different dimensions in a same mesh.\\[0.5cm]
The more basic function to add a new element to a mesh is\\[0.5cm]
\index{GETFEM!mesh.add_convex(pgt, it)}
\cpp{j = mesh.add\_convex(pgt, it);}\\[0.5cm]
This is a template function, with \cpp{pgt} of type \cpp{bgeot::pgeometric\_trans} and \cpp{it} is an iterator on a list of indexes of already existing points. For instance, if one needs to add a new triangle in a 3D mesh, one needs to define first an array with the indexes of the three points:\\[0.5cm]
\begin{cppcode}
  std::vector<bgeot::size\_type> ind(3);
  ind[0] = mesh.add\_point(bgeot::base\_node(0.0, 0.0, 0.0);
  ind[1] = mesh.add\_point(bgeot::base\_node(0.0, 1.0, 0.0);
  ind[2] = mesh.add\_point(bgeot::base\_node(0.0, 0.0, 1.0);
\end{cppcode}
then adding the element is done by\\[0.5cm]
\cpp{mesh.add\_convex(bgeot::simplex\_trans(2,1), ind.begin()); }\\[0.5cm]
\index{BGEOT!bgeot::simplex\_trans(N,1)}
where \cpp{bgeot::simplex\_trans(N,1);} denotes the usual linear geometric transformation for simplices of dimension N.\\[0.5cm]
For simplices, a more specialized function exists, which is\\[0.5cm]
\cpp{mesh.add\_simplex(2, ind.begin()); }\\[0.5cm]

It is also possible to give directly the list of points with the function\\[0.5cm]
\index{GETFEM!mesh.add\_convex\_by\_points(pgt, itp)}
\cpp{mesh.add\_convex\_by\_points(pgt, itp); }\\[0.5cm]
where now \cpp{itp} is an iterator on an array of points. For example\\[0.5cm]
\begin{cppcode}
  std::vector<bgeot::base\_node> pts(3);
  pts[0] = bgeot::base\_node(0.0, 0.0, 0.0);
  pts[0] = bgeot::base\_node(0.0, 1.0, 0.0);
  pts[0] = bgeot::base\_node(0.0, 0.0, 1.0);
  mesh.add\_convex\_by\_points(bgeot::simplex\_trans(2,1), pts.begin());
\end{cppcode}
Still add a triangle to the mesh.
It is possible to use also \\[0.5cm]
\cpp{mesh.add\_simplex\_by\_points(2, pts.begin()); } \\[0.5cm]

For other elements than simplices, it is still possible to use \cpp{mesh.add\_convex\_by\_points} or $\ $$\ $ \cpp{mesh.add\_convex} with the appropriate geometric transformation. \\[0.5cm]
\index{BGEOT!bgeot::parallelepiped\_trans(N, 1)}
\cpp{bgeot::parallelepiped\_trans(N, 1) }
describes the usual transformation for parallelepipeds of dimension \cpp{N} (quadrilateron for \cpp{N=2}, hexahedron for \cpp{N=3}, ...) \\[0.5cm]
\index{BGEOT!bgeot::prism\_trans(N, 1)}
\cpp{bgeot::prism\_trans(N, 1) } 
describes the usual transformation for prisms of dimension \cpp{N} (usual prism is for \cpp{N=3}. A generalized prism is the product of a simplex of dimension \cpp{N-1} with a segment) \\[0.5cm]
Specialized functions exist also: \\[0.5cm]
\begin{cppcode}
  mesh.add\_parallelepiped(N, it);
  mesh.add\_parallelepiped\_by\_points(N, itp);
  mesh.add\_prism(N, it);
  mesh.add\_prism\_by\_points(N, itp);
\end{cppcode}

The order of the points in the array of point is not important for simplices. For other element, it is important to respect the order shown in figure \ref{fig:elem}.

\begin{figure}[htb]
  \begin{center}
    \texonly{\includegraphics[width=15cm,angle=0]{getfemuserelem}}
    \htmlonly{\htmlimg{getfemuserelem.png}{vertex numeration for usual elements}}
  \end{center}
  \caption{ \it vertex numeration for usual elements }
  \label{fig:elem}
\end{figure}

\subsection{Remove an element from a mesh}
To remove an element from a mesh, simply use\\[0.5cm]
\index{GETFEM!mesh.sup\_convex(i)}
\cpp{mesh.sup\_convex(i); }\\[0.5cm]
where \cpp{i} is the index of the element.

\subsection{Simple structured meshes}

For parallelepiped domains, it is possible to obtain structured meshes with simplices, parallelepipeds or prisms elements from three functions defined in \cpp{getfem\_regular\_meshes.h}. \\[0.5cm]
\index{GETFEM!getfem::parallelepiped\_regular\_mesh}
\begin{cppcode}
  getfem::parallelepiped\_regular\_simplex\_mesh(mesh, N, org, ivect, iref); \\
  getfem::parallelepiped\_regular\_prism\_mesh(mesh, N, org, ivect, iref); \\
  getfem::parallelepiped\_regular\_mesh(mesh, N, org, ivect, iref);
\end{cppcode}
where \cpp{mesh} is a mesh variable in which the structured mesh will be built, \cpp{N} is the dimension (limited to 4 for simplices, 5 for prisms, unlimited for parallelepipeds), \cpp{org} is of type \cpp{bgeot::base\_node} and represents the origin of the mesh, \cpp{ivect} is an iterator on an array of \cpp{N} vectors to build the parallelepiped domain, \cpp{iref} is an iterator on an array of \cpp{N} integers representing the number of division on each direction. \\[0.5cm]
For instance, to build a mesh with tetrahedrons for a unit cube with $10×10×10$ cells one can write\\[0.5cm]
\begin{cppcode}
  getfem::getfem\_mesh mesh; \\
  bgeot::base\_node org(0.0, 0.0, 0.0); \\
  std::vector<bgeot::base\_small\_vector> vect(3); \\
  vect[0] = bgeot::base\_small\_vector(1.0, 0.0, 0.0); \\
  vect[1] = bgeot::base\_small\_vector(0.0, 1.0, 0.0); \\
  vect[2] = bgeot::base\_small\_vector(0.0, 0.0, 1.0); \\
  std::vector<int> ref(3); \\
  ref[0] = ref[1] = ref[2] = 10; \\
  getfem::parallelepiped\_regular\_simplex\_mesh(mesh, 3, org, vect.begin(), ref.begin()); 
\end{cppcode}

Remark: \cpp{base\_node} and \cpp{base\_small\_vector} are almost identical, they are both ``small'' vector classes (they cannot store more than 16 elements), used to describe geometrical points, and geometrical vectors. Their memory footprint is lower than a \cpp{std::vector}.

\subsection{How to get information from a mesh}

Here is a list of functions to get information from an existing mesh. The list is not exhaustive.

\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline
  \cpp{mesh.dim()} & main dimension of the mesh.  \\ \hline

  \cpp{mesh.points\_index()} & gives a \cpp{dal::bit\_vector} object which represents all the indexes of valid points of a mesh (see in the following)  \\ \hline

  \cpp{mesh.points()[i]} & gives the point of index \cpp{i} (a \cpp{bgeot::base\_node} ). \\ \hline
  
  \cpp{mesh.convex\_index()} & gives a \cpp{dal::bit\_vector} object which represents all the indexes of valid elements of a mesh (see in the following) \\ \hline

  \cpp{mesh.structure\_of\_convex(i)} & gives the description of the structure of element of index \cpp{i}. The function return a \cpp{bgeot::pconvex\_structure}. \\ \hline

  \cpp{mesh.structure\_of\_convex(i)\hspace{5em}->nb_faces()} & number of faces of  element of index \cpp{i}. \\ \hline

  \cpp{mesh.structure\_of\_convex(i)\hspace{5em}->nb\_points()} & number of vertices of  element of index \cpp{i}. \\ \hline

  \cpp{mesh.structure\_of\_convex(i)->dim()} & intrinsic dimension of element of index \cpp{i}. \\ \hline

  \cpp{mesh.structure\_of\_convex(i)\hspace{5em}->nb\_points\_of\_face(f)} & number of vertices of the face of local index \cpp{f} of  element of index \cpp{i}.\\ \hline
 
  \cpp{mesh.structure\_of\_convex(i)\hspace{5em}->ind\_points\_of\_face(f)} & return a container with the local indexes of all vertices of the face of local index \cpp{f} of  element of index \cpp{i}. For instance \cpp{mesh.structure\_of\_convex(i) ->ind\_points\_of\_face(f)[0]} is the local index of the first vertex. \\ \hline

  \cpp{mesh.structure\_of\_convex(i)\hspace{5em}->face\_structure(f)} & gives the structure (a \cpp{bgeot::pconvex\_structure}) of local index \cpp{f} of  element of index \cpp{i}.\\ \hline

  \cpp{mesh.ind\_points\_of\_convex(i)} & gives a container with the global indexes of  vertices of element of index \cpp{i}.\\ \hline

  \cpp{mesh.points\_of\_convex(i)} & gives a container with the  vertices of element of index \cpp{i}. This is an array of \cpp{bgeot::base\_node}.\\ \hline

  \cpp{mesh.convex\_to\_point(ipt)} & gives a container with the indexes of all elements attached to the point of global index \cpp{ipt}.\\ \hline

  \cpp{convex\_with\_points(mesh, nb, ipts) } & gives a container with the indexes of all elements in \cpp{mesh} having a certain set of points for vertices. The set of points is describe by an iterator \cpp{ipts} on an array and the number of points \cpp{nb}.\\ \hline

  \cpp{neighbour\_of\_convex(mesh, ic, f)} & gives a container with the indexes of all elements in \cpp{mesh} having the common face of local index \cpp{f} of element \cpp{ic} except element \cpp{ic}. \\ \hline

  \cpp{mesh.stat()} & print in \cpp{std::cout} main information on the mesh. \\ \hline

  \cpp{mesh.clear()} & delete all elements and points from the mesh. \\ \hline

  \cpp{mesh.optimize\_structure()} & compact the structure. \\ \hline

  \cpp{mesh.trans\_of\_convex(i)} & geometric transformation of the element of index \cpp{i}. return a \cpp{bgeot::pgeometric\_trans} (see \cite{BASCOMP} for more details).  \\ \hline

  \cpp{mesh.normal\_of\_face\_of\_convex(ic, f, pt)} & gives a \cpp{bgeot::base\_small\_vector} representing an outward normal to the element at the face of local index \cpp{f} at the point of local coordinates (coordinates in the element of reference) \cpp{pt}. The point \cpp{pt} has no influence if the geometric transformation is linear. This is not a unit normal, the norm of the resulting vector is the ratio between the surface of the face of the reference element and the the surface of the face of the real element. \\ \hline

  \cpp{mesh.convex\_quality\_estimate(ic)} & gives an rought estimate of the quality of element \cpp{ic}. \\ \hline

  \cpp{mesh.convex\_radius\_estimate(ic)} & gives an estimate of the radius of element \cpp{ic}. \hline

\end{ctableau}

\index{DAL!dal::bit\_vector}
About the object \cpp{dal::bit\_vector}, which is very close to \cpp{std::bit\_vector} but with additional functionalities to represent a set of non negative integers. If \cpp{nn} is declared to be a \cpp{dal::bit\_vector}, the two instructions \cpp{nn.add(6)} or \cpp{nn[6] = true} are equivalent and means that integer 6 is added to the set. In a same way \cpp{nn.sup(6)} or \cpp{nn[6] = false} remove the integer 6 from the set. The instruction \cpp{nn.add(6, 10)} add the whole interval from 6 to 10 to the set (i.e. here 6, 7, 8, 9 and 10). To iterate on a \cpp{dal::bit\_vector}, it is possible to use iterators as usual,  but, most of the time, as this object represents a set of integer, one just wants to iterate on the integers included into the set. This is possible with the operator
\cpp{i << nn; }\\[0.5cm]
This operator takes the first index such that \cpp{nn[i] == true} and remove it (it makes nn[i] = false). If \cpp{nn} is empty, the returned value for \cpp{i} is -1. For instance, here is the code to iterate on the points of a mesh and print it to the standard output
\begin{cppcode}
  dal::bit\_vector nn = mesh.points\_index();
  bgeot::size\_type i;
  for (i << nn; i != bgeot::size\_type(-1); i << nn)
    cout << "Point of index " << i << " of the mesh : " << mesh.points()[i] << endl;
\end{cppcode}
The numeration of faces on usual elements is given in figure~\ref{fig:elemf}.
\begin{figure}[htb]
  \begin{center}
    \texonly{\includegraphics[width=15cm,angle=0]{getfemuserelemf}}
    \htmlonly{\htmlimg{getfemuserelemf.png}{faces numeration for usual elements}}
  \end{center}
  \caption{ \it faces numeration for usual elements }
  \label{fig:elemf}
\end{figure}

\subsection{Save, load and draw meshes}

(outadate section)

In \filename{getfem\_mesh.h}, two methods are defined to load meshes from file and write meshes to a file. \\[0.5cm]
\index{GETFEM!mesh.write\_to\_file(name)}
\index{GETFEM!mesh.read\_from\_file(name)}
\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline

  \cpp{mesh.write\_to\_file(const std::string \&name)} & save the mesh into a file.\\ \hline

  \cpp{mesh.read\_from\_file(const std::string \&name)} & load the mesh from a file. \hline

\end{ctableau}

A little tool allows to display a mesh using Gnuplot (and Perl). This tool is present in the directory \filename{contrib/} and of course you need to have a working distribution of Gnuplot installed on your system. This little tool is built when you execute a {\tt make} instruction on the root directory of \gf . So, if \gf  is normally installed on your system, you can change your current directory to \filename{contrib/} and execute the command \\[0.5cm]
{\tt draw\_mesh filename.mesh} \\[0.5cm]
where {\tt filename.mesh} is the file containing the mesh. This works only for meshes whose principal dimension is between 1 and 3. Examples of mesh files are also provided into the directory \filename{contrib/} to test the program.

\subsection{example}

The following is an example of how to load a mesh and extract information on it.
\begin{cppcode}
  \#include <getfem\_mesh.h>
  
  getfem::getfem\_mesh mesh; 
  
  int main(int argc, char *argv[]) \{ 
    try \{ 
     
      // read the mesh from the file name given by the first argument 
      mesh.read\_from\_file(std::string(argv[0])); 
     
      // List all the convexes
      dal::bit\_vector nn = mesh.convex\_index(); 
      bgeot::size\_type i; 
      for (i << nn; i != bgeot::size\_type(-1); i << nn) \{
        cout << "Convex of index " << i << endl; 
        bgeot::pconvex\_structure cvs =  mesh.structure\_of\_convex(i); 
        cout << "Number of vertices : " << cvs->nb\_points() << endl; 
        cout << "Number of faces : " << cvs->nb\_faces() << endl;
        for (bgeot::size\_type f = 0; f < cvs->nb\_faces(); ++f) \{
          cout << "face " << f << " has " << cvs->nb\_points\_of\_face(f); 
          cout << " vertices with local indexes : "; 
          for (bgeot::size\_type k = 0; k < cvs->nb\_points\_of\_face(f); ++k) 
          cout << cvs->ind\_points\_of\_face(f)[k] << " "; 
          cout << " and global indexes : ";
          for (bgeot::size\_type k = 0; k < cvs->nb\_points\_of\_face(f); ++k) 
            cout << mesh.ind\_points\_of\_convex(i)(cvs->ind\_points\_of\_face(f)[k]) << " ";
        \}
     \}
     
   \} DAL\_STANDARD\_CATCH\_ERROR; // catches standard errors
 \}
\end{cppcode}

\section{Select finite element and integration methods}
\subsection{Obtaining descriptors to finite elements and integration methods}
\index{GETFEM!getfem::mesh\_fem}
In order to define a complete finite element procedure on a mesh, the structure \cpp{getfem::mesh\_fem} is defined in the file \cpp{getfem\_mesh\_fem.h}. Basically, this structure describes the finite element method on each element of the mesh, and can store information about boundary structure. It is possible to have an arbitrary number of finite element description for a single mesh. This is particularly necessary for mixed methods, but also to describe different data on the same mesh. One can instantiate a \cpp{getfem::mesh\_fem} object as follows\\[0.5cm]
\cpp{getfem::mesh\_fem mef(mesh); }\\[0.5cm]
where \cpp{mesh} is an already existing mesh. The structure will be linked to this mesh and will react when modifications will be done on it. \\[0.5cm]
It is possible to specify element by element the finite element method, so that element of mixed types can be treated, even if the dimensions are different. For usual elements, the connection between two elements is done when the two elements are compatibles (same degrees of freedom on the common face). A numeration of the degrees of freedom is automatically done with a Cuthill Mc Kee like algorithm. You have to keep in mind that there is absolutely no connection between the numeration of vertices of the mesh and the numeration of the degrees of freedom. Every \cpp{getfem::mesh\_fem} object has its own numeration. \\[0.5cm]
To select a particular finite element method on a given element, one can use \\[0.5cm]
\index{GETFEM!mef.set\_finite\_element(i, ppf, ppi)}
\cpp{mef.set\_finite\_element(i, ppf, ppi=0); }\\[0.5cm]
where \cpp{i} is the index of the element, \cpp{ppf} is the descriptor of the finite element method, and \cpp{ppi} is the descriptor of the integration method. Alternative forms of this member function are:
\begin{cppcode}
  void mesh\_fem::set\_finite\_element(const dal::bit\_vector &cvs, 
    getfem::pfem ppf, getfem::pintegration\_method ppi = 0);
  void mesh\_fem::set\_finite\_element(getfem::pfem pf, 
    getfem::pintegration\_method ppi = 0);
\end{cppcode}
which set the finite elements for either the convexes listed in the \cpp{bit\_vector} cvs, or all the convexes of the mesh.

The list of all available descriptors of finite element methods is in the file \filename{getfem\_fem.h}. A short description is also given in \cite{BASCOMP}. The list of all available descriptors of integration methods is in the file \filename{getfem\_integration.h}. The integration method may be omitted, in that case the dummy integration method {\tt IM\_NONE} will be used.\\[0.5cm]
Descriptors for finite element methods and integration methods are available thanks to the two follofing functions\\[0.5cm]
\index{GETFEM!getfem::fem\_descriptor("name")}\index{GETFEM!getfem::pfem}
\index{GETFEM!getfem::int\_method\_descriptor("name")}\index{GETFEM!getfem::pintegration_method}
\begin{cppcode}
  getfem::pfem                ppf = getfem::fem\_descriptor("name of method");
  getfem::pintegration_method ppi = getfem::int\_method\_descriptor("name of method");
\end{cppcode}
where \cpp{"name of method"} is to be chosen among the existing methods.
A name of a method can be retrieved thanks to the following functions\\[0.5cm]
\begin{cppcode}
  std::string femname = getfem::name\_of\_fem(ppf); 
  std::string im\_name = getfem::name\_of\_int\_method(ppi);
\end{cppcode}
A non exhautive list (see \cite{FEMLIST} for exhaustive lists) of finite element methods is given by
\input{../kernel/getfemelemfem.tex}
Examples of exact integration methods:
\input{../kernel/getfemelemint.tex}
Examples of approximated integration methods:
\input{../kernel/getfemeleminta.tex}

Remark: note that \texttt{IM\_QUAD(3)} is not able to integrate
exactly the base functions of the \texttt{FEM_QK(2,3)} finite element!
Since its base function are tensorial product of 1D polynomials of
degree 3, one would need to use \texttt{IM\_QUAD(7)} (6 is not
available). Hence \texttt{IM\_GAUSS\_PARALLELEPIPED(2,k)} should
always be prefered over \texttt{IM\_QUAD(2*k)} since it has less
integration points.

(new in getfem++-1.7) An alternative way to obtain a Lagrange polynomial fem suitable for a given geometric transformation is to use%
\index{GETFEM!getfem::classical\_fem(pgt,degree)}\index{GETFEM!getfem::classical\_discontinuous\_fem(pgt,degree)}
\begin{cppcode}
 getfem::pfem getfem::classical\_fem(bgeot::pgeometric\_trans pg, short\_type degree);
 pfem getfem::classical\_discontinuous\_fem(bgeot::pgeometric\_trans pg, short\_type degree);
\end{cppcode}
For integration methods, one may also use\index{GETFEM!getfem::classical\_exact\_im(pgt)}\index{GETFEM!getfem::classical\_approx\_im(pgt,degree)}
\begin{cppcode}
  getfem::pintegration\_method getfem::classical\_exact\_im(bgeot::pgeometric\_trans pgt);
  getfem::pintegration\_method getfem::classical\_approx\_im(bgeot::pgeometric\_trans pgt, dim\_type d);
\end{cppcode}
These functions return an exact (i.e. analytical) integration method, or select an approximate integration method which is able to integrate exactly polynamials of degree <= \cpp{d} (at least) for convexes defined with the specified geometric transformation.

The \cpp{mesh\_fem} can call directly these functions via:\index{GETFEM!getfem::set_classical\_finite\_element}\index{GETFEM!getfem::set\_classical\_discontinuous\_finite\_element}
\begin{cppcode}
  void mesh\_fem::set\_classical\_finite\_element(const dal::bit\_vector &cvs, 
    dim\_type fem\_degree, dim\_type im\_degree=dim\_type(-1));
  void mesh\_fem::set\_classical\_discontinuous\_finite\_element(const dal::bit\_vector &cvs, 
    dim\_type fem\_degree, dim\_type im\_degree=dim\_type(-1));
  void mesh\_fem::set\_classical\_finite\_element(dim\_type fem\_degree, dim\_type im\_degree=dim\_type(-1));
  void mesh\_fem::set\_classical\_discontinuous\_finite\_element(dim\_type fem\_degree, dim\_type im\_degree=dim\_type(-1));                           
\end{cppcode}

\subsection{Examples}
For instance if one needs to have a description of a $P_1$ finite element method on a triangle with an exact integration, the way to set it is
\begin{cppcode}
 mef.set\_finite\_element(i, getfem::fem\_descriptor("FEM\_PK(2, 1)"),
                        getfem::int\_method\_descriptor("IM\_EXACT\_SIMPLEX(2)"));
\end{cppcode}
where \cpp{i} is still the index of the triangle. It is also possible to select a particular method directly on a set of element, passing to \cpp{mef.set\_finite\_element} a \cpp{dal::bit\_vector} instead of a single index. For instance
\begin{cppcode}
 mef.set\_finite\_element(mesh.convex\_index(), getfem::fem\_descriptor("FEM\_PK(2, 1)"),
                        getfem::int\_method\_descriptor("IM\_EXACT\_SIMPLEX(2)"));
\end{cppcode}
selects the method on all the elements of the mesh.\\[0.5cm]
IMPORTANT: If the finite element represents an unknown for a vectorial problem (such as linear elasticity), one should use
\cpp{mef.set\_qdim(Q)}\\[0.5cm]
to set the target dimension (see
\cite{BASCOMP} for the definition of the target dimension $Q$)\\[0.5cm]
If the target dimension $Q$ is set to a value different of $1$, the
scalar FEMs (such as $P_k$ fems etc.) are automatically
``vectorized'', i.e. each scalar degree of freedom is duplicated $Q$
times, from the \cpp{mesh\_fem} object point of vue. To sum it up,
\begin{itemize}
\item if the fem of the $ith$ element is a real vector FEMs, \cpp{mef.get\_qdim() == mef.fem\_of\_element(i)->target\_dim()} \\ and\\ \cpp{
    mef.nb\_dof\_of\_element(i) == mef.fem\_of\_element(i).nb\_dof()}.
\item if the fem has a \cpp{target\_dim} equal to $1$, \cpp{mef.nb\_dof\_of\_element(i) == mef.get\_qdim()*mef.fem\_of\_element(i).nb\_dof()}.
\end{itemize}



\subsection{Methods of the \cpp{mesh\_fem} object}

Once a finite element method is defined on a mesh, it is possible to obtain information on it with the following methods (the list is not exhaustive).\\[0.5cm]
\begin{center} \texonly{\begin{tabular}{|m{0.4\linewidth}|m{0.55\linewidth}|} \hline}\htmlonly{\xmlattributes*{table}{border}\begin{tabular}{l|l}}

  \cpp{mef.convex\_index()} & Set of indexes (a \cpp{dal::bit\_vector}) on which a finite element method is defined.  \\ \hline

  \cpp{mef.linked\_mesh()} & gives a reference to the linked mesh.  \\ \hline

  \cpp{mef.fem\_of\_element(i)} & gives a descriptor on the finite element method defined on element of index \cpp{i}.  \\ \hline

  \cpp{mef.int\_method\_of\_element(i)} & gives a descriptor on the integration method defined on element of index \cpp{i}.  \\ \hline

  \cpp{mef.nb\_dof\_of\_element(i)} & gives the number of degrees of freedom on the element of index \cpp{i}.  \\ \hline

  \cpp{mef.ind\_dof\_of\_element(i)} & gives a container (an array) with all the global indexes of the degrees of freedom of element of index \cpp{i}.  \\ \hline

  \cpp{mef.point\_of\_dof(i, j)} & gives a \cpp{bgeot::base\_node} which represents the point associated with the dof of local index \cpp{j} on element of index \cpp{i}.  \\ \hline

  \cpp{mef.point\_of\_dof(j)} & gives a \cpp{bgeot::base\_node} which represents the point associated with the dof of global index \cpp{j}.  \\ \hline

  \cpp{mef.reference\_point\_of\_dof(i, j)} & gives a \cpp{bgeot::base\_node} which represents the point associated with the dof of local index \cpp{j} on element of index \cpp{i} in the coordinates of the reference element.  \\ \hline

  \cpp{mef.first\_convex\_of\_dof(j)} & gives the index of the first element on which the degree of freedom of global index \cpp{j} is defined.  \\ \hline
  
  \cpp{mef.nb\_dof()} & gives the total number of different degrees of freedom.  \\ \hline

  \cpp{mef.get_qdim()} & gives the target dimension \cpp{Q}.  \\ \hline

  \cpp{mef.clear()} & Clear the structure, no finite element method is still defined.  \\ \hline

  \cpp{mef.add\_boundary\_elt(b, c, f)} & Add a face to a description of a boundary. Add the face \cpp{f} of the element of index \cpp{c} to the boundary of index \cpp{b}.  \\ \hline
  
  \cpp{mef.sup\_boundary\_elt(b, c, f)} & remove a face to a description of a boundary. remove the face \cpp{f} of the element of index \cpp{c} to the boundary of index \cpp{b}.  \\ \hline
\end{tabular} \end{center}

\begin{center} \begin{tabular}{|m{0.4\linewidth}|m{0.55\linewidth}|} \hline
  
  \cpp{mef.is\_convex\_on\_boundary(c, b)} & return either or not the convex of index \cpp{c}  has a face on the boundary of index \cpp{b}.  \\ \hline
  
  \cpp{mef.convex\_on\_boundary(b)} & return a \cpp{dal::bit\_vector} containing all the indexes of all the elements having at least one face on boundary of index \cpp{b}.  \\ \hline

  \cpp{mef.faces\_of\_convex\_on\_boundary(c, b) } & return a \cpp{dal::bit\_vector} containing all the local indexes of faces of the element of index \cpp{c} which contained on the boundary of index \cpp{b}.  \\ \hline

  \cpp{mef.sup\_boundary(b) } & remove the boundary of index \cpp{b}.  \\ \hline

\end{tabular} \end{center}

\section{Linear algebra procedures}
The linear algebra library used by \gf is Gmm++ which is now a separate library. Please see the \WEB{http://www.gmm.insa-tlse.fr/getfem/gmmuser/gmmuser.html}{GMM++ user documentation}.\\

Note that Getfem++ includes (since release 1.7) its own version of SuperLU 3.0 (http://crd.lbl.gov/\verb\~\xiaoye/SuperLU/), hence a direct sparse solver is available out of the box.


\section{Standard assembling procedures}

Procedures defined in the file \filename{getfem\_assembling.h} allow to assemble stiffness matrices, mass matrices and boundary conditions for a few amount of classical partial differential equation problems. All the procedures have vectors and matrices template parameters in order to be used with any matrix library.

\subsection{Laplacian (Poisson) problem}
\index{laplacian}
\index{Poisson problem}

An assembling procedure is defined to solve the problem
\texonly{\begin{eqnarray*}
  \Div (a(x)\ \Grad u(x)) = f(x), \ \ \text{in $\Omega$}, \\
  u(x) = U(x),  \ \ \text{on $\Gamma_{D}$}, \\
  \Frac{\partial u}{\partial \bf n} = F(x),  \ \ \text{ on $\Gamma_{N}$}, 
\end{eqnarray*}
}\htmlonly{
  \begin{equation*}
    \Div (a(x)\ \Grad u(x)) = f(x), \ \ \text{in $\Omega$},
  \end{equation*}
}
where $\Omega$ is an open domain of arbitrary dimension, $\Gamma_{D}$ and $\Gamma_{N}$ are parts of the boundary of $\Omega$, $u(x)$ is the unknown, $a(x)$ is a given coefficient, $f(x)$ is a given source term, $U(x)$ the prescribed value of $u(x)$ on $\Gamma_{D}$ and $F(x)$ is the prescribed normal derivative of $u(x)$ on $\Gamma_{N}$.
The function to be called to assemble the stiffness matrix is\\[0.5cm]
\index{GETFEM!getfem::asm\_stiffness\_matrix\_for\_laplacian}
\cpp{getfem::asm\_stiffness\_matrix\_for\_laplacian(SM, mef1, mef2, A);} \\[0.5cm]
where \cpp{SM} is a matrix of any type having the right dimension (i.e. \cpp{me1.nb\_dof()}), \cpp{mef1} is a variable of type \cpp{getfem::mesh\_fem} and should define the finite element method for the solution, \cpp{mef2}  is a variable of type \cpp{getfem::mesh\_fem} (possibly equal to \cpp{mef1}) describing the finite element method on which the coefficient $a(x)$ is defined, and \cpp{A} is the vector of the values of this coefficient on each degree of freedom of \cpp{mef2}. Both should use the same mesh. It is important to pay attention to the fact that the integration methods used to compute the elementary matrices are the ones declared in \cpp{mef1}. This integration method have to be chosen of sufficient order. The order has to be determined considering the degrees of element in \cpp{mef1}, in \cpp{mef2} and the geometric transformations for non-linear cases. Integration methods defined in \cpp{mef2} are ignored, hence you can use the dummy integration method \index{IM_NONE}{\tt IM\_NONE} with mef2.\\[0.5cm]
To assemble the source term, the  function to be called is\\[0.5cm]
\index{GETFEM!getfem::asm\_source\_term}
\cpp{getfem::asm\_source\_term(B, mef1, mef2, V);} \\[0.5cm]
where \cpp{B} is a vector of any type having the right dimension (still \cpp{me1.nb\_dof()}), \cpp{mef2}  is a variable of type \cpp{getfem::mesh\_fem} (possibly equal to \cpp{mef1}) describing the finite element method on which $f(x)$ is defined, \cpp{V} is the vector of the values of $f(x)$ on each degree of freedom of \cpp{mef2}.\\[0.5cm]
For the Neumann condition on $\Gamma_{N}$, the same function\\[0.5cm]
\cpp{getfem::asm\_source\_term(B, mef1, mef2, V, nbound);} \\[0.5cm]
is used again, but an additional argument has been added: \cpp{nbound} is the index of the boundary in \cpp{mef1} (see previous section on how to describe a boundary) where the Neumann condition is applied. Hence the assembly is done on the indicated boundary, and no more on the whole domain. \cpp{mef2}  is a variable of type \cpp{getfem::mesh\_fem} describing the finite element method on which $F(x)$ is defined, \cpp{V} is the vector of the values of $F(x)$ on each degree of freedom of \cpp{mef2}.\\[0.5cm]
there is two manner to take into account the Dirichlet condition on $\Gamma_{D}$, changing the linear system or explicitly reduce to the kernel of the Dirichlet condition. For the first manner, the following function is defined \\[0.5cm]
\index{GETFEM!getfem::assembling\_Dirichlet\_condition}
\cpp{getfem::assembling\_Dirichlet\_condition(SM, B, mef1, nbound, V, N);} \\[0.5cm]
where \cpp{nbound} is the index of the boundary in \cpp{mef1} where the Dirichlet condition is applied, \cpp{V} is the vector of the values of $U(x)$ on each degree of freedom of \cpp{mef1} and \cpp{N} is the dimension for vectorial problems (should be \cpp{1} for scalar problems). This operation should be the last one because it transform the stiffness matrix \cpp{SM}. It works only for Lagrange elements. At the end, one obtains the discrete system
\begin{equation*} [SM] U = B, \end{equation*}
where $U$ is the discrete unknown.\\[0.5cm]

\T \newcommand{\tildeH}{\tilde{H}}
\W \newcommand{\tildeH}{HH}
\T \newcommand{\tildeR}{\tilde{R}}
\W \newcommand{\tildeR}{RR}
\T \newcommand{\tildeN}{\tilde{N}}
\W \newcommand{\tildeN}{NN}


For the second manner, one should use\\[0.5cm]
\index{GETFEM!getfem::asm\_dirichlet\_constraints}
\cpp{getfem::asm\_dirichlet\_constraints($\tildeH$, $\tildeR$, mf\_u, mf\_rh,$H$, $R$, nbound)}.\\[0.5cm]
See the Dirichlet condition as a general linear constraint that must
satisfy the solution $u$. This function does the assembly of 
Dirichlet conditions of type $h(x).u(x) = r(x)$ where h is a small square matrix
  (of any rank) whose size is equal to \cpp{gf_mesh_fem_get(mf_u,'Qdim')}.
  This matrix is stored in \cpp{H}, one column per dof in
  \cpp{mf\_rh}, each column containing the values of the matrix $h$ stored
  in Fortran order: for example \cpp{Hd(:,j)}$ = [h_{11}(x_j) h_{21}(x_j) h_{12}(x_j) h_{22}(x_j)]$ if $u$ is a 2D vector field.
  Of course, if the unknown $u$ is a scalar field, \cpp{H} is just a row vector.
This function just assemble these
constraints into a new linear system $\tildeH u=\tildeR$, doing some
additional simplification in order to obtain a ``simple'' constraints
matrix. On a scalar equation or with a Dirichlet condition on all the components one may use \\[0.5cm]
\cpp{getfem::asm\_dirichlet\_constraints($\tildeH$, $\tildeR$, mf\_u, mf\_rh, $R$, nbound)},\\[0.5cm]
where again $R$ is the Dirichlet condition expressed on the finite element method \cpp{mf\_d}. The output matrix $\tildeH$ should be a $nbdof × nbdof$ (sparse) matrix and $\tildeR$ a $nbdof$ vector where $nbdof$ is the number of degrees of freedom of \cpp{mf\_u}.\\[0.5cm]

\index{GETFEM!getfem::Dirichlet\_nullspace} Then, one should
call \\[0.5cm]\cpp{ncols = getfem::Dirichlet\_nullspace($\tildeH$, $\tildeN$,
  $\tildeR$, Ud)},\\[0.5cm] which will return a vector $U_d$ which
satisfies the Dirichlet condition, and an orthogonal basis $\tildeN$ of the kernel of
$\tildeH$. Hence, the discrete system that must be solved is
\begin{equation*} (\tildeN'[SM]\tildeN) U_{int}=\tildeN'(B-[SM]U_d),\end{equation*}
and the solution is $U=\tildeN U_{int}+U_d$.
The output matrix $\tildeN$ should be a $nbdof × nbdof$ (sparse) matrix but should be resized to \cpp{ncols} columns. The output vector $U_d$ should be a $nbdof$ vector.
A big advantage of this approach is to be generic, and do not prescribed for the finite element method \cpp{mf\_u} to be of Lagrange type. If \cpp{mf\_u} and 
\cpp{mf\_d} are different, there is implicitly a projection (with respect to the $L^2$ norm) of the data on the finite element \cpp{mf\_u}.

If you want to treat the more general scalar elliptic equation $\Div A(x)\nabla u$, where $A(x)$ is square matrix, you should use
\cpp{getfem::asm_stiffness_matrix_for_scalar_elliptic(M, mf,mfdata, A)}. The matrix data \cpp{A} should be defined on \cpp{mfdata}. It is expected as a vector representing a $n× n× nbdof$ tensor (in Fortran order), where $n$ is the mesh dimension of \cpp{mf}, and $nbdof$ is the number of dof of \cpp{mfdata}.

\subsection{Linear Elasticity problem}

the following function assembles the stiffness matrix for linear elasticity\\[0.5cm]
\index{GETFEM!getfem::asm\_stiffness\_matrix\_for\_linear\_elasticity}
\cpp{getfem::asm\_stiffness\_matrix\_for\_linear\_elasticity(SM, mef1, mef2, LAMBDA, MU); } \\[0.5cm]
where \cpp{SM} is a matrix of any type having the right dimension (i.e. here \cpp{me1.nb\_dof()}), \cpp{mef1} is a variable of type \cpp{getfem::mesh\_fem} and should define the finite element method for the solution, \cpp{mef2}  is a variable of type \cpp{getfem::mesh\_fem} (possibly equal to \cpp{mef1}) describing the finite element method on which the Lam{é} coefficient are defined, \cpp{LAMBDA} and \cpp{MU} are vectors of the values of Lam{é} coefficients on each degree of freedom of \cpp{mef2}. It is important to pay attention to the fact that the integration methods used to compute the elementary matrices is the ones declared in \cpp{mef1} and must be of sufficient order.\\[0.5cm]

CAUTION : Linear elasticity problem is a vectorial problem, so the target dimension of \cpp{mef1} (see \cpp{mef.set_qdim(Q)}) should be the same as the dimension of the mesh.\\[0.5cm]

In order to assemble source term, Neumann and Dirichlet conditions, same functions as in previous section can be used.

\subsection{Stokes Problem with mixed finite element method}

to be described ... (see the file \filename{getfem\_assembling.h} and the MATLAB interface).
 
\subsection{Assembling a mass matrix}

The following function allows to assemble a mass matrix for a finite element method\\[0.5cm]
\cpp{getfem::asm_mass\_matrix(M, mef); } \\[0.5cm]
where \cpp{M} is a matrix of any type having the right dimension (i.e. here \cpp{me1.nb\_dof()}), \cpp{mef} is a variable of type \cpp{getfem::mesh\_fem} and should define the finite element method. \cpp{mef} could represent a vectorial finite element method (i.e. \cpp{mef.get_qdim } $> 1$).
It is also possible to obtain  mass matrix on a boundary with the same function:
\cpp{getfem::asm_mass\_matrix(M, mef, nbound); } \\[0.5cm]
where \cpp{nbound} is the index of the boundary in \cpp{mef}.


\section{Compute arbitrary elementary matrices - generic assembly procedures}
As it can be seen in the file \filename{getfem_assembling.h}, all the
previous assembly procedures use a \cpp{generic_assembly} object and
provide it an adequate description of what must be done. For example, 
the assembly of a volumic source term for a scalar FEM is done with the following excerpt of code:
\index{GETFEM!getfem::generic_assembly}
\begin{cppcode}
  getfem::generic_assembly assem;
  assem.push_mf(mf);
  assem.push_mf(mfdata);
  assem.push_data(F);
  assem.push_vec(B);
  assem.set("Z=data(#2); V(#1)+=comp(Base(#1).Base(#2))(:,j).Z(j);");
  assem.volumic_assembly();
\end{cppcode}
The first instructions declare the object, and set the data that it will use: the two \cpp{mesh\_fem} objects, the input data \cpp{F}, and the destination vector \cpp{B}.

The input data is the vector $F$, defined on \cpp{mfdata}. One wants to
evaluate $\sum_{j} f_j (\int_\Omega \phi^i \psi^j)$. The instruction must be seen as
something that will be executed for each convex \cpp{cv} of the mesh. The terms
\cpp{\#1} and \cpp{\#2} refer to the first \cpp{mesh\_fem} and the second one
(i.e. \cpp{mf} and \cpp{mfdata}).  The instruction \cpp{Z=data(\#2);}
means that for each convex, the ``tensor'' \cpp{Z} will receive the values of the first data argument provided with \cpp{push\_data},
at indexes corresponding to the degrees of freedom attached to the convex of the second (\cpp{\#2}) \cpp{mesh_fem} (here, \cpp{Z $\gets$ F[mfdata.ind_dof_of_element(cv)]}. The
part \cpp{V(\#1)+=\ldots} means that the result of the next expression will be
accumulated into the output vector (provided with \cpp{push\_vec}). Here
again, \cpp{\#1} means that we will write the result at indexes
corresponding to the degrees of freedom of the current convex with respect to the first (\cpp{\#1}) \cpp{mesh_fem}. The
left hand side \cpp{comp(Base(\#1).Base(\#2))(:,j).Z(j)} contains
two operations. The first one is a computation of a tensor on the
convex: \cpp{comp(Base(\#1).Base(\#2))} is evaluated as a
2-dimensions tensor, $\int\phi^i \psi^j$, for all degrees of freedom $i$ of \cpp{mf} and $j$ of \cpp{mfdata} attached to the current convex. The next
part is a reduction operation, \cpp{C(:,j).Z(j)}: each named index
(here $j$) is summed, i.e. the result is $\sum_j c_{i,j} z_j$.

The integration method used inside \cpp{comp(Base(#1).Base(#2))} is
the one of the first \cpp{mesh\_fem} referenced (here, the
\cpp{mesh\_fem \#1}). If you need to use integration methods from another \cpp{mesh\_fem}, you can specify it as the first argument of \cpp{comp}, for example \cpp{comp(\#3, Base(\#1).Grad(\#2))} (New in getfem++-1.7).

An other example is the assembly of the stiffness matrix for a vector Laplacian:
\begin{cppcode}
  getfem::generic_assembly assem;
  assem.push_mf(mf);
  assem.push_mf(mfdata);
  assem.push_data(A);
  assem.push_mat(SM);
  assem.set("a=data$1(#2);"
            "M$1(#1,#1)+=sym(comp(vGrad(#1).vGrad(#1).Base(#2))(:,j,k,:,j,k,p).a(p))");
  assem.volumic_assembly();
\end{cppcode}
Now the output is written in a sparse matrix, inserted with \cpp{assem.push_mat(SM)}. The \cpp{\$1} in \cpp{M\$1(\#1,\#1)} just indicates that we refer to the first matrix ``pushed'' (it is optional, but if the assembly requires two matrices, the second one must be referred this way). The \cpp{sym} function ensure that the result is symmetric (if this is not done, some round-off errors may cancel the symmetricity). Next, the \cpp{comp} part evaluates a 7D tensor, 
\begin{equation*}\int\partial_k \varphi^{i}_{j} \partial_l \varphi^m_n \psi^p,\end{equation*}
where $\varphi^i_j$ is a $jth$ component of the $ith$ base function of \cpp{mf} and $\psi^p$ is a (scalar) base function of the second \cpp{mesh_fem}. Since we want to assemble
\begin{equation*}\int a(x).\nabla\phi^i.\nabla\phi^j,\quad\text{with}\quad a(x)=\sum_p a^p \psi^p(x),\end{equation*}
the reduction is:
\begin{equation*}\sum_{j,k,p}\left(\int \partial_k\varphi^{i}_{j} \partial_k\varphi^m_j \psi^p\right)a^p\end{equation*}
In the \cpp{comp} function, \cpp{vGrad} was used instead of \cpp{Grad} since we
said that we were assembling a {\em vector} Laplacian: that is why
each \cpp{vGrad} part has three dimensions (dof number, component
number, and derivative number). For a scalar Laplacian, we could have
used \cpp{comp(Grad(\#1).Grad(\#1).Base(\#2))(:,k,:,k,p).a(p)}. But the
vector form has the advantage to work in both vector and scalar case.

The last instruction, \cpp{assem.volumic_assembly()}, does evaluate
the expression on each convex. For an assembly over a boundary just
call \cpp{assem.boundary_assembly(boundary_num)}.


The third example shows how to compute the $L^2$ norm of a scalar or vector field on a mesh boundary:
\begin{cppcode}
    assem.push_mf(mf);
    assem.push_data(U);
    std::vector<scalar_type> v(1);
    assem.push_vec(v);
    assem.set("u=data(#1); V()+=u(i).u(j).comp(vBase(#1).vBase(#1))(i,k,j,k)");
    assem.boundary_assembly(boundary_number);
\end{cppcode}
This one is easy to read. When \cpp{boundary_assembly} returns, \cpp{v[0]} will contain 
\begin{equation*}\sum_{i,j,k}\left(\int_{boundary} u_i \varphi^{i}_{k} u_j \varphi^j_k \right)\end{equation*}


The fourth and last example shows assembly of the linear elasticity problem with a complete Hooke tensor:
\begin{cppcode}
 assem.set("h=data\$1(qdim(\#1),qdim(\#1),qdim(\#1),qdim(\#1),\#2);"
           "t=comp(vGrad(\#1).vGrad(\#1).Base(\#2));"
           "e=(t\{:,2,3,:,5,6,:\}+t\{:,3,2,:,5,6,:\}+t\{:,2,3,:,6,5,:\}+t\{:,3,2,:,6,5,:\})/4;"
           "M(\#1,\#1)+= sym(e(:,j,k,:,m,n,p).h(j,k,m,n,p))");
\end{cppcode}
The original equations are:
\begin{equation*}\int\varepsilon(\varphi^i):\sigma(\phi^j),\quad\text{with}\quad
\sigma(u)_{ij}=\sum_{kl} h_{ijkl}(x) \varepsilon_{kl}(u)\end{equation*}
where $h$ is the Hooke tensor, and ':' means the scalar product between matrices.
Since we assume it is not constant, $h$ is given on the second \cpp{mesh_fem}: $h_{ijkl}(x)=\sum_p h_{ijkl}^p \psi^p$.  Hence the first line
declares that the first data ``pushed'' is indeed a five-dimensions
tensor, the first fourth ones being all equal to the target dimension
of the first \cpp{mesh_fem}, and the last one being equal to the
number of degrees of freedom of the second \cpp{mesh_fem}.  The \cpp{comp} part still computes the same 7D tensor than for the
vector Laplacian case.  From this tensor, one evaluates
$\varepsilon(\varphi^i)_{jk}\varepsilon(\phi^l)_{mn}\psi^p$ via permutations, and finally the
expression is reduced against the hook tensor.

{\bf availaible operations inside the \cpp{comp} command}

\begin{itemize}
  \item[\cpp{Base(\#i)}] : evaluate the value of the base functions of the \textit{ith} \cpp{mesh\_fem}
  \item[\cpp{Grad(\#i)}] : evaluate the value of the gradient of the base functions of the \textit{ith} \cpp{mesh\_fem}
  \item[\cpp{Hess(\#i)}] : evaluate the value of the Hessian of the base functions of the \textit{ith} \cpp{mesh\_fem}
  \item[\cpp{Normal()}]: (New in getfem++-1.7) evaluate the unit normal (should not be used for volumic integrations !)
    \item[\cpp{NonLinear\$x(\#mf1,\ldots\#mfn)}] : (New in getfem++-1).7evaluate the \textit{xth} non-linear term (inserted with \cpp{push\_nonlinear\_term(pnonlinear\_elem\_term)}) using the listed mesh\_fem objects.
      \item (New in getfem++-1.7) you may reference any data object inside the \cpp{comp} command, and perform reductions inside the \cpp{comp()}. This feature is mostly interesting for speeding up assembly of nonlinear terms (see getfem\_nonlinear\_elasticy.h for an example of use).
\end{itemize}

{\bf others operations}

Slices may be mixed with reduction operations \cpp{t(:,4,i,i)} takes a slice at index 4 of the second dimension, and reduces the diagonal of dimension 3 and 4. {\em Please note that index numbers for slices start at 1 and not 0 !!} 

\cpp{mdim(\#2)} is evaluated as the mesh dimension associated to the second \cpp{mesh_fem}, while \cpp{qdim(\#2)} is the target dimension of the \cpp{mesh_fem}.

The diagonal of a tensor can be obtained with \cpp{t\{:,:,3,3\}} (which is strictly equivalent to \cpp{t\{1,2,3,3\}}: the colon is just here to improve the readability). This is the same operator than for permutation operations. Note that \cpp{t\{:,:,1,1\}} or \cpp{t\{:,:,4,4\}} are not valid operations. 

The \cpp{print} command can be used to see the tensor: \cpp{"print comp(Base(\#1));"} will print the integrals of the base functions for each convex.

If there is more than one data array, output array  or output sparse matrix, one can use \cpp{data\$2, data\$3, V\$2, M\$2,}\ldots

\section{Incorporate new finite element methods in \gf }

Basically, It is sufficient to describe an element on the reference element, i.e. to describe each base function of each degree of freedom. Vectorial elements and non-equivalent elements are partially supported ... (supported by the finite element kernel but none vector element is implemented for now).\\[0.5cm]
To be done ... please read \cite{BASCOMP} for more details and see the file \filename{getfem\_fem.C} for practical implementation.

\section{Incorporate new approximated integration methods in \gf }

A perl script automatically incorporates new cubature methods from a description file. You can see in the directory {\tt cubature} such description files (with extension {\tt.IM}) . For instance for {\tt IM_TETRAHEDRON(5)} the following file describes the method:

\begin{alltt}
NAME = IM_TETRAHEDRON(5)
N = 3
GEOTRANS = GT_PK(3,1)
NBPT = 4
0, 0.25, 0.25, 0.25, 0.008818342151675485
1, 0.31979362782962991, 0.31979362782962991, 0.31979362782962991, 0.011511367871045398 
1, 0.091971078052723033, 0.091971078052723033, 0.091971078052723033, 0.01198951396316977
1, 0.056350832689629156, 0.056350832689629156, 0.44364916731037084, 0.008818342151675485
NBF = 4
IM_TRIANGLE(5)
IM_TRIANGLE(5)
IM_TRIANGLE(5)
IM_TRIANGLE(5)
\end{alltt}

where {\tt NAME} is the name of the method in \gf (constant integer parameter are allowed), {\tt N} is the dimension, {\tt GEOTRANS} describes a valid geometric transformation of \gf. This geometric transformation just defines the reference element on which the integration method is described. {\tt NBPT} is the number of integration node definitions. Integration node definitions include a symmetry definition such that the total number of integration nodes would be greater than {\tt NBPT}.

Composition of the integration node definition :
\begin{itemize}
  \item an integer : 0 = no symmetry, 1 = full symmetric (x6 for a triangle, x4 for a quadrangle, x24 for a tetrahedron ...),
  \item the {\tt N} coordinates of the integration node,
  \item the load.
\end{itemize}

{\tt NBF} is the number of faces of the reference element (should correspond to {\tt GEOTRANS}). Then follows an already existing integration method for each face (each on a line). This is necessary to make integrations on boundaries.

The file format is inspired from \cite{EncyclopCubature}.

\section{Support for Xfem methods}
\index{GETFEM!Xfem}
Xfem are finite element method with a particular enrichment with non-polynomials functions (see \cite{Xfem} for instance). The file {\tt getfem_Xfem.h} gives a support for this kind of method. Any ($\tau$-equivalent) valid finite element method can be extended. If {\tt pf} is a valid descriptor of a finite element method, one can build a Xfem with the declaration
\begin{alltt}
  Xfem  xf(pf);
\end{alltt}
then one adds a global function with
\begin{alltt}
  xf.add_function(pXf, pXg, pXh, ind);
\end{alltt}
where {\tt pXf} should be a pointer on a type derived from the object {\tt virtual_Xfem_func} representing the global function, {\tt pXg} should be a pointer on a type derived from the object {\tt virtual_Xfem_grad} representing the global function gradient, {\tt pXh} is an optional parameter (only for fourth order derivative problems) which should be a pointer on a type derived from the object {\tt virtual_Xfem_hess} representing the global function Hessian and {\tt ind} is an index which should correspond to this function to identify the degrees of freedom (this should be different for each function added). It is possible to add an arbitrary number of global functions. The total number of degrees of freedom of the Xfem is the number of degrees of freedom of the initial fem times $N_f+1$ where $N_f$ is the number of global functions added.\\[0.5cm]

If $\varphi_i$ for $i=1..N_d$ are the basis functions of {\tt pf} and $f_j$ for 
$j=1..N_f$ the additional global functions, the basis functions of the Xfem are the basis function $\varphi_i$ for $i=1..N_d$ and the basis functions $f_j\varphi_i$ for $i=1..N_d$ and $j=1..N_f$. From an element to another and for each function $f_j$, the corresponding degrees of freedom are connected in a same manner as the corresponding degrees of freedom of {\tt pf}.\\[0.5cm]

Most of the time, one only needs an enrichment on a subset of node of the original element. If it is so, one should a posteriori eliminate the unwanted extra-dofs.

\section{Interpolation of a finite element method on non-matching meshes}

(evolution of \cpp{virtual\_link\_fem}) A special finite element method is defined in \filename{getfem\_interpolated\_fem.h} which is not a real finite element method but allows to interpolate a finite element method defined on another mesh. When an assembling procedure has different finite element methods as arguments, the mesh on which those methods are defined should be the same. If you need to assemble a matrix with finite element methods defined on different meshes, you may use the finite element methods\\[0.5cm]
\index{GETFEM!getfem::interpolated\_fem}
\cpp{getfem::interpolated\_fem(getfem::mesh\_fem mf1, getfem::mesh\_fem mf2) }\\[0.2cm]
Because each base function of the finite element method has to be interpolated, such a computation can be a haevy procedure. By default, the interpolated fem object store the interpolation. \\[0.5cm]

The interpolation is made on each Gauss point of the integration methods of  \cpp{mf2}, so that you have to use these integration methods in the assembling procedures.\\[0.5cm]

For instance if you need to compute the mass matrix between to different finite element methods defined on two different meshes, this is an example of code which interpolate the second f.e.m. on the mesh of the first f.e.m., assuming that \cpp{mf1} and \cpp{mf2} describe the two finite element methods and \cpp{pim} is the chosen integration method.\\[0.5cm]
\begin{cppcode}
  getfem::mesh\_fem mf\_interpole(mf1.linked\_mesh());
  getfem::interpolated\_fem feminterpolated(mf2, mf1);
  dal::bit\_vector nn = mf1.convex\_index();
  mf\_interpole.set\_finite\_element(nn, &feminterpolated, pim);
  getfem::asm\_mass\_matrix(SM1, mf1, mf\_interpole);
\end{cppcode}

The object \cpp{feminterpolated} contains all the information concerning the interpolation. It could use a lot of memory. You have to care that it is not destroyed while you use it in a \cpp{mesh\_fem} structure. To obtain a better accuracy, it is better to refine the integration method (with \cpp{IM_STRUCTURED_COMPOSITE} for instance) rather than improve its order. 

\subsection{mixed methods with different meshes}
  to be described ...
\subsection{mortar methods}
  to be described ...


\section{Compute $L^2$ and $H^1$ norms}

The file \filename{getfem\_assembling.h} defines the functions to compute $L^2$ and $H^1$ norms of a solution. The following functions compute the different norms\\[0.5cm]
\index{GETFEM!asm_L2\_norm(mef, U)}
\index{GETFEM!asm_H1\_norm(mef, U)}
\cpp{getfem::asm_L2\_norm(mef, U); } \\[0.5cm]
\cpp{getfem::asm_H1\_semi\_norm(mef, U); } \\[0.5cm]
\cpp{getfem::asm_H1\_norm(mef, U); } \\[0.5cm]
where \cpp{mef} is a variable of type \cpp{getfem::mesh\_fem} and describes the finite element method on which the solution is defined, \cpp{U} is the vector of values of the solution on each degree of freedom of \cpp{mef}. The size of  \cpp{U} should be \cpp{mef.nb\_dof()}.\\[0.5cm]

\section{Compute derivatives}

The file \filename{getfem\_derivatives.h}  defines the following function to compute the gradient of a solution\\[0.5cm]
\index{GETFEM!getfem::compute\_gradient}
\cpp{getfem::compute\_gradient(mef1, mef2, U, V); }\\[0.5cm]
where \cpp{mef1} is a variable of type \cpp{getfem::mesh\_fem} and describes the finite element method on which the solution is defined, \cpp{mef2} describes the finite element method to compute the gradient, \cpp{U} is a vector representing the solution and should be of size \cpp{mef1.nb\_dof()}, \cpp{V} is the vector on which the gradient will be computed and should be of size
\cpp{N * mef2.nb\_dof()} where \cpp{N} is the dimension of the domain. IMPORTANT : This function only work when \cpp{mef2} is a Lagrange element. This element should be, most of the time, a discontinuous Lagrangian element, because for usual element (for instance \cpp{getfem::PK\_discontinuous\_fem(n, k)}), the gradient is not continuous.

\section{Export and view a solution}

(outdated section, use vtk format and mayavi to see the result, see examples in tests directory)

\subsection{Mesh slices}
Getfem++ provides a \cpp{getfem::mesh_slice} class,
with support general slicing operations on a mesh (slicing with a
plane, half-space, cylinder, sphere, isosurfaces, union or
intersection of slices, etc..). A slice object may be considered as a
P1 discontinuous \cpp{mesh_fem} with fast interpolation ability.  See
\filename{getfem_mesh_slices.h} for more information, and the
\filename{gf_slice.C} file of the getfem-matlab interface for an
example of use.

\section{Interpolation on different meshes}

The file \filename{getfem\_export.h} defines the following function to interpolate a solution from a mesh and a finite element method  to another mesh and another Lagrange finite element method.\\[0.5cm]
\index{GETFEM!getfem::interpolation\_solution}
\cpp{getfem::interpolation\_solution(mef1, mef2, U, V); }\\[0.5cm]
where \cpp{mef1}  is a variable of type \cpp{getfem::mesh\_fem} and describes the finite element method on which the solution is defined, \cpp{mef2} is the finite element method on which the solution will be interpolate,  \cpp{U} is a vector representing the solution and should be of size \cpp{mef1.nb\_dof()}, \cpp{V} is a vector on which the interpolation will be computed and should be of size \cpp{mef2.nb\_dof()}. IMPORTANT : \cpp{mef2} should be of Lagrange type for the interpolation to makes sense but the meshes linked to \cpp{mef1} and \cpp{mef2} may be different (and this is the interest of this function). There is no restriction for the dimension of the domain.\\

If you need to make more than one interpolation between the same finite element methods, it is better to use the function
\cpp{getfem::interpolation\_solution(mef1, mef2, M); }\\[0.5cm]
where \cpp{M} is a row matrix which will be filled with the linear map representing the interpolation (i.e. such that \cpp{V = MU}). The matrix should have the right dimensions (i.e. \cpp{mef2.nb\_dof()} x \cpp{mef1.nb\_dof()}).



\section{The model bricks}
\index{model bricks}
Although it is possible to use assembly procedures on their own to make your finite element programs, it is now possible to use predefined bricks to build up very quickly a certain number of models. Most of the bricks are defined in \cpp{getfem_modeling.h}

\subsection{The model state variable}
\index{GETFEM!getfem::model\_state}
The model state object is an object which stores the state of the system and the tangent system with eventual constraints. There are two predefined model state type:
\begin{alltt}
  getfem::standard_model_state
  getfem::standard_complex_model_state
\end{alltt}
The second one is for models with complex degrees of freedom like Helmholtz problem. These two predefined model state type are built with the following predefined sparse matrix and plain vectors:
\begin{alltt}
  getfem::modeling_standard_sparse_matrix (gmm::col_matrix<gmm::rsvector<double> >)
  getfem::modeling_standard_plain_vector (std::vector<double>)
  getfem::modeling_standard_complex_sparse_matrix (gmm::col_matrix<gmm::rsvector<std::complex<double> > >)
  getfem::modeling_standard_complex_plain_vector (std::vector<std::complex<double> >)
\end{alltt}
But you can define your own model state type with arbitrary types of sparse matrices and plain vector (see the file {\tt getfem_modeling.h})

\subsection{Basic properties of a brick}
A brick represents a basic problem (elasticity, Helmholtz, Poisson problems ...) or a modifier of such problems (Addition of a Dirichlet or Neumann condition, source term, incompressibility term ...).
Each brick will participate on the global linear system to be solved (the tangent system for non linear problem). A brick is an object which derives from \cpp{mdbrick_abstract} with the following virtual methods to be defined:\\[0.5cm]

\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline
  \cpp{brick.nbdof()} & number of total variables including the variables
  of the sub-problem(s) if any.  \\ \hline

  \cpp{brick.nb_constraints()} & number of linear constraints on the system
  including the constraints defined in the sub-problem(s) if any. \\ \hline

  \cpp{brick.compute_tangent_matrix}\cpp{(MS, i0, j0, modified)} & the brick
  has to call the \cpp{compute_tangent_matrix(MS, i0,modified)} of
  sub-problem(s) if any and to compute its own part of the tangent and
  constraint matrices (i0 and j0 are optional arguments representing
  the shifts in the matrices defined in MS) modified indicates if the
  part of the tangent matrix dedicated to this brick will be modified by
  other bricks.\\ \hline

  \cpp{brick.compute_residu(MS, i0, j0)} & the brick has to call the
  \cpp{compute_residu(MS, i0, modified)} of sub-problem(s) if any and has
  to compute its own part of the residu of the linear system and of
  the constraint system (i0 and j0 are the shifts in the residu vectors
  defined in MS). \\ \hline

  \cpp{brick.mixed_variables(bv, i0)} & indicates in bv
  (a \cpp{dal::bit_vector}) the indices of the variables which are
  considered as multipliers or mixed variables\\ \hline

\end{ctableau}

Of course, each specific brick may have additional methods to build
the brick, define some parameters and extract the solution from the
model state variable.

\subsection{Scalar elliptic brick}
The Scalar elliptic brick is a basic brick representing a term such as\\
$$ -div(k\nabla u) = ... $$

where $u$ is a scalar field and $k$ is a positive scalar or a symmetric positive definite order two tensor field. There is two constructors for this brick. The first one is for constant scalar coefficient $k$:
\begin{alltt}
  getfem::mdbrick_scalar_elliptic<MODEL_STATE> brick(mf_u, mf_data, k, mat_stored);
\end{alltt}
where \cpp{mf_u} and \cpp{mf_data} are two valid fem descriptor on the same mesh. \cpp{mf_u} describe the finite element method used for the unknown and \cpp{mf_data} the finite element method used for the parameter $k$. As $k$ is constant \cpp{mf_data} will be chosen to be a constant fem like $P_0$ or $Q_0$ elements. \cpp{k} is a real defining a constant \cpp{k} and \cpp{mat_stored} is an optional parameter (the default value is \cpp{false}) specifying if the stiffness matrix has to be stored in the brick or not. Storing the stiffness matrix in the brick will have a memory cost but allows not to recompute it each time when \cpp{compute_tangent_matrix(...)} is called.

The second constructor is for an arbitrary coefficient $k$:
\begin{alltt}
  getfem::mdbrick_scalar_elliptic<MODEL_STATE> brick(mf_u, mf_data, k, laplace, mat_stored);
\end{alltt}
where \cpp{mf_u} and \cpp{mf_data} are still two valid fem descriptor on the same mesh. Very often, \cpp{k} is still constant or piecewise constant which meand that \cpp{mf_data} will be chosen to be a constant fem like $P_0$ or $Q_0$ elements. \cpp{k} is a vector of type \cpp{MODEL_STATE::vector_type} where \cpp{MODEL_STATE} is the type of model state variable used. \cpp{laplace} is a boolean, it has to be \cpp{true} if \cpp{k} is scalar and \cpp{false} if \cpp{k} is an order two tensor value. The vector \cpp{k} will be filled with either one tensorial or scalar value if the coefficient is constant or with a value on each degree of freedom of \cpp{mf_data} if not. \cpp{mat_stored} is still an optional parameter (the default value is false) specifying if the stiffness matrix has to be stored in the brick or not.

The following additional methods are available on this brick:
\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline
  \cpp{brick.set_coeff(k)} & with \cpp{k} a real, set the coefficient in
  the homogeneous scalar case.  \\ \hline

  \cpp{brick.set_coeff(k, laplace)} & with \cpp{k} a vector of type
  \cpp{MODEL_STATE::vector_type} and laplace a boolean (see previous
  explanation). Set the coefficient \cpp{k}.  \\ \hline

  \cpp{brick.get_solution(MS, V)} & After a solve, extract the solution of the
  model state variable MS and put it in the vector V. \hline
\end{ctableau}

\subsection{Source term brick}
This brick represent either a volumic source term or a Neumann condition, i.e. a term $\int_{\Omega} f.v dx$ or $\int_{\Gamma} f.v dx$ in the weak formulation , with $\Gamma$ a part of$\partial \Omega$. This brick works for both real or complex terms in scalar or vectorial problems. The constructor of this brick is:

\begin{alltt}
  getfem::mdbrick_source_term<MODEL_STATE> brick(problem, mf_data, F, bound, num_fem);
\end{alltt}

where \cpp{problem} is the problem on which the source term will be added (a scalar elliptic brick for instance), \cpp{mf_data} is the finite element description for the source term $f$, F is a vector of type \cpp{MODEL_STATE::vector_type} which contains the values of the source term on each degree of freedom of \cpp{mf_data}, \cpp{bound} is an optional parameter specifying on which boundary of the main mesh fem of \cpp{problem} the Neumann condition is applied. If this parameter is omitted, a volumic source term will be taken into account. \cpp{num_fem} is an optional parameter allowing to choose a fem is the problem has several fems.

The following additional methods are available on this brick:
\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline

  \cpp{brick.set_rhs(F)} & change the value of the source term.  \hline

\end{ctableau}


\subsection{Dirichlet condition brick}
This brick allows to define a Dirichlet condition on a boundary of the domain (i.e. set the value of the unknown on this boundary $u = F$). Two means are available to take into account a Dirichlet condition : with Lagrange multipliers or with a reduction of the linear system. This brick works for both real or complex terms in scalar or vectorial problems. The constructor of this brick is:

\begin{alltt}
  getfem::mdbrick_Dirichlet<MODEL_STATE> brick(problem, mf_data, F, bound, num_fem, with_multipliers);
\end{alltt}

where  \cpp{problem} is the problem on which the Dirichlet condition will be added (a scalar elliptic brick for instance), \cpp{mf_data} is the finite element description for the data, \cpp{F} is a vector of type \cpp{MODEL_STATE::vector_type} which contains the values of the data on each degree of freedom of \cpp{mf_data}, \cpp{bound} specifies on which boundary of the main mesh fem of \cpp{problem} the Dirichlet condition is applied, \cpp{num_fem} is an optional parameter allowing to choose a fem is the problem has several fems (0 is the default) and \cpp{with_multipliers} is a boolean specifying if the Dirichlet condition is applied reducing the system (the default value of this parameter) or with Lagrange multipliers. The parameter \cpp{F} can be omitted, the default value is zero.

The following additional methods are available on this brick:
\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline

  \cpp{brick.set_rhs(F)} & change the value of the data. \hline
  
\end{ctableau}

\subsection{Example of a complete Poisson problem}
If \cpp{mf_u} and \cpp{mf_data} are valid finite element description on a mesh representing the domain on which the problem is defined, the following sequence will define a Poisson (laplacian) problem with a Dirichlet condition on boundary 1 of \cpp{mf_u} and a Neumann condition on boundary 0 of \cpp{mf_u}:

\begin{cppcode}
  typedef getfem::modeling_standard_plain_vector  plain_vector;

  plain_vector U(mf_u.nb_dof()), F(mf_data.nb_dof());

  double k = 1.0;
  getfem::mdbrick_scalar_elliptic<> laplacian(mf_u, mf_data, k);
  
  plain_vector F(mf_data.nb_dof());
  for (int i = 0; i < mf_data.nb_dof(); ++i) F(i) = ...;
  getfem::mdbrick_source_term<> volumic_source_term(laplacian, mf_data, F);
  
  for (int i = 0; i < mf_data.nb_dof(); ++i) F(i) = ...;
  getfem::mdbrick_source_term<> neumann_condition(volumic_source_term, mf_data, F, 0);
  
  for (int i = 0; i < mf_data.nb_dof(); ++i) F(i) = ...;
  getfem::mdbrick_Dirichlet<> final_model(neumann_condition, mf_data, F, 1);

  getfem::standard_model_state MS(final_model);
  gmm::iteration iter(residu, 1, 40000);
  getfem::standard_solve(MS, final_model, iter);

  laplacian.get_solution(MS, U);
\end{cppcode}
Remark how the bricks are linked, each condition is applied to the brick defined with the previous condition. The order of the conditions is of course arbitrary, you can define the Dirichlet condition before the source term for instance.


\subsection{Predefined solvers}
Of course, for many problems, it will be more convenient to make a specific solver. Even so, one generic solver is at the moment available to test your models quickly. It can also be taken as a model to build your own solvers. It is defined in \cpp{getfem_modeling.h} and the call is
\begin{alltt}
  getfem::standard_solve(MS, problem, iter);
\end{alltt}
where \cpp{MS} is a model state variable, \cpp{problem} is the brick  that represent your global problem and \cpp{iter} is an iteration object from Gmm++. See also the previous section for an example of use.


\subsection{Isotropic linearized elasticity brick}
This brick is a basic brick representing a term such as\\
$$ -div(\sigma) = ...; $$

with \\
$$ \ \ \ \sigma = \lambda\mbox{tr}(\varepsilon(u))I + 2\mu\varepsilon(u); \ \ \ \varepsilon(u) = (\nabla u + \nabla u^T)/2. $$

$\varepsilon(u)$ is the small strain tensor, $\sigma$ is the stress tensor, $\lambda$ and $\mu$ are the Lamé coefficients. This represents the system of linearized isotropic elasticity. It can also be used with $\lambda=0$ together with the linear incompressible brick to build the Stokes problem.

There is two constructors for this brick. The first one is for constant Lamé coefficients:
\begin{alltt}
  getfem::mdbrick_isotropic_linearized_elasticity<MODEL_STATE>
     brick(mf_u, mf_data, lambda, mu, mat_stored);
\end{alltt}
where \cpp{mf_u} and \cpp{mf_data} are two valid fem descriptor on the same mesh. \cpp{mf_u} describe the finite element method used for the unknown and \cpp{mf_data} the finite element method used for the Lamé coefficients. As they are constant \cpp{mf_data} will be chosen to be a constant fem like $P_0$ or $Q_0$ elements. \cpp{lambda} and \cpp{mu} are two real defining the constant Lamé coefficients. \cpp{mat_stored} is an optional parameter (the default value is \cpp{false}) specifying if the stiffness matrix has to be stored in the brick or not. Storing the stiffness matrix in the brick will have a memory cost but allows not to recompute it each time when \cpp{compute_tangent_matrix(...)} is called.

The second constructor is for non homogeneous Lamé coefficients:
\begin{alltt}
  getfem::mdbrick_isotropic_linearized_elasticity(mf_u, mf_data, lambda, mu, mat_stored);
\end{alltt}
It has the same form but here \cpp{lambda} and \cpp{mu} are two vectors of type \cpp{MODEL_STATE::vector_type} defining the Lamé coefficients on \cpp{mf_data}.

The following additional methods are available on this brick:
\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline
  \cpp{brick.set_Lame_coeff(lambda, mu)} & with \cpp{lambda} and \cpp{mu} two reals, set the Lamé coefficients in the homogeneous case.  \\ \hline

  \cpp{brick.set_coeff(lambda, mu)} & with \cpp{lambda} and \cpp{mu} two vectors of type
  \cpp{MODEL_STATE::vector_type}. Set the coefficients in the non-homogeneous case.  \\ \hline

  \cpp{brick.get_solution(MS, V)} & After a solve, extract the solution of the
  model state variable MS and put it in the vector V. \hline
\end{ctableau}
The program \cpp{elastostatic.C} in the tests directory of Getfem++ distribution can be taken as a model of use of this brick.

\subsection{Qu term brick}
This brick allows to add boundary conditions of Fourier-Robin type like\\
$$ \frac{\partial u}{\partial n} = Qu $$

for scalar problems, or\\
$$ \sigma n = Qu $$

for linearized elasticity problems. \cpp{Q} is a scalar field in the scalar case or a matrix field in the vectorial case. This brick works for both real or complex terms in scalar or vectorial problems.


The constructor is the following :
\begin{alltt}
  getfem::mdbrick_QU_term<MODEL_STATE> brick(problem, mf_data, Q, bound, numfem);
\end{alltt}
where \cpp{problem} is the problem on which the condition will be added, \cpp{mf_data} is a valid fem descriptor for \cpp{Q}. \cpp{Q} is either a real for the homogeneous and diagonal case, or a vector of type \cpp{MODEL_STATE::vector_type} defining \cpp{Q} on \cpp{mf_data}. \cpp{bound} is the number of the boundary of \cpp{main_mesh_fem()} on which the condition will be applied. \cpp{num_fem} is an optional parameter allowing to choose a fem is the problem has several fems.

The following additional methods are available on this brick:
\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline

  \cpp{brick.set_Q(q)} & change the value of Q. \cpp{q} is either a real value or a vectors of type \cpp{MODEL_STATE::vector_type}. \hline
  
\end{ctableau}

\subsection{Helmholtz brick}
This brick represent the complex or real Helmholtz problem \\
$$ \Delta u + k^2 u = 0; $$
where $k$ the wave number is a real or complex value. For a complex version, a complex model state variable has to be used (for example \cpp{getfem::standard_complex_model_state}, see \cpp{helmholtz.C} in the tests directory)

The constructor is
\begin{alltt}
  getfem::mdbrick_Helmholtz<MODEL_STATE> brick(mf_u, mf_data, k, mat_stored);
\end{alltt}
where \cpp{mf_u} and \cpp{mf_data} are two valid fem descriptor on the same mesh. \cpp{mf_u} describe the finite element method used for the unknown and \cpp{mf_data} the finite element method used for the wave number. \cpp{k} is a real or a vector of type \cpp{MODEL_STATE::vector_type} defining the wave number and  \cpp{mat_stored} is an optional parameter (the default value is \cpp{false}) specifying if the stiffness matrix has to be stored in the brick or not. Storing the stiffness matrix in the brick will have a memory cost but allows not to recompute it each time when \cpp{compute_tangent_matrix(...)} is called.

The following additional methods are available on this brick:
\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline

  \cpp{brick.set_wave_number(k)} & with \cpp{k} ia a real or a vector of type
  \cpp{MODEL_STATE::vector_type}.  \\ \hline

  \cpp{brick.get_solution(MS, V)} & After a solve, extract the solution of the
  model state variable MS and put it in the vector V. \hline
\end{ctableau}

\subsection{linear incompressibility (or nearly incompressibility) brick}
This brick allows to add a linear incompressibility condition (or a nearly incompressible condition) in a problem of type\\
$$ \mbox{div}(u) = 0,\ \ (or \mbox{div}(u) = \varepsilon p)$$

For this, multipliers representing the pressure are introduced in a mixed formulation.

The constructor for the incompessibility condition is:
\begin{alltt}
  getfem::mdbrick_linear_incomp<MODEL_STATE> brick(problem, mf_p, numfem);
\end{alltt}

where  \cpp{problem} is the problem on which the incompressibility condition is applied, \cpp{mf_p} is the finite element description for the pressure (be aware that the LBB inf-sup condition has to be satisfied between the \cpp{main_mesh_fem()} and \cpp{mf_p}. \cpp{num_fem} is an optional parameter allowing to choose a fem is the problem has several fems.

For the nearly incompressibility condition, the constructor is:
\begin{alltt}
  getfem::mdbrick_linear_incomp<MODEL_STATE> brick(problem, mf_p, mf_data, epsilon, numfem);
\end{alltt}
where \cpp{mf_data} is the finite element description on which the penalization parameter is descibed and \cpp{epsilon} is either a (small) real or a vector of type \cpp{gmm::vector<scalar_type>}. In nearly incompressible homogeneous linearized elasticity, one has $\varepsilon = 1 / \lambda$ where $\lambda$ is one of the Lamé coefficient.\\

The following additional methods are available on this brick:
\begin{ctableau}{|m{0.4\linewidth}|m{0.55\linewidth}|}{ll}\hline
  \cpp{brick.set_coeff(epsilon)} & with \cpp{epsilon} either a real or
  a vector of type \cpp{MODEL_STATE::vector_type}, set the penalization
  parameter in the nearly incompressible case.  \hline
\end{ctableau}
~\\

For instance, the following program defines a Stokes problem with a source term and an homogeneous Dirichlet condition on boundary 0. \cpp{mf_u}, \cpp{mf_data} and \cpp{mf_p} have to be valid finite element description on the same mesh.

\begin{cppcode}
  typedef getfem::modeling_standard_plain_vector  plain_vector;

  plain_vector U(mf_u.nb_dof()), F(mf_data.nb_dof());

  double mu = 1.0;
  getfem::mdbrick_isotropic_linearized_elasticity<>
    stokes(mf_u, mf_coef, 0.0, mu);

  getfem::mdbrick_linear_incomp<> incomp(stokes, mf_p);
  
  plain_vector F(mf_data.nb_dof());
  for (int i = 0; i < mf_data.nb_dof(); ++i) F(i) = ...;
  getfem::mdbrick_source_term<> volumic_source_term(incomp, mf_data, F);
  
  gmm::clear(F);
  getfem::mdbrick_Dirichlet<> final_model(volumic_source_term, mf_data, F, 0);

  getfem::standard_model_state MS(final_model);
  gmm::iteration iter(residu, 1, 40000);
  getfem::standard_solve(MS, final_model, iter);

  stokes.get_solution(MS, U);
\end{cppcode}

A example for a nearly incompressibility condition can be found in the program \cpp{elastostatic.C} in tests directory.

\subsection{Small displacement plasticity brick}
This brick modelizes small-displacement quasi-static plasticity problems. It is defined in \cpp{getfem_plasticity.h}

Plasticity happens when you stress an object too much, so that even when you remove the charge, constraints remain 'trapped' into the object. When a stress is applied to an object, if the stress is small enough, the displacements stay elastic. If that stress gets greater than a constant value called stress threshold (intrinsic to the object), then the displacements become plastic.

Quasi-static means that we do not take inertia into account, but that the algorithm used needs some kind of a time representation. It is not possible to put the charge on the model at once, as it will render false results. Instead, we have to put the charge only a bit at a time, and calculate the deformation each time,  hence the 'quasi-static' name. For instance, if you wish to put a 100N/m charge on your object, you should put it by small steps (20,40,60,80,100 is ok). We have to use that method to keep the consistency of the problem.


A brick behaves like a black-box, that is defined by its constructor. A constructor is something like \cpp{getfem::mdbrick_plasticity<> brick(mf_u, mf_coef, lambda, mu, stress_threshold, TOL, flag_hyp);} where :
\begin{itemize}
\item mf_u and mf_coef are 2 meshes that define the geometry and the finite elements method of the problem (type : \cpp{getfem::mesh_fem})
\item lambda and mu are Lame coefficients that define the problem (type : if the problem is homogeneous, \cpp{scalar_type}. If not, \cpp{gmm::vector<scalar_type>}. Its size must be equal to the number of degree of freedom of the system.)
\item stress_threshold is the 'elasticity limit' : if constraints are below that limit, the problem is an elasticity problem. Else, it is a plasticity one. (type : \cpp{scalar_type})
\item TOL is a small number that defines what is zero. (type : \cpp{scalar_type})
\item flag_hyp is zero if the problem is 3D or '2D plane'. Other cases are not implemented, yet. (type : \cpp{size_type})
\end{itemize}


Using that constructor, you can build the problem like with any other bricks, adding the Volumic, Neumann and Dirichlet bricks as usual (look at elastostatic.C and plasticity.C in tests directory for examples), and call the solver with \cpp{getfem::standard_solve(MS, final_model, iter);}.


Once it's done, you need to know what the results are. 
You can know the displacement using \cpp{brick.get_solution(MS, U);} where MS is defined by \cpp{getfem::standard_model_state MS(final_model);}, and U the displacement vector.


To get the constraints, you can use \cpp{brick.compute_constraints(MS);} followed by \cpp{brick.get_proj(proj);}, where proj is a \cpp{std::vector<std::vector<scalar_type> >}.

\subsection{Contact and friction conditions brick}
(to be documented, see the test program dynamic_friction.C)
\subsection{Linearized plate brick}
(to be documented, see the test program plate.C)
\subsection{Large strain elasticity brick}
This brick represent a large strain elasticity problem. It is defined in \cpp{getfem_nonlinear_elasticity.h}

The constructor is:
\begin{alltt}
  getfem::mdbrick_nonlinear_elasticity<MODEL_STATE> brick(Hyperelastic_Law, mf_u, mf_data, params);
\end{alltt}
where \cpp{Hyperelastic_Law} is an object representing the considered hyperelastic law. It has to be chosen between:
\begin{alltt}
  getfem::SaintVenant_Kirchhoff_hyperelastic_law Hyperelastic_Law;
  getfem::Ciarlet_Geymonat_hyperelastic_law Hyperelastic_Law;
  getfem::Mooney_Rivlin_hyperelastic_law Hyperelastic_Law;
\end{alltt}
The Saint-Venant Kirchhoff law is a linearized law defined with the two Lamé coefficients, Ciarlet Geymonat law is defined with the two Lamé coefficients and an additional coefficient and the Mooney-Rivlin law is defined with two coefficients and is to be used with the large strain incompressibility condition.\\

\cpp{mf_u} and \cpp{mf_data} are two valid fem descriptor on the same mesh. \cpp{mf_u} describe the finite element method used for the unknown and \cpp{mf_data} the finite element method used for the parameters of the selected hyperelastic law. \cpp{k} is a vector of type \cpp{MODEL_STATE::vector_type} defining the parameters on \cpp{mf_data}.

The program \cpp{nonlinear_elastostatic.C} in tests directory is an example of use of this brick with or without an incompressibility condition.

\subsection{Large strain incompressibility brick}
This brick allows to add an incompressibility condition in a large strain problem of type\\
$$ \mbox{det}(I+\nabla u) = 1, $$

For this, multipliers representing the pressure are introduced in a mixed formulation.

The constructor is:
\begin{alltt}
  getfem::mdbrick_nonlinear_incomp<MODEL_STATE> brick(problem, mf_p, numfem);
\end{alltt}

where  \cpp{problem} is the problem on which the incompressibility condition is applied, \cpp{mf_p} is the finite element description for the pressure (be aware that the LBB inf-sup condition has to be satisfied between the \cpp{main_mesh_fem()} and \cpp{mf_p}. \cpp{num_fem} is an optional parameter allowing to choose a fem is the problem has several fems.

The program \cpp{nonlinear_elastostatic.C} in tests directory is an example of use of this brick.

\section{Catch errors}
\index{errors}

Errors used in Getfem++ are defined in the file \filename{dal\_except.h}. In order to make easier  the error catching all errors derive from the type \cpp{std::logic\_error} defined in the file \cpp{ stdexcept} of the S.T.L.\\[0.5cm]
A standard procedure, \cpp{DAL\_STANDARD\_CATCH\_ERROR}, is defined in \cpp{dal\_except.h}. This procedure catches all errors and print the error message when an error occurs. It can be used in the main procedure of the program as follows\\[0.5cm]
\begin{cppcode}
  int main(void) \{ 
    try \{ 
      ... main program ... 
        \} 
     DAL\_STANDARD\_CATCH\_ERROR;
  \}
\end{cppcode}

\section{Example : Laplacian program}
\index{laplacian}
\index{Poisson problem}

The program \filename{laplacian} is provided in the directory \filename{tests} of \gf  distribution. This program compute the solution of the Poisson problem in a parellepiped domain in any dimension with various finite element methods and elements. This program can be used as a model to build application programs. To compile it execute a {\tt gmake check} on the root directory of \gf . Once the program is compiled you can test it executing the command\\[0.5cm]
{\tt laplacian laplacian.param}\\[0.5cm]
The file \filename{laplacian.param} is the parameter file. You can edit it and test various situation. The following parameter can be changed\\[0.5cm]

\begin{tabular}{|m{0.2\linewidth}|l|} \hline
  {\tt LX, LY} and {\tt LZ} &  Dimensions of the domain. \\ \hline
  {\tt FT} &  parameter for the exact solution. \\ \hline
  {\tt MESH\_TYPE} & name of the geometric transformation used for the mesh cells, for example ``GT_PK(2,1)'' for triangles\\ \hline
  {\tt NX} &  Number of element in each dimension. \\ \hline
  {\tt MESH_NOISE} &  if non-zero, a random perturbation is applied to the interior nodes of the mesh.\\ \hline
  {\tt INCLINE} &  Incline of the mesh.\\ \hline
  {\tt FEM\_TYPE} & name of finite element method (i.e. FEM_PK(2,1))\\ \hline
  {\tt INTEGRATION} & name of integration method (i.e. IM_TRIANGLE(6))\\ \hline
  {\tt RESIDU} & Residu for conjugate gradient. \\ \hline
  {\tt ROOTFILENAME} & Root name for data files. \\ \hline
\end{tabular}


The mesh is exported as \filename{laplacian.mesh}. The program print the $L^2$ and $H^1$ error from an exact solution.\\[0.5cm]
\index{elastostatic}
The program \filename{elastostatic} is built in a same way and compute the solution of linear elasticity problem.

\begin{thebibliography}{99}
% \bibliographystyle{apalike}
% \bibliographystyle{plain}
% \bibliography{all}

\bibitem{EncyclopCubature}
  R. {\texonly{\sc} Cools}
  {\it An Encyclopaedia of Cubature Formulas}, J. Complexity, {\tt http://www.cs.kuleuven.ac.be/\verb+~+ines/research/ecf/ecf.html}

\bibitem{Xfem}
  N. {\texonly{\sc} Moës, J. Dolbow and T. Belytschko}
  {\it A finite element method for crack growth without remeshing },
  Int. J. Num. Meth. Engng. 46, 131-150 (1999).  

\bibitem{dh-to1984} 
  {\texonly{\sc} G. Dhatt, and  G. Touzot}
  {\it The Finite Element Method Displayed}, 
  J. Wiley \& Sons,  New York, 1984.

\bibitem{BASCOMP}
  Y. {\texonly{\sc} Renard},
  {\it Elementary Computations in \gf }, 2002.

\bibitem{FEMLIST}
  Y. {\texonly{\sc} Renard},
  {\it Description of Finite Element and Integration Methods in \gf }, 2002.

\end{thebibliography}

\W \section*{Index}
\texorhtml{\printindex}{\label{gfmindex}\htmlprintindex}

\end{document}
