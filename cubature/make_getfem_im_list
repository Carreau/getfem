
# -*- perl -*-
eval 'exec perl -S $0 "$@"'
  if 0;

$prefix = "inte";
$count = int(1000 * rand);
if ($ENV{TMPDIR} eq "") { $tmpdir = "/tmp"; } else { $tmpdir = $ENV{TMPDIR} }
if (substr($tmpdir, length($tmpdir)-1, 1) eq "/")
  { $tmpdir = substr($tmpdir, 0, length($tmpdir)-1); }
do { $tmp1 = $tmpdir."/".$prefix."\_$count"; ++$count; } while (-f $tmp1);
do { $tmp2 = $tmpdir."/".$prefix."\_$count"; ++$count; } while (-f $tmp2);
do { $tmp3 = $tmpdir."/".$prefix."\_$count"; ++$count; } while (-f $tmp3);
do { $tmp4 = $tmpdir."/".$prefix."\_$count"; ++$count; } while (-f $tmp4);
do { $tmp5 = $tmpdir."/".$prefix."\_$count"; ++$count; } while (-f $tmp5);

sub catch { `rm -f $tmp1 $tmp2 $tmp3 $tmp4 $tmp5`; }
$SIG{INT} = 'catch';

sub read_line {
  while(1) {
    $li = <DATAF>; if (!($li)) { return; }
    chomp($li); ($li, $a) = split('\%', $li, 2);
    $li =~s/\s//g;
    if ($li) { return; }
  }
}

open(TMPF1, ">$tmp1") or die "Open file impossible : $!\n";
open(TMPF2, ">$tmp2") or die "Open file impossible : $!\n";
open(TMPF3, ">$tmp3") or die "Open file impossible : $!\n";
open(TMPF4, ">$tmp4") or die "Open file impossible : $!\n";
open(TMPF5, ">$tmp5") or die "Open file impossible : $!\n";

print TMPF1 "  static im_desc im_desc_tab[NB_IM] = {\n";
print TMPF3 "  static long_scalar_type im_desc_real[NB_IMR] = {\n";
print TMPF4 "  static char * im_desc_face_meth[NB_IMF] = {\n";
print TMPF5 "  static char * im_desc_node_type[NB_IMN] = {\n";

$lss = `ls IM*`;
$nb_methods = 0;
$nb_faces = 0;
$nb_real = 0;
$nb_int = 0;

while ($lss) {

  ($filename, $lss) = split('\n', $lss, 2);

  if (!($filename=~/\~/) && !($filename=~/\#/)) {
    open(DATAF, $filename) or die "Open file impossible : $!\n";
    read_line;
    if (!($li=~/NAME=/))
      { die "Impossible to read $filename : no NAME found\n"; }
    ($a, $name) = split('=', $li, 2);
    print "Making $name\n";
    read_line;
    if (!($li=~/N=/)) { die "Impossible to read $filename : no N found\n"; }
    ($a, $N) = split('=', $li, 2); $N *= 1;
    read_line;
    if (!($li=~/GEOTRANS=/))
      { die "Impossible to read $filename : no GEOTRANS found\n"; }
    ($a, $geotrans) = split('=', $li, 2); $N *= 1;
    read_line;
    if (!($li=~/NBPT=/))
      { die "Impossible to read $filename : no NBPT found\n"; }
    ($a, $nbpt) = split('=', $li, 2); $nbpt *= 1;
    if ($nbpt) { print TMPF5 "    "; print TMPF3 "    // $name\n"; }
    for ($i = 0; $i < $nbpt; ++$i) {
      read_line;
      if (!($li=~/,/))
      { die "Impossible to read $filename : integration node unreadable\n"; }
      ($a, $b) = split(',', $li, 2);
      print TMPF5 $a, ", ";
      for ($j = 0; $j < $N; ++$j) {
	if (!($b=~/,/))
	{ die "Impossible to read $filename : wrong number of coordinates\n"; }
	($a, $b) = split(',', $b, 2);
	print TMPF3 "    ", $a, ",\n";
      }
      if (!($b))
	{ die "Impossible to read $filename : wrong number of coordinates\n"; }
      print TMPF3 "    ", $b, ",\n";
    }
    if ($nbpt) { print TMPF5 " // $name\n"; }
    read_line;
    if (!($li=~/NBF=/))
      { die "Impossible to read $filename : no NBF found\n"; }
    ($a, $nbf) = split('=', $li, 2); $nbf *= 1;
    if ($nbf) { print TMPF4 "    // $name\n    "; }
    for ($i = 0; $i < $nbf; ++$i) {
      read_line;
      print TMPF4 "\"$li\",";
    }
    if ($nbf) { print TMPF4 "\n"; }
    close(DATAF);
    $nb_methods++;
    print TMPF1 "    \"$name\", \"$geotrans\", $nb_real, $nb_faces, $nb_int,\n";
    $nb_faces += $nbf;
    $nb_real += $nbpt * ($N + 1);
    $nb_int += $nbpt;
  }
}

print TMPF2 "// This file is generated by make_getfem_list\n";
print TMPF2 "
/* *********************************************************************** */
/*                                                                         */
/* Copyright (C) 2000-2003  Yves Renard.                                   */
/*                                                                         */
/* This file is a part of GETFEM++                                         */
/*                                                                         */
/* This program is free software; you can redistribute it and/or modify    */
/* it under the terms of the GNU Lesser General Public License as          */
/* published by the Free Software Foundation; version 2.1 of the License.  */
/*                                                                         */
/* This program is distributed in the hope that it will be useful,         */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of          */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           */
/* GNU Lesser General Public License for more details.                     */
/*                                                                         */
/* You should have received a copy of the GNU Lesser General Public        */
/* License along with this program; if not, write to the Free Software     */
/* Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,  */
/* USA.                                                                    */
/*                                                                         */
/* *********************************************************************** */
\n\n 
namespace getfem {\n\n
  static const int NB_IM=$nb_methods;\n\n";
print TMPF1 "  };\n\n  static const int NB_IMR=$nb_real; \n\n";
print TMPF3 "  };\n\n  static const int NB_IMF=$nb_faces; \n\n";
print TMPF4 "  };\n\n  static const int NB_IMN=$nb_int; \n\n";
print TMPF5 "  };\n\n}\n\n";

close(TMPF1); close(TMPF2); close(TMPF3); close(TMPF4); close(TMPF5);

`cat $tmp2 $tmp1 $tmp3 $tmp4 $tmp5 > getfem_in_list.h`;
`rm -f $tmp1 $tmp2 $tmp3 $tmp4 $tmp5`;
