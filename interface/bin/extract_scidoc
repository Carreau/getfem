#!/usr/bin/env python

import re
import string
import os
import textwrap
import sys

class ParseError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def RemoveSpacesInFNames(d):
    """Replace MESH:GET('max pid') with MESH:GET('max_pid')."""
    n=1
    while n:
        (d,n)=re.subn(r"(:[A-Z]+ *\('[a-z_]+) ([a-z_ ]+')", r"\1_\2",d)
    return d

def find_closing_brace(s):
    lev = 0
    cnt = 0
    for c in s:
        if (c == '{'):
            lev+=1
        if (c == '}'):
            lev-=1
            if (lev == -1):
                return cnt
        cnt += 1
    raise ParseError, s

def FilterPythonSections(d):
    w = 0
    markup = ['@MATLAB{', '@PYTHON{']
    ll = d.split(markup[w])
    d = ll[0]
    for l in ll[1:]:
        d += l[(find_closing_brace(l)+1):]
    ll = d.split(markup[1-w])
    d = ll[0]
    for l in ll[1:]:
        p = find_closing_brace(l)
        d += l[:p] + l[p+1:]
    return d

def SubstituteTypes(d):
    transtypes = { '@dmat':'mat',
                   '@mat':'mat',
                   '@ivec':'ivec',
                   '@dvec':'vec',
                   '@cvec':'vec',
                   '@dcvec':'vec',
                   '@vec':'vec',
                   '@int' :'int',
                   '@bool':'bool',
                   '@real':'real',
                   '@scalar':'scalar',
                   '@str':'string',
                   '@list':'list',
                   '@imat':'imat',
                   '@tmesh':'Mesh',
                   '@tmim':'MeshIm',
                   '@tmf':'MeshFem',
                   '@tbrick':'MdBrick',
                   '@tstate':'MdState',
                   '@tmodel':'Model',
                   '@teltm':'Eltm',
                   '@tfem':'Fem',
                   '@tgt':'GeoTrans',
                   '@tinteg':'Integ',
                   '@tls':'LevelSet',
                   '@tsl':'Slice',
                   '@tsp':'Spmat',
                   '@tpre':'Precond',
                   }
    for (k,v) in transtypes.items():
        d = string.replace(d, k, v)
    return d

def WrapParagraphs(d):
    doc = ''
    for l in re.split(r'(<[Pp]ar>)', d):
        if l.startswith('<Par>'):
            doc += textwrap.fill(l[5:],78)
            doc += '\n\n'
        elif l.startswith('<par>'):
            doc += textwrap.fill(l[5:],78)
            doc += '\n'
        else: doc += textwrap.fill(l,78)
    doc = doc.strip('\n')
    return doc

def ScilabRewriteDoc(d):
    d = d.strip('\n')
    d = RemoveSpacesInFNames(FilterPythonSections(d))
    trans = {'MESH:INIT': r"gf_mesh(", \
             'MESH:GET': r"gf_mesh_get(M", \
             'MESH:SET': r"gf_mesh_set(M", \
             'MESHFEM:GET': r"gf_mesh_fem_get(MF,'", \
             'MESHFEM:SET': r"gf_mesh_fem_set(MF,'", \
             'MESHIM:GET': r"gf_mesh_im_get(MIM,", \
             'MESHIM:SET': r"gf_mesh_im_set(MIM,'", \
             'SLICE:GET': r"gf_slice_get(SL,", \
             'SLICE:SET': r"gf_slice_set(SL,", \
             'MDBRICK:GET': r"gf_mdbrick_get(b,", \
             'MDBRICK:SET': r"gf_mdbrick_set(b,", \
             'MDSTATE:GET': r"gf_mdstate_get(mds,", \
             'MDSTATE:SET': r"gf_mdstate_set(mds,", \
             'MODEL:GET': r"gf_model_get(mds,", \
             'MODEL:SET': r"gf_model_set(mds,", \
             'CVSTRUCT:GET': r"gf_cvstruct_get(CVS,", \
             'GEOTRANS:GET': r"gf_geotrans_get(CVS,", \
             'INTEG:GET': r"gf_integ_get(IM,", \
             'FEM:GET': r"gf_fem_get(fe,", \
             'SPMAT:GET': r"gf_spmat_get(M,", \
             'SPMAT:SET': r"gf_spmat_set(M,", \
             'PRECOND:GET': r"gf_precond_get(P,", \
             'LEVELSET:GET': r"gf_levelset_get(ls,", \
             'LEVELSET:SET': r"gf_levelset_set(ls,", \
             '::COMPUTE' : r"gf_compute(MF, U,", \
             '::ASM' : r"gf_asm("}

    for (k,v) in trans.items():
        #d = re.sub(k+"\('([a-zA-Z]*)'(,.*\))",v, d)
        d = string.replace(d,k,v)

    d = string.replace(d,'SLICE:INIT','gf_slice')
    d = string.replace(d,'MDBRICK:INIT','gf_mdbrick')
    d = string.replace(d,'MDSTATE:INIT','gf_mdstate')
    d = string.replace(d,'MODEL:INIT','gf_model')
    d = string.replace(d,'MESHFEM:INIT','gf_mesh_fem')
    d = string.replace(d,'MESHIM:INIT','gf_mesh_im')
    d = string.replace(d,'GEOTRANS:INIT','gf_geotrans')
    d = string.replace(d,'INTEG:INIT','gf_integ')
    d = string.replace(d,'FEM:INIT','gf_fem')
    d = string.replace(d,'ELTM:INIT','gf_eltm')
    d = string.replace(d,'SPMAT:INIT','gf_spmat')
    d = string.replace(d,'PRECOND:INIT','gf_precond')
    d = string.replace(d,'LEVELSET:INIT','gf_levelset')
    d = string.replace(d,'MESHLEVELSET:INIT','gf_mesh_levelset')
    d = string.replace(d,'::LINSOLVE','gf_linsolve')
    d = string.replace(d,'::UTIL','gf_util')
        
    d = SubstituteTypes(d)
    d = string.replace(d, '@CELL','')
    d = string.replace(d,'((','(')
    d = string.replace(d,'@FUNC','')
    d = WrapParagraphs(d)
    return d

class ExtractDoc:
    def __init__(self, s):
        (self.type, self.synopsis) = s.split('\n',1)[0].split(' ',1)
        m = re.search(r"([A-Z:]+) *\( *'([a-z0-9A-Z _.]*)'(.*)\)",self.synopsis)
        if (not m):
            raise ParseError, s
        self.categ = m.group(1) # 'MESH:GET' etc
        self.name = m.group(2)  # 'pts', 'optimize_structure',...
        self.args = m.group(3)  # ', int dim, ...'

        if (self.name[0]=='.'):# that is the case of name hidden in synopsis
          syn = self.synopsis
          syn = syn[:syn.find("'")]+syn[syn.find(",",syn.find("'")+1)+1:]
          self.synopsis = syn

        l = s.split('\n',1)
        if (len(l)==2):
            self.rawdoc = textwrap.dedent(l[1])
        else:
            self.doc = "Undocumented."
    def __repr__(self):
        return "cat='%s' type='%s', name='%s', args='%s'" % \
               (self.categ,self.type,self.name,self.args)

def ExtractDocFromCppFile(fname):
    docs = {}
    in_doc = 0

    sys.stderr.write('reading %s:' % (fname))
    f = open(fname)
    for l in f:
        if (l.strip().startswith('/*@')):
            in_doc = 1
            docline = l.strip()[3:].strip()
        elif (l.find('@*/') != -1):
            in_doc = 0
            docline += l[:l.find('@*/')]
            ed = ExtractDoc(docline)
            docs[ed.name] = ed
            sys.stderr.write(' '+ed.name)
        elif (in_doc):
            docline += l
    f.close()
    sys.stderr.write('\n')
    return docs

def CommaIf(cond):
    return cond and ", " or ""

def WriteScilabSubFunctionDoc(ed):
    if (ed.type != 'TEXT'):
        d = '* '+ScilabRewriteDoc(ed.synopsis+r'<par>'+ed.rawdoc)
        print '  <para>'
        print '  '.join(['  '+s for s in d.split('\n')])
        print '  </para>'
    else:
        print '  <para>'
        print '  %s' % ScilabRewriteDoc(ed.rawdoc)
        print '  </para>'

def LookupDoc(what):
    """return the ExtractDoc for what = @RDATTR MESH:GET('nbpts') etc"""
    what = what.strip()
    ed = ExtractDoc(what)
    if (not docs.has_key(ed.categ)):
        sys.stderr.write('Undocumented category : %s\n' % ed.categ)
        raise ParseError, what
    d = docs[ed.categ]
    if (not d.has_key(ed.name)):
        raise ParseError, 'CANNOT FIND KEY for for %s:%s\n' % (ed.categ,ed.name)
    if (d[ed.name].type != ed.type):
        raise ParseError, 'WRONG TYPE : for %s:%s\n  Found %s, expected %s' % (ed.categ,ed.name,ed.type,d[ed.name].type)
    return d[ed.name]

def UpdateScilabDoc(fname):
    Cfname = fname
    Scifname = string.replace(fname,'.cc','')
    # Write the XML header
    print '<?xml version="1.0" encoding="UTF-8"?>'
    print '<refentry version="5.0-subset Scilab" xml:id="%s" xml:lang="en"' % Scifname
    print '          xmlns="http://docbook.org/ns/docbook"'
    print '          xmlns:xlink="http://www.w3.org/1999/xlink"'
    print '          xmlns:xi="http://www.w3.org/2001/XInclude"'
    print '          xmlns:svg="http://www.w3.org/2000/svg"'
    print '          xmlns:mml="http://www.w3.org/1998/Math/MathML"'
    print '          xmlns:html="http://www.w3.org/1999/xhtml"'
    print '          xmlns:db="http://docbook.org/ns/docbook">'

    # Write the refnamediv section
    print '<refnamediv>'
    print '  <refname>%s</refname>' % Scifname
    print '  <refpurpose></refpurpose>'
    print '</refnamediv>'

    # Write the synopsisdiv section
    print '<refsynopsisdiv>'
    print '  <title>Calling Sequence</title>'
    print '  <synopsis>'

    all = open(Cfname).read()
    for l in all.split('\n'):
        if (l.strip().startswith('/*@FUNC')):
            # ed = ScilabRewriteDoc(l.strip()[1:])
            ed = ScilabRewriteDoc(l)
            ed = ExtractFunctionPrototypes(ed)
            for elem in ed:
                param1, param2, param3 = elem
                param1 = string.replace(param1,'{','[');
                param1 = string.replace(param1,'}',']');
                param3 = string.replace(param3,'{','list(');
                param3 = string.replace(param3,'}',')');
                print '    %s = %s(%s)' % (param1,param2,param3)

    print '  </synopsis>'
    print '</refsynopsisdiv>'

    # Write the parameters section
    print '<refsection>'
    print '  <title>Parameters</title>'
    print ''
    print '  <variablelist>'
    print '    <varlistentry>'
    print '      <term></term>'
    print '      <listitem>'
    print '        <para></para>'
    print '      </listitem>'
    print '    </varlistentry>'
    print '  </variablelist>'
    print '</refsection>'

    # Write the description section
    print '<refsection>'
    print '  <title>Description</title>'

    all = open(Cfname).read().split('/*MLABCOM',1)[1].split('MLABCOM*/')[0].strip()
    for l in all.split('\n'):
        if (l.strip().startswith('@')):
            ed = LookupDoc(l.strip()[1:])
            WriteScilabSubFunctionDoc(ed)
        else:
            print '  <para>'
            print '  %s' % l
            print '  </para>'

    print '</refsection>'

    # Write the example section
    print '<refsection>'
    print '  <title>Examples</title>'
    print '  <programlisting role="example"> '
    print '  Add an example here'
    print ' </programlisting>'
    print '</refsection>'

    # Write the see also section
    print '<refsection>'
    print '  <title>See Also</title>'
    print '  <simplelist type="inline">'
    print '    <member><link linkend="???">???</link></member>'
    print '  </simplelist>'
    print '</refsection>'

    # Write the authors section
    print '<refsection>'
    print '  <title>Authors</title>'
    print '  <para>Y. Collette</para>'
    print '</refsection>'

    # Write the end tag of the refsection
    print '</refentry>'

def ExtractFunctionPrototypes(d):
    locate_function= re.compile("\s*\\*\s*([^=]*)\s=\s([^\(]*)\(([^\)]*)\)",re.MULTILINE|re.DOTALL)
    return locate_function.findall(d)

if (len(sys.argv) < 2):
    raise SystemExit, "give the filename to update, or just 'python'"

fmap = {'gf_mesh.cc':'MESH:INIT',
        'gf_mesh_get.cc':'MESH:GET',
        'gf_mesh_set.cc':'MESH:SET',
        'gf_slice.cc':'SLICE:INIT',
        'gf_slice_get.cc':'SLICE:GET',
        'gf_slice_set.cc':'SLICE:SET',
        'gf_mesh_fem.cc':'MESHFEM:INIT',
        'gf_mesh_fem_get.cc':'MESHFEM:GET',
        'gf_mesh_fem_set.cc':'MESHFEM:SET',
        'gf_mesh_im.cc':'MESHIM:INIT',
        'gf_mesh_im_get.cc':'MESHIM:GET',
        'gf_mesh_im_set.cc':'MESHIM:SET',
        'gf_fem.cc':'FEM:INIT',
        'gf_fem_get.cc':'FEM:GET',
        'gf_eltm.cc':'ELTM:INIT',
        'gf_cvstruct_get.cc':'CVSTRUCT:GET',
        'gf_geotrans.cc':'GEOTRANS:INIT',
        'gf_geotrans_get.cc':'GEOTRANS:GET',
        'gf_integ.cc':'INTEG:INIT',
        'gf_integ_get.cc':'INTEG:GET',
        'gf_mdbrick.cc':'MDBRICK:INIT',
        'gf_mdbrick_get.cc':'MDBRICK:GET',
        'gf_mdbrick_set.cc':'MDBRICK:SET',
        'gf_mdstate.cc':'MDSTATE:INIT',
        'gf_mdstate_get.cc':'MDSTATE:GET',
        'gf_mdstate_set.cc':'MDSTATE:SET',
        'gf_model.cc':'MODEL:INIT',
        'gf_model_get.cc':'MODEL:GET',
        'gf_model_set.cc':'MODEL:SET',
        'gf_spmat.cc':'SPMAT:INIT',
        'gf_spmat_get.cc':'SPMAT:GET',
        'gf_spmat_set.cc':'SPMAT:SET',
        'gf_precond.cc':'PRECOND:INIT',
        'gf_precond_get.cc':'PRECOND:GET',
        'gf_levelset.cc':'LEVELSET:INIT',
        'gf_levelset_get.cc':'LEVELSET:GET',
        'gf_levelset_set.cc':'LEVELSET:SET',
        'gf_mesh_levelset.cc':'MESHLEVELSET:INIT',
        'gf_mesh_levelset_get.cc':'MESHLEVELSET:GET',
        'gf_mesh_levelset_set.cc':'MESHLEVELSET:SET',
        'gf_asm.cc':'::ASM',
        'gf_linsolve.cc':'::LINSOLVE',
        'gf_util.cc':'::UTIL',
        'gf_compute.cc':'::COMPUTE'}

docs = {}

for (fname,cat) in fmap.items():
    docs[cat] = ExtractDocFromCppFile(fname)

if (sys.argv[1].endswith('.cc')):
    UpdateScilabDoc(sys.argv[1])
else:
    raise SystemExit, "don't know file "+sys.argv[1]
