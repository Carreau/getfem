#!/usr/bin/env python
# -*- python -*-
#
# Copyright (C) 2004-2009 Yves Renard, Julien Pommier.
#                                                       
# This file is a part of GETFEM++                                         
#                                                                         
# GetFEM++  is  free software;  you  can  redistribute  it  and/or modify it
# under  the  terms  of the  GNU  Lesser General Public License as published
# by  the  Free Software Foundation;  either version 2.1 of the License,  or
# (at your option) any later version.
# This program  is  distributed  in  the  hope  that it will be useful,  but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or  FITNESS  FOR  A PARTICULAR PURPOSE.  See the GNU Lesser General Public
# License for more details.
# You  should  have received a copy of the GNU Lesser General Public License
# along  with  this program;  if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.
#
############################################################################
"""  Autofunc and autodoc for python interface.

  This program is used to extract the function prototypes and documentation
  from C++ interface to python interface.

  $Id$
"""
import re
import string
import os
import textwrap
import sys

class ParseError(Exception):
    def __init__(self, value):
      self.value = value
    def __str__(self):
      return repr(self.value)

def ExceptionsRewrite(d):
    """renames some ambiguous commands for python.

    for example, mesh_set('pts') and mesh_get(pts) => problem with mesh.pts().
    """
    d = string.replace(d, "MESH:SET('pts'", "MESH:SET('set_pts'")
    d = string.replace(d, "SLICE:SET('pts'", "SLICE:SET('set_pts'")
    d = string.replace(d, "MESHFEM:SET('qdim'", "MESHFEM:SET('set_qdim'")
    d = string.replace(d, "MESHFEM:SET('fem'", "MESHFEM:SET('set_fem'")
    d = string.replace(d, "MDSTATE:SET('state'", "MDSTATE:SET('set_state'")
    d = string.replace(d, "MODEL:SET('state'", "MODEL:SET('set_state'")
    d = string.replace(d, "MODEL:SET('variable'", "MODEL:SET('set_variable'")
    d = string.replace(d, "MESHIM:SET('integ'", "MESHIM:SET('set_integ'")
    d = re.sub("(MESHFEM:SET\('classical[ _]fem')",
               "MESHFEM:SET('set_classical_fem'", d)
    d = re.sub("(MESHFEM:SET\('classical[ _]discontinuous[ _]fem')",
               "MESHFEM:SET('set_classical_discontinuous_fem'", d)
    d = string.replace(d, "MESH:SET('region'", "MESH:SET('set_region'")

    d = string.replace(d, "MDBRICK:SET('param'", "MDBRICK:SET('set_param'")
    d = string.replace(d, "MDBRICK:SET('constraints'", "MDBRICK:SET('set_constraints'")
    d = string.replace(d, "MDBRICK:SET('constraints_rhs'", "MDBRICK:SET('set_constraints_rhs'")
    d = string.replace(d, "LEVELSET:SET('values'", "LEVELSET:SET('set_values'")
    return d;

def RemoveSpacesInFNames(d):
    """Replace MESH:GET('max pid') with MESH:GET('max_pid')."""
    n=1
    while n:
      (d,n)=re.subn(r"(:[\w]+ *\('[\w]+) ([\w\s]+')", r"\1_\2",d)
    return d

def find_closing_brace(s):
    lev = 0
    cnt = 0
    for c in s:
      if (c == '{'):
        lev+=1
      if (c == '}'):
        lev-=1
        if (lev == -1):
          return cnt
      cnt += 1
    raise ParseError, s

def CellToTuples(d):
    while 1:
      s = ''
      p = d.find('@CELL{')
      #sys.stderr.write('p=%d\n' % (p,))
      if (p == -1):
        s += d
        break
      s += d[:p]+'('
      d = d[p+6:]
      p2 = find_closing_brace(d)
      #sys.stderr.write(d[:p2]+'| p2=%d\n' % (p2,))
      s += d[:p2]+')'+d[p2+1:]
      d = s
    return d

def FilterMatlabOrPythonSections(d, what):
    if (what == 'MATLAB'):
      w = 1
    else: w = 0
    markup = ['@MATLAB{', '@PYTHON{']
    ll = d.split(markup[w])
    d = ll[0]
    for l in ll[1:]:
      d += l[(find_closing_brace(l)+1):]
    ll = d.split(markup[1-w])
    d = ll[0]
    for l in ll[1:]:
      p = find_closing_brace(l)
      d += l[:p] + l[p+1:]
    return d

def SubstituteTypes(d):
    transtypes = { '@dmat':'mat',
                   '@mat':'mat',
                   '@ivec':'ivec',
                   '@dvec':'vec',
                   '@cvec':'vec',
                   '@dcvec':'vec',
                   '@vec':'vec',
                   '@int' :'int',
                   '@bool':'bool',
                   '@real':'real',
                   '@scalar':'scalar',
                   '@str':'string',
                   '@list':'list',
                   '@imat':'imat',
                   '@tmesh':'Mesh',
                   '@tmim':'MeshIm',
                   '@tmf':'MeshFem',
                   '@tbrick':'MdBrick',
                   '@tstate':'MdState',
                   '@tmodel':'Model',
                   '@teltm':'Eltm',
                   '@tfem':'Fem',
                   '@tgt':'GeoTrans',
                   '@tinteg':'Integ',
                   '@tgf':'GlobalFunction',
                   '@tmls':'MeshLevelSet',
                   '@tls':'LevelSet',
                   '@tsl':'Slice',
                   '@tsp':'Spmat',
                   '@tpre':'Precond',
                   }
    for (k,v) in transtypes.items():
      d = string.replace(d, k, v)
    return d


def flush_par(par, state,indent):
    if (state == 1):
      return indent+'* '+par+'\n'
    elif (state == 2):
      return indent+par+'\n'
    elif (state == 3):
      return '<P>'+par+'</P>\n'
    return ''

def WrapParagraphs(d, indent):
    doc = ''
    for l in re.split(r'(<[Pp]ar>)', d):
      if l.startswith('<Par>'):
        doc += textwrap.fill(l[5:],78)
        doc += '\n\n'
      elif l.startswith('<par>'):
        doc += textwrap.fill(l[5:],78)
        doc += '\n'
      else: doc += textwrap.fill(l,78)
    doc = doc.strip('\n')
    return doc

def PythonWrapParagraphs(d,indent,subindent,endline):
    doc = ''
    dd = re.sub("(<[Pp]ar>)[\n]*","\\1",d)
    dd = string.replace(dd,'\n',' ')
    for l in re.split(r'(<[Pp]ar>)', dd):
      if l.startswith('<Par>'):
        doc += '\n\n'
      elif l.startswith('<par>'):
        doc += '\n'
      elif len(l)>0:
        indent_ini = re.sub("([ ]*)(.*)","\\1",l)
        text = textwrap.fill(l.strip(),78,initial_indent=indent_ini+indent,
                                  subsequent_indent=subindent+indent_ini).replace('\n',endline+'\n')
        doc += text
    doc = doc.strip('\n')
    return doc
    
def PythonRewriteDoc(d,indent,subindent,endline):
    d = d.strip('\n')
    d = CellToTuples(d)
    d = RemoveSpacesInFNames(FilterMatlabOrPythonSections(d,'PYTHON'))
    d = ExceptionsRewrite(d)
    trans = {'MESH:GET':r'Mesh.\1(\3)', \
             'MESH:SET':r'Mesh.\1(\3)', \
             'MESHFEM:GET':r'MeshFem.\1(\3)', \
             'MESHFEM:SET':r'MeshFem.\1(\3)', \
             'MESHIM:GET':r'MeshIm.\1(\3)', \
             'MESHIM:SET':r'MeshIm.\1(\3)', \
             'SLICE:GET':r'Slice.\1(\3)', \
             'SLICE:SET':r'Slice.\1(\3)', \
             'MDBRICK:GET':r'MdBrick.\1(\3)', \
             'MDBRICK:SET':r'MdBrick.\1(\3)', \
             'MDSTATE:GET':r'MdState.\1(\3)', \
             'MDSTATE:SET':r'MdState.\1(\3)', \
             'MODEL:GET':r'Model.\1(\3)', \
             'MODEL:SET':r'Model.\1(\3)', \
             'CVSTRUCT:GET': r"CvStruct.\1(\3)", \
             'GEOTRANS:GET': r"GeoTrans.\1(\3)", \
             'INTEG:GET': r"Integ.\1(\3)", \
             'GLOBALFUNCTION:GET': r"GlobalFunction.\1(\3)", \
             'FEM:GET': r"Fem.\1(\3)", \
             'SPMAT:GET': r"Spmat.\1(\3)", \
             'SPMAT:SET': r"Spmat.\1(\3)", \
             'PRECOND:GET': r"Precond.\1(\3)", \
             'MESHLEVELSET:GET': r"MeshLevelSet.\1(\3)", \
             'MESHLEVELSET:SET': r"MeshLevelSet.\1(\3)", \
             'LEVELSET:GET': r"LevelSet.\1(\3)", \
             'LEVELSET:SET': r"LevelSet.\1(\3)", \
             '::COMPUTE':r'compute_\1(mf, U, \3)', \
             '::ASM':r'asm_\1(\3)', \
             '::LINSOLVE':r'linsolve_\1(\3)', \
             }
    for retry in [1,2,3]: #pour les appels imbriques
      for (k,v) in trans.items():
        d = re.sub(k+r"\( *'([^)']*)' *(,?)([^\)]*)\)",v, d)
    d = string.replace(d,'MESH:INIT','Mesh')
    d = string.replace(d,'SLICE:INIT','Slice')
    d = string.replace(d,'MDBRICK:INIT','MdBrick')
    d = string.replace(d,'MDSTATE:INIT','MdState')
    d = string.replace(d,'MODEL:INIT','Model')
    d = string.replace(d,'MESHFEM:INIT','MeshFem')
    d = string.replace(d,'MESHIM:INIT','MeshIm')
    d = string.replace(d,'GEOTRANS:INIT','GeoTrans')
    d = string.replace(d,'INTEG:INIT','Integ')
    d = string.replace(d,'GLOBALFUNCTION:INIT','GlobalFunction')
    d = string.replace(d,'FEM:INIT','Fem')
    d = string.replace(d,'ELTM:INIT','Eltm')
    d = string.replace(d,'SPMAT:INIT','Spmat')
    d = string.replace(d,'PRECOND:INIT','Precond')
    d = string.replace(d,'MESHLEVELSET:INIT','MeshLevelSet')
    d = string.replace(d,'LEVELSET:INIT','LevelSet')
    d = string.replace(d,'::UTIL','util_')

    d = SubstituteTypes(d)
    d = PythonWrapParagraphs(d,indent,subindent,endline)
    d = re.sub("([\w.,:;])[ ]{2,}","\\1 ",d)
    d = re.sub("(\w)[ ]{1,}([.,:;])","\\1\\2",d)
    return d

def MatlabRewriteDoc(d):
    d = d.strip('\n')
    d = RemoveSpacesInFNames(FilterMatlabOrPythonSections(d,'MATLAB'))
    trans = {'MESH:INIT': r"gf_mesh('\1'\2", \
             'MESH:GET': r"gf_mesh_get(M,'\1'\2", \
             'MESH:SET': r"gf_mesh_set(M,'\1'\2", \
             'MESHFEM:GET': r"gf_mesh_fem_get(MF,'\1\2'", \
             'MESHFEM:SET': r"gf_mesh_fem_set(MF,'\1\2'", \
             'MESHIM:GET': r"gf_mesh_im_get(MIM,'\1\2'", \
             'MESHIM:SET': r"gf_mesh_im_set(MIM,'\1\2'", \
             'SLICE:GET': r"gf_slice_get(SL,'\1'\2", \
             'SLICE:SET': r"gf_slice_set(SL,'\1'\2", \
             'MDBRICK:GET': r"gf_mdbrick_get(b,'\1'\2", \
             'MDBRICK:SET': r"gf_mdbrick_set(b,'\1'\2", \
             'MDSTATE:GET': r"gf_mdstate_get(mds,'\1'\2", \
             'MDSTATE:SET': r"gf_mdstate_set(mds,'\1'\2", \
             'MODEL:GET': r"gf_model_get(mds,'\1'\2", \
             'MODEL:SET': r"gf_model_set(mds,'\1'\2", \
             'CVSTRUCT:GET': r"gf_cvstruct_get(CVS,'\1'\2", \
             'GEOTRANS:GET': r"gf_geotrans_get(CVS,'\1'\2", \
             'INTEG:GET': r"gf_integ_get(IM,'\1'\2", \
             'GLOBALFUNCTION:GET': r"gf_global_function_get(GF,'\1'\2", \
             'FEM:GET': r"gf_fem_get(fe,'\1'\2", \
             'SPMAT:GET': r"gf_spmat_get(M,'\1'\2", \
             'SPMAT:SET': r"gf_spmat_set(M,'\1'\2", \
             'PRECOND:GET': r"gf_precond_get(P,'\1'\2", \
             'MESHLEVELSET:GET': r"gf_mesh_levelset_get(ls,'\1'\2", \
             'MESHLEVELSET:SET': r"gf_mesh_levelset_set(ls,'\1'\2", \
             'LEVELSET:GET': r"gf_levelset_get(ls,'\1'\2", \
             'LEVELSET:SET': r"gf_levelset_set(ls,'\1'\2", \
             '::COMPUTE' : r"gf_compute(MF, U,'\1'\2", \
             '::ASM' : r"gf_asm('\1'\2"}
    for (k,v) in trans.items():
      d = re.sub(k+r"\( *'([^)']*)' *(,?)",v, d)
    d = string.replace(d,'SLICE:INIT','gf_slice')
    d = string.replace(d,'MDBRICK:INIT','gf_mdbrick')
    d = string.replace(d,'MDSTATE:INIT','gf_mdstate')
    d = string.replace(d,'MODEL:INIT','gf_model')
    d = string.replace(d,'MESHFEM:INIT','gf_mesh_fem')
    d = string.replace(d,'MESHIM:INIT','gf_mesh_im')
    d = string.replace(d,'GEOTRANS:INIT','gf_geotrans')
    d = string.replace(d,'INTEG:INIT','gf_integ')
    d = string.replace(d,'GLOBALFUNTION:INIT','gf_global_function')
    d = string.replace(d,'FEM:INIT','gf_fem')
    d = string.replace(d,'ELTM:INIT','gf_eltm')
    d = string.replace(d,'SPMAT:INIT','gf_spmat')
    d = string.replace(d,'PRECOND:INIT','gf_precond')
    d = string.replace(d,'MESHLEVELSET:INIT','gf_mesh_levelset')
    d = string.replace(d,'LEVELSET:INIT','gf_levelset')
    d = string.replace(d,'::LINSOLVE','gf_linsolve')
    d = string.replace(d,'::UTIL','gf_util')

    d = SubstituteTypes(d)
    d = string.replace(d, '@CELL','')
    d = WrapParagraphs(d, "% ")
    return d

def SynopsisToArgs(s0):
    s = s0
    need_star_args = 0
    if (s.find('(') != -1):
      s = s.split('(',1)[1].split(')',1)[0]
    if (s.find('{') != -1):
      s = s[:s.find('{')]
      need_star_args = 1
    if (s.find('...') != -1):
      s = s[:s.find('...')]
      need_star_args = 1
    if (s.find('[',1+s.find('[')) != -1):
      s = s[:s.find('[',1+s.find('['))]
      need_star_args = 1
    if (s.find(']') != -1):
      s = s[:s.find(']')]

    ll = [re.sub('@[a-z]*','',l).strip() for l in s.split(',')]
    args = []
    in_opt_arg = 0
    for l0 in ll:
      c = 0
      for l in l0.split('['):
        in_opt_arg += c
        l = l.strip()
        if (len(l)):
          if (l[0] != "'"):
            if not in_opt_arg:
              args += [l]
            elif (l.find('=')==-1):
              args += [l+'=None']
            else:
              args += [l]
          elif (in_opt_arg):
            need_star_args = 0
        c = 1
    if (need_star_args == 1):
      args += ['*args']
    #sys.stderr.write('to_args(%s)\n %d -> %s\n' % (s0, need_star_args, str(args)))
    return args

class ExtractDoc:
    def __init__(self, s):
      (self.type, self.synopsis) = s.split('\n',1)[0].split(' ',1)
      m = re.search(r"([\w:]+) *\( *'([\w _.]*)'(.*)\)",self.synopsis)
      if (not m):
        raise ParseError, s
      self.categ = m.group(1) # 'MESH:GET' etc
      self.name = m.group(2)  # 'pts', 'optimize_structure',...
      self.args = m.group(3)  # ', int dim, ...'

      if (self.name[0]=='.'):# that is the case of name hidden in synopsis
        syn = self.synopsis
        syn = syn[:syn.find("'")]+syn[syn.find(",",syn.find("'")+1)+1:]
        self.synopsis = syn

      l = s.split('\n',1)
      if (len(l)==2):
        self.rawdoc = textwrap.dedent(l[1])
      else:
        self.rawdoc = "Undocumented."
    def __repr__(self):
      return "cat='%s' type='%s', name='%s', args='%s'" % \
             (self.categ,self.type,self.name,self.args)

def ExtractDocFromCppFile(fname):
    docs = {}
    in_doc = 0

    sys.stderr.write('reading %s:' % (fname))
    f = open(fname)
    for l in f:
      if (l.strip().startswith('/*@')):
        in_doc = 1
        docline = l.strip()[3:].strip()+'\n'
      elif (l.find('@*/') != -1):
        in_doc = 0
        docline += l[:l.find('@*/')]
        ed = ExtractDoc(docline)
        docs[ed.name] = ed
        sys.stderr.write(' '+ed.name)
      elif (in_doc):
        docline += l
    f.close()
    sys.stderr.write('\n')
    return docs

def CommaIf(cond):
    return cond and ", " or ""

def WritePythonFunction(ed):
    #sys.stderr.write('SYNOPSIS: %s\n  -> args=%s\n' % (ed.synopsis,SynopsisToArgs(ed.synopsis)))
    tmp = ExceptionsRewrite('@'+ed.type + ' ' +ed.categ + "('" + ed.name + "')")
    #sys.stderr.write('tmp = %s\n' % tmp)
    name = ExtractDoc(tmp).name
    arg_first_dic = { '::COMPUTE':'mf, U', '::ASM':'', '::LINSOLVE':'', '::UTIL':'' }
    arg_list = ", ".join(SynopsisToArgs(ed.synopsis))
    if (not ed.type == 'FUNC'):
      sys.stdout.write('    def %s(self%s%s):\n' % (string.replace(name,' ','_'), CommaIf(len(arg_list)), arg_list))
      sys.stdout.write('        ')
    else:
      arg_first = arg_first_dic[ed.categ]
      sys.stdout.write('def %s(%s%s%s):\n' % (string.replace(ed.categ,'::','').lower() + '_' + string.replace(name,' ','_'),
                                        arg_first, CommaIf(len(arg_first) and len(arg_list)), arg_list))
      sys.stdout.write('    ')

    arg_list = re.sub("=[ .\d\w\"\']*","",arg_list)
    d = ed.rawdoc.split('\n')
    while (len(d) and (len(d[0].strip()) == 0)):
      d = d[1:]
    if (len(d)>2 and (len(d[1].strip()) == 0)):
      doc = d[0]+'<Par>Synopsis: %s<Par>' % (RemoveSpacesInFNames(ed.synopsis),)
      doc += '\n'.join(d[2:])
    else:
      doc = '\n'.join(d)
    if (ed.type == 'FUNC'):
      sys.stdout.write('"""%s"""\n' % (PythonRewriteDoc(doc,"    ","    ","").strip(),))
      if (len(arg_first)):
        sys.stdout.write("    return getfem('%s',%s,'%s'%s%s)\n" % (string.replace(ed.categ.lower(),'::',''),
                                                            arg_first,name,CommaIf(len(arg_list)), arg_list))
      else:
        sys.stdout.write("    return getfem('%s','%s'%s%s)\n" % (string.replace(ed.categ.lower(),'::',''),name,CommaIf(len(arg_list)), arg_list))
    elif (ed.categ.endswith('GET')):
      sys.stdout.write('"""%s"""\n' % (PythonRewriteDoc(doc,"        ","        ","").strip(),))
      sys.stdout.write('        return self.get("%s"%s%s)\n\n' % (name, CommaIf(len(arg_list)), arg_list))
    else:
      sys.stdout.write('"""%s"""\n' % (PythonRewriteDoc(doc,"        ","        ","").strip(),))
      sys.stdout.write('        return self.set("%s"%s%s)\n\n' % (ed.name, CommaIf(len(arg_list)), arg_list))

def WritePythonSubConstructor(ed):
    if (ed.type != 'TEXT'):
      sys.stdout.write(PythonRewriteDoc('* '+ed.synopsis,"      ","        "," \\")+'\n')
      sys.stdout.write(PythonRewriteDoc(ed.rawdoc,"          ","          ","")+'\n')
    else:
      sys.stdout.write(PythonRewriteDoc(ed.rawdoc,"    ","    ",""))

def WriteMatlabSubFunctionDoc(ed):
    if (ed.type != 'TEXT'):
      d = '* '+MatlabRewriteDoc(ed.synopsis+r'<par>'+ed.rawdoc)
      sys.stdout.write('\n'.join(['  '+s for s in d.split('\n')]) + '\n\n')
    else:
      sys.stdout.write(MatlabRewriteDoc(ed.rawdoc)+'\n')

def LookupDoc(what):
    """return the ExtractDoc for what = @RDATTR MESH:GET('nbpts') etc"""
    what = what.strip()
    ed = ExtractDoc(what)
    if (not docs.has_key(ed.categ)):
      sys.stderr.write('Undocumented category : %s\n' % ed.categ)
      raise ParseError, what
    d = docs[ed.categ]
    if (not d.has_key(ed.name)):
      raise ParseError, 'CANNOT FIND KEY for for %s:%s\n' % (ed.categ,ed.name)
    if (d[ed.name].type != ed.type):
      raise ParseError, 'WRONG TYPE : for %s:%s\n  Found %s, expected %s' % (ed.categ,ed.name,ed.type,d[ed.name].type)
    return d[ed.name]

def UpdatePythonDoc():
    currentclass = None;
    f = open(os.path.join(src_dir,'python/getfem.base.py'))
    for l in f:
      if (l.strip().startswith("class ")):
        sys.stdout.write(l)
        currentclass = l.strip()[6:].split(':')[0].strip()
        sys.stderr.write("currentclass='%s'\n" % currentclass)
      elif (l.strip().startswith('#@')):
        sys.stdout.write('\n'+l)
        WritePythonFunction(LookupDoc(l.strip()[2:]))
      elif l.strip().startswith('@'):
        WritePythonSubConstructor(LookupDoc(l.strip()[1:]))
      else:
        sys.stdout.write(l)
    f.close()

def UpdateMatlabDoc(fname):
    #sys.stderr.write("$$$update: %s\n" % (fname));
    Cfname = string.replace(fname,'.m','.cc')
    all = open(os.path.join(src_dir,Cfname)).read().split('/*MLABCOM',1)[1].split('MLABCOM*/')[0].strip()
    for l in all.split('\n'):
      if (l.strip().startswith('@')):
        ed = LookupDoc(l.strip()[1:])
        WriteMatlabSubFunctionDoc(ed)
      else:
        sys.stdout.write(l+'\n')

if (len(sys.argv) < 2):
    raise SystemExit, "give the filename to update, or just 'python'"

if (len(sys.argv) == 3):
    src_dir = sys.argv[2]
else:
    src_dir = ''

fmap = {'gf_mesh.cc':'MESH:INIT',
        'gf_mesh_get.cc':'MESH:GET',
        'gf_mesh_set.cc':'MESH:SET',
        'gf_slice.cc':'SLICE:INIT',
        'gf_slice_get.cc':'SLICE:GET',
        'gf_slice_set.cc':'SLICE:SET',
        'gf_mesh_fem.cc':'MESHFEM:INIT',
        'gf_mesh_fem_get.cc':'MESHFEM:GET',
        'gf_mesh_fem_set.cc':'MESHFEM:SET',
        'gf_mesh_im.cc':'MESHIM:INIT',
        'gf_mesh_im_get.cc':'MESHIM:GET',
        'gf_mesh_im_set.cc':'MESHIM:SET',
        'gf_fem.cc':'FEM:INIT',
        'gf_fem_get.cc':'FEM:GET',
        'gf_eltm.cc':'ELTM:INIT',
        'gf_cvstruct_get.cc':'CVSTRUCT:GET',
        'gf_geotrans.cc':'GEOTRANS:INIT',
        'gf_geotrans_get.cc':'GEOTRANS:GET',
        'gf_integ.cc':'INTEG:INIT',
        'gf_integ_get.cc':'INTEG:GET',
        'gf_global_function.cc':'GLOBALFUNCTION:INIT',
        'gf_global_function_get.cc':'GLOBALFUNCTION:GET',
        'gf_mdbrick.cc':'MDBRICK:INIT',
        'gf_mdbrick_get.cc':'MDBRICK:GET',
        'gf_mdbrick_set.cc':'MDBRICK:SET',
        'gf_mdstate.cc':'MDSTATE:INIT',
        'gf_mdstate_get.cc':'MDSTATE:GET',
        'gf_mdstate_set.cc':'MDSTATE:SET',
        'gf_model.cc':'MODEL:INIT',
        'gf_model_get.cc':'MODEL:GET',
        'gf_model_set.cc':'MODEL:SET',
        'gf_spmat.cc':'SPMAT:INIT',
        'gf_spmat_get.cc':'SPMAT:GET',
        'gf_spmat_set.cc':'SPMAT:SET',
        'gf_precond.cc':'PRECOND:INIT',
        'gf_precond_get.cc':'PRECOND:GET',
        'gf_mesh_levelset.cc':'MESHLEVELSET:INIT',
        'gf_mesh_levelset_get.cc':'MESHLEVELSET:GET',
        'gf_mesh_levelset_set.cc':'MESHLEVELSET:SET',
        'gf_levelset.cc':'LEVELSET:INIT',
        'gf_levelset_get.cc':'LEVELSET:GET',
        'gf_levelset_set.cc':'LEVELSET:SET',
        'gf_asm.cc':'::ASM',
        'gf_linsolve.cc':'::LINSOLVE',
        'gf_util.cc':'::UTIL',
        'gf_compute.cc':'::COMPUTE'}

docs = {}
for (fname,cat) in fmap.items():
    docs[cat] = ExtractDocFromCppFile(os.path.join(src_dir,fname))

if (sys.argv[1] == 'python'):
    UpdatePythonDoc()
elif (sys.argv[1].endswith('.m')):
    UpdateMatlabDoc(sys.argv[1])
else:
    raise SystemExit, "don't know file "+sys.argv[1]
