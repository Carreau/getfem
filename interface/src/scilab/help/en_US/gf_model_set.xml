<?xml version="1.0" encoding="UTF-8"?>
<refentry version="5.0-subset Scilab" xml:id="gf_model_set" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:xi="http://www.w3.org/2001/XInclude"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:db="http://docbook.org/ns/docbook">
  <refnamediv>
    <refname>gf_model_set</refname>

    <refpurpose>Modify a model object.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>

    <synopsis>
gf_model_set(md,'variable', vec U[, int niter])
gf_model_set(md,'clear')
gf_model_set(md,'add fem variable', string name, mesh_fem mf[, int niter])
gf_model_set(md,'add variable' string name, int size[, int niter])
gf_model_set(md,'add fem data', string name, mesh_fem mf[, int niter])
gf_model_set(md,'add initialized fem data', string name, mesh_fem mf, vec V)
gf_model_set(md,'add data', string name, mesh_fem mf, vec V)
gf_model_set(md,'add initialized data', string name, vec V)
gf_model_set(md,'add multiplier', string name, mesh_fem mf, mesh_im mim, string primalname, int region[, int niter])
gf_model_set(md,'to variables', vec V)
ind_brick=gf_model_set(md,'add Laplacian brick', mesh_im mim, string varname[, int region])
ind_brick=gf_model_set(md,'add generic elliptic brick', mesh_im mim, string varname[, int region])
ind_brick=gf_model_set(md,'add source term brick', mesh_im mim, string varname, string dataname[, int region[, string directdataname ]])
ind_brick=gf_model_set(md,'add normal source term brick', mesh_im mim, string varname, string dataname, int region)
ind_brick=gf_model_set(md,'add Dirichlet condition with multiplier', mesh_im mim, string varname, mult_description, int region[, string dataname ])
ind_brick=gf_model_set(md,'add Dirichlet condition with penalization', mesh_im mim, string varname, scalar coeff, int region[, string dataname ])
ind_brick=gf_model_set(md,'add generalized Dirichlet condition with multiplier', mesh_im mim, string varname, mult_description, int region, string dataname, string Hname)
ind_brick=gf_model_set(md,'add generalized Dirichlet condition with penalization', mesh_im mim, string varname, scalar coeff, int region, string dataname, string Hname)
gf_model_set(md,'change penalization coeff', int ind_brick, scalar coeff)
ind_brick=gf_model_set(md,'add Helmholtz brick', mesh_im mim, string varname, string dataname[, int region])
ind_brick=gf_model_set(md,'add Fourier Robin brick', mesh_im mim, string varname[, string dataname, int region)
ind_brick=gf_model_set(md,'add constraint with penalization',  string varname, scalar coeff, mat B, vec L)
ind_brick=gf_model_set(md,'add constraint with multipliers,  string varname, string multname, mat B, vec L)
ind_brick=gf_model_set(md,'add explicit matrix', string varname1, string varname2, mat B[, int issymmetric[, int iscoercive]])
ind_brick=gf_model_set(md,'add explicit rhs', string varname, vec L)
gf_model_set(md,'set private matrix',  int indbrick, mat B)
gf_model_set(md,'set private rhs',  int indbrick, vec L)
gf_model_set(md,'disable bricks',  ivec indbricks)
gf_model_set(md,'unable bricks',  ivec indbricks)
ind_brick=gf_model_set(md,'add isotropic linearized elasticity brick', mesh_im mim, string varname, string dataname_lambda, string dataname_mu[, int region])
ind_brick=gf_model_set(md,'add linear incompressibility brick', mesh_im mim, string varname, string multname_pressure[, int region[, string dataname_coeff]])
ind_brick=gf_model_set(md,'add mass brick', mesh_im mim, string varname[, string dataname_rho[, int region]])
ind_brick=gf_model_set(md,'add basic d on dt brick', mesh_im mim, string varnameU,  string dataname_dt[, string dataname_rho[, int region]])
ind_brick=gf_model_set(md,'add basic d2 on dt2 brick', mesh_im mim, string varnameU,  string varnameV, string dataname_dt, string dataname_alpha[, string dataname_rho[, int region]])
gf_model_set(md,'add theta method dispatcher', ivec bricks_indices, string theta)
gf_model_set(md,'add midpoint dispatcher', ivec bricks_indices)
gf_model_set(md,'velocity update for order two theta method',  string varnameU,  string datanameV, string dataname_dt, string dataname_theta)
gf_model_set(md,'velocity update for Newmark scheme',  int id2dt2_brick, string varnameU,  string datanameV, string dataname_dt, string dataname_twobeta,  string dataname_gamma)
gf_model_set(md,'first iter')
gf_model_set(md,'next iter')
ind_brick=gf_model_set(md,'add basic contact brick', string varname_u, string multname_n, string dataname_r, mat BN[, string dataname_gap[, string dataname_alpha[, int symmetrized]]])
gf_model_set(md,'contact brick set BN', int indbrick, mat BN)
gf_model_set(md,'contact brick set BT', int indbrick, mat BT)
    </synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Description</title>

    <itemizedlist>
      <listitem>
        <para>gf_model_set(mds,'clear') Clear the model.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'add fem variable', string name, MeshFem mf[,
        int niter]) Add a variable to the model linked to a MeshFem.
        <literal>name</literal> is the variable name and
        <literal>niter</literal> is the optional number of copy of the
        variable for time integration schemes.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'add variable', string name, int size[, int
        niter]) Add a variable to the model of constant size.
        <literal>name</literal> is the variable name and
        <literal>niter</literal> is the optional number of copy of the
        variable for time integration schemes.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'add multiplier', string name, MeshFem mf,
        string primalname[, int niter]) Add a particular variable linked to a
        fem being a multiplier with respect to a primal variable. The dof will
        be filtered with the gmm::range_basis function applied on the terms of
        the model which link the multiplier and the primal variable. This in
        order to retain only linearly independant constraints on the primal
        variable. Optimized for boundary multipliers. niter is the number of
        version of the data stored, for time integration schemes.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'add fem data', string name, MeshFem mf[, int
        qdim, int niter]) Add a data to the model linked to a MeshFem.
        <literal>name</literal> is the data name, <literal>qdim</literal> is
        the optional dimension of the data over the MeshFem and
        <literal>niter</literal> is the optional number of copy of the data
        for time integration schemes.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'add initialized fem data', string name,
        MeshFem mf, vec V) Add a data to the model linked to a MeshFem.
        <literal>name</literal> is the data name. The data is initiakized with
        <literal>V</literal>. The data can be a scalar or vector field.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'add data', string name, int size[, int niter])
        Add a data to the model of constant size. <literal>name</literal> is
        the data name and <literal>niter</literal> is the optional number of
        copy of the data for time integration schemes.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'add initialized data', string name, V) Add a
        fixed size data to the model linked to a MeshFem.
        <literal>name</literal> is the data name, <literal>V</literal> is the
        value of the data.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'variable', string name, vec V[, int niter])
        Set the value of a variable or data.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'to variables', vec V) Set the value of the
        variables of the model with the vector <literal>V</literal>.
        Typically, the vector <literal>V</literal> results of the solve of the
        tangent linear system (usefull to solve your problem with you own
        solver).</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add Laplacian brick', MeshIm mim, string
        varname[, int region]) add a Laplacian term to the model relatively to
        the variable <literal>varname</literal>. If this is a vector valued
        variable, the Laplacian term is added componentwise.
        <literal>region</literal> is an optional mesh region on which the term
        is added. If it is not specified, it is added on the whole
        mesh.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add generic elliptic brick', MeshIm mim,
        string varname, string dataname[, int region]) add a generic elliptic
        term to the model relatively to the variable
        <literal>varname</literal>. The shape of the elliptic term depends
        both on the variable and the data. This corresponds to a term
        <inlineequation>
            <inlinemediaobject>
              <imageobject>
                <imagedata fileref="../mml/gf_model_set_eq1.mml" />
              </imageobject>
            </inlinemediaobject>
          </inlineequation> where <literal>a</literal> is the data and
        <literal>u</literal> the variable. The data can be a scalar, a matrix
        or an order four tensor. The variable can be vector valued or not. If
        the data is a scalar or a matrix and the variable is vector valued
        then the term is added componentwise. An order four tensor data is
        allowed for vector valued variable only. The data can be constant or
        describbed on a fem. Of course, when the data is a tensor describe on
        a finite element method (a tensor field) the data can be a huge
        vector. The components of the matrix/tensor have to be stored with the
        fortran order (columnwise) in the data vector (compatibility with
        blas). The symmetry of the given matrix/tensor is not verified (but
        assumed). If this is a vector valued variable, the Laplacian term is
        added componentwise. <literal>region</literal> is an optional mesh
        region on which the term is added. If it is not specified, it is added
        on the whole mesh.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add source term brick', MeshIm mim,
        string varname, string dataname[, int region]) add a source term to
        the model relatively to the variable <literal>varname</literal>. The
        source term is represented by the data <literal>dataname</literal>
        which could be constant or described on a fem.
        <literal>region</literal> is an optional mesh region on which the term
        is added. An additional optional data
        <literal>directdataname</literal> can be provided. The corresponding
        data vector will be directly added to the right hand side without
        assembly.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add normal source term brick', MeshIm
        mim, string varname, string dataname[, int region]) add a source term
        on the variable <literal>varname</literal> on a boundary
        <literal>region</literal>. The source term is represented by the data
        <literal>dataname</literal> which could be constant or described on a
        fem. A scalar product with the outward normal unit vector to the
        boundary is performed. The main aim of this brick is to represent a
        Neumann condition with a vector data without performing the scalar
        product with the normal as a pre-processing.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add Dirichlet condition with
        multipliers', MeshIm mim, string varname, mult_description, int
        region[, string dataname]) Add a Dirichlet condition on the variable
        <literal>varname</literal> and the mesh region
        <literal>region</literal>. This region should be a boundary. The
        Dirichlet condition is prescribed with a multiplier variable described
        by <literal>mult_description</literal>. If
        <literal>mult_description</literal> is a string this is assumed to be
        the variable name correpsonding to the multiplier (which should be
        first declared as a multiplier variable on the mesh region in the
        model). If it is a finite element method (mesh_fem object) then a
        multiplier variable will be added to the model and build on this
        finite element method (it will be restricted to the mesh region
        <literal>region</literal> and eventually some conflicting dofs with
        some other multiplier variables will be suppressed). If it is an
        integer, then a multiplier variable will be added to the model and
        build on a classical finite element of degree that integer.
        <literal>dataname</literal> is the optional right hand side of the
        Dirichlet condition. It could be constant or described on a fem;
        scalar or vector valued, depending on the variable on which the
        Dirichlet condition is prescribed. Return the brick index in the
        model.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add Dirichlet condition with
        penalization', MeshIm mim, string varname, scalar coeff, int region[,
        string dataname]) Add a Dirichlet condition on the variable
        <literal>varname</literal> and the mesh region
        <literal>region</literal>. This region should be a boundary. The
        Dirichlet condition is prescribed with penalization. The penalization
        coefficient is intially <literal>coeff</literal> and will be added to
        the data of the model. <literal>dataname</literal> is the optional
        right hand side of the Dirichlet condition. It could be constant or
        described on a fem; scalar or vector valued, depending on the variable
        on which the Dirichlet condition is prescribed. Return the brick index
        in the model.</para>
      </listitem>

      <listitem>
	<para>ind_brick=gf_model_set(md,'add generalized Dirichlet
	  condition with multiplier', mesh_im mim, string varname,
	  string multname | mesh_fem mf_mult | int degree, int region,
	  string dataname, string Hname) : Add a Dirichlet condition on the variable <literal>varname</literal> and the mesh
	  region <literal>region</literal>. This version is for vector
	  field. It prescribes a condition $Hu = r$
	  where <literal>H</literal> is a matrix field. The region
	  should be a boundary. The Dirichlet condition is prescribed with a multiplier variable which can be either
	  directly given by <literal>multname</literal> (should be first declared as a multiplier 
	  variable on the mesh region in the model) or added by the function and
	  buld on the given finite element method <literal>mf_mult</literal> (it will be restricted to
	  the mesh region <literal>region</literal> and eventually some conflicting dofs with some
	  other multiplier variables will be suppressed) or added by the function and
	  build on a standard finite element method of degree <literal>degree</literal>.
	  <literal>dataname</literal> is the optional right hand side of  the Dirichlet condition. It could be constant or
	  described on a fem; scalar or vector valued, depending on the variable
	  on which the Dirichlet condition is prescribed. <literal>Hname</literal> is the data
	  corresponding to the matrix field <literal>H</literal>. It has to be a constant matrix
	  or described on a scalar fem. Return the brick index in the model.</para>
      </listitem>
      
      <listitem>
	<para>ind_brick=gf_model_set(md,'add  generalized Dirichlet
	  condition with penalization', mesh_im mim, string varname,
	  scalar coeff, int region, string dataname, string Hname) : Add
	  a Dirichlet condition on the
	  variable <literal>varname</literal> and the mesh 
	  region <literal>region</literal>. This version is for vector field.
	  It prescribes a condition $Hu = r$ where <literal>H</literal>
	  is a matrix field. The region should be a boundary. The Dirichlet
	  condition is prescribed with penalization. The penalization coefficient
	  is intially <literal>coeff</literal> and will be added to the data of
	  the model. <literal>dataname</literal> is the optional
	  right hand side of  the Dirichlet condition. It could be constant or
	  described on a fem; scalar or vector valued, depending on the variable
	  on which the Dirichlet condition is prescribed. <literal>Hname</literal> is the data
	  corresponding to the matrix field <literal>H</literal>. It has to be a constant matrix
	  or described on a scalar fem. Return the brick index in the model.</para>
      </listitem>
      
      <listitem>
        <para>gf_model_set(mds,'change penalization coeff', int ind_brick,
          scalar coeff) Change the penalization coefficient of a Dirichlet
          condition with penalization brick. If the brick is not of this kind,
          this function has an undefined behavior.</para>
      </listitem>
      
      <listitem>
        <para>ind = gf_model_set(mds,'add Helmholtz brick', MeshIm mim, string
        varname, string dataname[, int region]) add a Helmholtz term to the
        model relatively to the variable <literal>varname</literal>.
        <literal>dataname</literal> should contain the wave number.
        <literal>region</literal> is an optional mesh region on which the term
        is added. If it is not specified, it is added on the whole
        mesh.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add Fourier Robin brick', MeshIm mim,
        string varname, string dataname, int region) add a Fourier-Robin term
        to the model relatively to the variable <literal>varname</literal>.
        this corresponds to a weak term of the form <inlineequation>
            <inlinemediaobject>
              <imageobject>
                <imagedata fileref="../mml/gf_model_set_eq2.mml" />
              </imageobject>
            </inlinemediaobject>
          </inlineequation>. <phrase>dataname</phrase> should contain the
        parameter <literal>q</literal> of the Fourier-Robin condition.
        <literal>region</literal> is the mesh region on which the term is
        added.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add constraint with multipliers', string
        varname, string multname, mat B, vec L) Add an additional explicit
        constraint on the variable <literal>varname</literal> thank to a
        multiplier <literal>multname</literal> peviously added to the model
        (should be a fixed size variable). The constraint is
        <emphasis>BU=L</emphasis> with <literal>B</literal> being a
        rectangular sparse matrix. It is possible to change the constraint at
        any time whith the methods gf_model_set(mds,'set private matrix') and
        gf_model_set(mds,'set private rhs')</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add constraint with penalization',
        string varname, scalar coeff, mat B, vec L) Add an additional explicit
        penalized constraint on the variable <literal>varname</literal>. The
        constraint is BU=L with <literal>B</literal> being a rectangular
        sparse matrix. Be aware that <literal>B</literal> should not contain a
        palin row, otherwise the whole tangent matrix will be plain. It is
        possible to change the constraint at any time whith the methods
        gf_model_set(mds,'set private matrix') and gf_model_set(mds,'set
        private rhs'). The method gf_model_set(mds,'change penalization
        coeff') can be used.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add explicit matrix', string varname1,
        string varname2, mat B[, int issymmetric[, int iscoercive]]) Add a
        brick reprenting an explicit matrix to be added to the tangent linear
        system relatively to the variables 'varname1' and 'varname2'. The
        given matrix should have has many rows as the dimension of 'varname1'
        and as many columns as the dimension of 'varname2'. If the two
        variables are different and if <literal>issymmetric</literal> is set
        to 1 then the transpose of the matrix is also added to the tangent
        system (default is 0). set <literal>iscoercive</literal> to 1 if the
        term does not affect the coercivity of the tangent system (default is
        0). The matrix can be changed by the command gf_model_set(mds,'set
        private matrix').</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add explicit rhs', string varname, vec
        L) Add a brick reprenting an explicit right hand side to be added to
        the right hand side of the tangent linear system relatively to the
        variable 'varname'. The given rhs should have the same size than the
        dimension of <literal>varname</literal>. The rhs can be changed by the
        command gf_model_set(mds,'set private rhs').</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'set private matrix', int indbrick, mat B) For
        some specific bricks having an internal sparse matrix (explicit
        bricks: 'constraint brick' and 'explicit matrix brick'), set this
        matrix.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'set private rhs', int indbrick, vec B) For
        some specific bricks having an internal right hand side vector
        (explicit bricks: 'constraint brick' and 'explicit rhs brick'), set
        this rhs.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add isotropic linearized elasticity
        brick', MeshIm mim, string varname, string dataname_lambda, string
        dataname_mu[, int region]) add an isotropic linearized elasticity term
        to the model relatively to the variable <literal>varname</literal>.
        <literal>dataname_lambda</literal> and <literal>dataname_mu</literal>
        should contain the Lamé coefficients. <literal>region</literal> is an
        optional mesh region on which the term is added. If it is not
        specified, it is added on the whole mesh.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add linear incompressibility brick',
        MeshIm mim, string varname, string multname_pressure[, int region[,
        string dataname_coeff]]) add an linear incompressibility condition on
        <literal>variable</literal>. <literal>multname_pressure</literal> is a
        variable which represent the pressure. Be aware that an inf-sup
        condition between the finite element method describing the rpressure
        and the primal variable has to be satisfied. <literal>region</literal>
        is an optional mesh region on which the term is added. If it is not
        specified, it is added on the whole mesh.
        <literal>dataname_coeff</literal> is an optional penalization
        coefficient for nearly incompressible elasticity for instance. In this
        case, it is the inverse of the Lamé coefficient lambda.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add mass brick', MeshIm mim, string
        varname[, string dataname_rho[, int region]]) add mass term to the
        model relatively to the variable <literal>varname</literal>. If
        specified, the data <literal>dataname_rho</literal> should contain the
        density (1 if omitted). <literal>region</literal> is an optional mesh
        region on which the term is added. If it is not specified, it is added
        on the whole mesh.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add basic d on dt brick', MeshIm mim,
        string varnameU, string dataname_dt[, string dataname_rho[, int
        region]]) Add the standard discretization of a first order time
        derivative on <literal>varnameU</literal>. The parameter rho is the
        density which could be omitted (the defaul value is 1). This brick
        should be used in addition to a time dispatcher for the other
        terms.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'add basic d2 on dt2 brick', MeshIm mim,
        string varnameU, string datanameV, string dataname_dt, string
        dataname_alpha,[, string dataname_rho[, int region]]) Add the standard
        discretization of a second order time derivative on
        <literal>varnameU</literal>. <literal>datanameV</literal> is a data
        represented on the same finite element method as U which represents
        the time derivative of U. The parameter <literal>rho</literal> is the
        density which could be omitted (the defaul value is 1). This brick
        should be used in addition to a time dispatcher for the other terms.
        The time derivative <literal>v</literal> of the variable
        <literal>u</literal> is preferably computed as a post-traitement which
        depends on each scheme. The parameter
        <literal>dataname_alpha</literal> depends on the time integration
        scheme.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'add theta method dispatcher', vec
        bricks_indices, string theta) Add a theta-method time dispatcher to a
        list of bricks. For instance, a matrix term <literal>K</literal> will
        be replaced by <inlineequation>
            <inlinemediaobject>
              <imageobject>
                <imagedata fileref="../mml/gf_model_set_eq3.mml" />
              </imageobject>
            </inlinemediaobject>
          </inlineequation>.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'add midpoint dispatcher', vec bricks_indices)
        Add a midpoint time dispatcher to a list of bricks. For instance, a
        nonlinear term K(U) will be replaced by <inlineequation>
            <inlinemediaobject>
              <imageobject>
                <imagedata fileref="../mml/gf_model_set_eq4.mml" />
              </imageobject>
            </inlinemediaobject>
          </inlineequation>.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'velocity update for order two theta method',
        string varnameU, string datanameV, string dataname_dt, string
        dataname_theta) Function which udpate the velocity
        v<superscript>n+1</superscript> after the computation of the
        displacement u<superscript>n+1</superscript> and before the next
        iteration. Specific for theta-method and when the velocity is included
        in the data of the model.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'velocity update for Newmark scheme', int
        id2dt2_brick, string varnameU, string datanameV, string dataname_dt,
        string dataname_twobeta, string dataname_alpha) Function which udpate
        the velocity v<superscript>n+1</superscript> after the computation of
        the displacement u<superscript>n+1</superscript> and before the next
        iteration. Specific for Newmark scheme and when the velocity is
        included in the data of the model. This version inverts the mass
        matrix by a conjugate gradient.</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'disable bricks', vec bricks_indices) Disable a
        brick (the brick will no longer participate to the building of the
        tangent linear system).</para>
      </listitem>

      <listitem>
        <para>gf_model_set(mds,'unable bricks', vec bricks_indices) Unable a
        disabled brick.</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'first iter') To be executed before the
        first iteration of a time integration scheme</para>
      </listitem>

      <listitem>
        <para>ind = gf_model_set(mds,'next iter') To be executed at the end of
        each iteration of a time integration scheme.</para>
      </listitem>

      <listitem>
	<para>
	  ind_brick=gf_model_set(md,'add basic contact brick', string
	  varname_u, string multname_n, string dataname_r, mat BN[,
	  string dataname_gap[, string dataname_alpha[, int
	  symmetrized]]]) : Add a contact without friction brick to the model. If U is the vector
	  of degrees of freedom on which the unilateral contraint is applied,
	  the matrix <literal>BN</literal> have to be such that this conctraint is defined by
	  $B_N U \le 0$. The constraint is prescribed thank to a multiplier
	  <literal>multname_n</literal> whose dimension should be equal to the number of lines of
	  <literal>BN</literal>. The augmentation parameter <literal>r</literal> should be chosen in a range of
	  acceptabe values (see Getfem user documentation). <literal>dataname_gap</literal> is an
	  optional parameter representing the initial gap. It can be a single value
	  or a vector of value. <literal>dataname_alpha</literal> is an optional homogenization
	  parameter for the augmentation parameter (see Getfem user documentation). 
	  The parameter <literal>symmetrized</literal> indicates
	  that the symmetry of the tangent matrix will be kept or
	  not.</para>
      </listitem>
      
      <listitem>
	<para>gf_model_set(md,'contact brick set BN', int indbrick, mat BN) :
	  Can be used to set the BN matrix of a basic contact/friction
	  brick.</para>
      </listitem>
      
      <listitem>
	<para>gf_model_set(md,'contact brick set BT', int indbrick, mat BT) :
	  Can be used to set the BT matrix of a basic contact with
	  friction brick.</para>
      </listitem>
    </itemizedlist>
  </refsection>

  <refsection>
    <title>See Also</title>

    <simplelist type="inline">
      <member><link linkend="gf_model_get">gf_model_get</link></member>

      <member><link linkend="gf_model">gf_model</link></member>
    </simplelist>
  </refsection>

  <refsection>
    <title>Authors</title>

    <para>Y. Collette</para>
  </refsection>
</refentry>
