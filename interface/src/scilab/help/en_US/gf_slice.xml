<?xml version="1.0" encoding="UTF-8"?>
<refentry version="5.0-subset Scilab" xml:id="gf_slice" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:xi="http://www.w3.org/2001/XInclude"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:db="http://docbook.org/ns/docbook">
  <refnamediv>
    <refname>gf_slice</refname>

    <refpurpose>Mesh slice creation.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>

    <synopsis>
sl = gf_slice(sliceop, mesh M, int REFINE [, CVFLST])
sl = gf_slice(sliceop, mesh_fem MF, vec U, int REFINE [, CVFLST])
sl = gf_slice(sliceop, slice SL)
sl = gf_slice('streamlines', mesh_fem MF, vec U, mat SEEDS)
sl = gf_slice('points', mesh M, mat PTS)  
    </synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Description</title>

    <para>Creation of a mesh slice. Mesh slices are very similar to a
    P1-discontinuous mesh_fem on which interpolation is very fast. The slice
    is built from a mesh object, and a description of the slicing operation,
    for example,</para>

    <programlisting role="example"><![CDATA[ 
sl = gf_slice(list('planar',+1,[0;0],[1;0]), m, 5);
 ]]></programlisting>

    <para>cuts the original mesh with the half space [y&gt;0]. Each convex of
    the original mesh m is simplexified (for example a quadrangle is splitted
    into 2 triangles), and each simplex is refined 5 times.</para>

    <para>Slicing operations can be:</para>

    <itemizedlist>
      <listitem>
        <para>cutting with a plane, a sphere or a cylinder</para>
      </listitem>

      <listitem>
        <para>intersection or union of slices</para>
      </listitem>

      <listitem>
        <para>isovalues surfaces/volumes</para>
      </listitem>

      <listitem>
        <para>"points", "streamlines" (see below)</para>
      </listitem>
    </itemizedlist>

    <para>If the first argument is a mesh_fem mf instead of a mesh, and if it
    is followed by a field <literal>U</literal> (with <emphasis>size(U,1) ==
    gf_mesh_fem_get(mf,U)</emphasis>), then the deformation
    <literal>U</literal> will be applied to the mesh before the slicing
    operation.</para>

    <para>The first argument can also be a slice.</para>

    <para>Slicing operations:</para>

    <para>Always specifiy them between braces (i.e. in a cell array). The
    first argument is the name of the operation, followed the slicing
    options.</para>

    <itemizedlist>
      <listitem>
        <para>list('none'): Does not cut the mesh.</para>
      </listitem>

      <listitem>
        <para>list('planar', orient, p, n): Planar cut. <literal>p</literal>
        and <literal>n</literal> define a half-space, <literal>p</literal>
        being a point belong to the boundary of the half-space, and n being
        its normal. If <literal>orient</literal> is equal to -1 (resp. 0, +1),
        then the slicing operation will cut the mesh with the "interior"
        (resp. "boundary", "exterior") of the half-space.
        <literal>Orient</literal> may also be set to +2 which means that the
        mesh will be sliced, but both the outer and inner parts will be
        kept.</para>
      </listitem>

      <listitem>
        <para>list('ball', orient, c, r): Cut with a ball of center
        <literal>c</literal> and radius <literal>r</literal>.</para>
      </listitem>

      <listitem>
        <para>list('cylinder', orient, p1, p2, r): Cut with a cylinder whose
        axis is the line (p1,p2) and whose radius is r.</para>
      </listitem>

      <listitem>
        <para>list('isovalues',orient, mesh_fem MF, vec U, scalar V): Cut
        using the isosurface of the field <literal>U</literal> (defined on the
        mesh_fem <literal>MF</literal>). The result is the set <emphasis>{x
        such that U(x) &lt;= V} or {x such that U(x) == V} or {x such that
        U(x) &lt;= V}</emphasis> depending on the value of
        <literal>ORIENT</literal>.</para>
      </listitem>

      <listitem>
        <para>list('boundary'[, SLICEOP]): Return the boundary of the result
        of <literal>SLICEOP</literal>, where <literal>SLICEOP</literal> is any
        slicing operation. If <literal>SLICEOP</literal> is not specified,
        then the whole mesh is considered (i.e. it is equivalent to
        list('boundary',list('none'))).</para>
      </listitem>

      <listitem>
        <para>list('explode', coef): Build an 'exploded' view of the mesh:
        each convex is shrinked (<emphasis>0 &lt;coef &lt;= 1</emphasis>). In
        the case of 3D convexes, only their faces are kept.</para>
      </listitem>

      <listitem>
        <para>list('union', SLICEOP1, SLICEOP2),</para>
      </listitem>

      <listitem>
        <para>list('intersection', SLICEOP1, SLICEOP2),</para>
      </listitem>

      <listitem>
        <para>list('comp', SLICEOP),</para>
      </listitem>

      <listitem>
        <para>list('diff', SLICEOP1, SLICEOP2): Boolean operations: returns
        the union,intersection,complementary or difference of slicing
        operations.</para>
      </listitem>

      <listitem>
        <para>list('mesh', MESH): Build a slice which is the intersection of
        the sliced mesh with another mesh. The slice is such that all of its
        simplexes are stricly contained into a convex of each mesh.</para>
      </listitem>
    </itemizedlist>


    <para>SPECIAL SLICES:</para>

    <para>There are also some special calls to gf_slice:</para>

    <itemizedlist>
      <listitem>
        <para>gf_slice('streamlines',mf, U, mat SEEDS): compute streamlines of
        the (vector) field <literal>U</literal>, with seed points given by the
        columns of <literal>SEEDS</literal>.</para>
      </listitem>

      <listitem>
        <para>gf_slice('points', m, mat PTS): return the "slice" composed of
        points given by the columns of <literal>PTS</literal> (useful for
        interpolation on a given set of sparse points, see
        <emphasis>gf_compute(mf,U,'interpolate on',sl)</emphasis>.</para>
      </listitem>

      <listitem>
        <para>gf_slice('load', filename [,m]): load the slice (and its
        linked_mesh if it is not given as an argument) from a text
        file.</para>
      </listitem>
    </itemizedlist>
  </refsection>

  <refsection>
    <title>Examples</title>

    <para>Apply the deformation given by mf,U on the mesh, then slice it with the z+ half-space, and keep only the part where U2(x) > 0. </para>

    <programlisting role="example"><![CDATA[ 
sl = gf_slice(list(intersection',list('planar',+1,[0;0;0],[0;0;1]),list('isovalues',-1,mf2,U2,0)),mf,U,5);
 ]]></programlisting>

    <para>view the convex quality of a 2D or 3D mesh m:</para>
    
    <programlisting role="example"><![CDATA[ 
gf_plot_slice(gf_slice(list('explode', 0.7), m, 2), 'convex_data', gf_mesh_get(m,'quality'));
 ]]></programlisting>

    <para>See the gf_plot_slice usage example for more slices. </para>
  </refsection>

  <refsection>
    <title>See Also</title>

    <simplelist type="inline">
      <member><link linkend="gf_slice_get">gf_slice_get</link></member>
      <member><link linkend="gf_slice_set">gf_slice_set</link></member>
      <member><link linkend="gf_plot_slice">gf_plot_slice</link></member>
    </simplelist>
  </refsection>

  <refsection>
    <title>Authors</title>

    <para>Y. Collette</para>
  </refsection>
</refentry>
