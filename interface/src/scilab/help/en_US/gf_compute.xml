<?xml version="1.0" encoding="UTF-8"?>
<refentry version="5.0-subset Scilab" xml:id="gf_compute" xml:lang="en"
          xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:xi="http://www.w3.org/2001/XInclude"
          xmlns:svg="http://www.w3.org/2000/svg"
          xmlns:mml="http://www.w3.org/1998/Math/MathML"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:db="http://docbook.org/ns/docbook">
  <refnamediv>
    <refname>gf_compute</refname>

    <refpurpose>Various computations involving the solution U of the finite
    element problem.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <title>Calling Sequence</title>

    <synopsis>
N = gf_compute(mf, U, 'L2 norm', mesh_im MIM [,ivec CVLST])
N = gf_compute(mf, U, 'H1 semi norm', mesh_im MIM [,CVLST])
N = gf_compute(mf, U, 'H1 norm', mesh_im MIM [,ivec CVLST])
N = gf_compute(mf, U, 'H2 semi norm', mesh_im MIM [,CVLST])
N = gf_compute(mf, U, 'H2 norm', mesh_im MIM [,ivec CVLST])
DU = gf_compute(mf, U, 'gradient', mesh_fem mfgrad)
D2U = gf_compute(mf, U, 'hessian', mesh_fem mfhess)
U2 = gf_compute(mf, U, 'interpolate on', mesh_fem mf2)
U2 = gf_compute(mf, U, 'interpolate on', mesh_slice sl)
[U2[,mf2,[,X[,Y[,Z]]]]] = gf_compute(mf,U,'interpolate on Q1 grid', 
      {'regular h', hxyz | 'regular N',Nxyz | X[,Y[,Z]]})
U2 = gf_compute(mf, U, 'extrapolate on', mesh_fem mf2)
E = gf_compute(mf, U, 'error estimate',  mesh_im MIM) 
gf_compute(mf, U, 'convect', mesh_fem mf_v, vec V, scalar dt, int nt[, string option]) 
  </synopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Description</title>

    <para>The first two arguments of this function are always mf and U, where U is a field defined on the mesh_fem mf.</para>

    <itemizedlist>
      <listitem>
        <para>n = gf_compute(MF, U,('L2 norm',MeshIm mim[, mat CVids]) Compute
        the L2 norm of the (real or complex) field <literal>U</literal>. If
        <literal>CVids</literal> is given, the norm will be computed only on
        the listed convexes.</para>
      </listitem>

      <listitem>
        <para>n = gf_compute(MF, U,('H1 semi norm',MeshIm mim[, mat CVids])
        Compute the L2 norm of grad(<literal>U</literal>). If
        <literal>CVids</literal> is given, the norm will be computed only on
        the listed convexes.</para>
      </listitem>

      <listitem>
        <para>n = gf_compute(MF, U,('H1 norm',MeshIm mim[, mat CVids]) Compute
        the H1 norm of <literal>U</literal>. If <literal>CVids</literal> is
        given, the norm will be computed only on the listed convexes.</para>
      </listitem>

      <listitem>
        <para>n = gf_compute(MF, U,('H2 semi norm',MeshIm mim[, mat CVids])
        Compute the L2 norm of D^2(<literal>U</literal>). If
        <literal>CVids</literal> is given, the norm will be computed only on
        the listed convexes.</para>
      </listitem>

      <listitem>
        <para>n = gf_compute(MF, U,('H2 norm',MeshIm mim[, mat CVids]) Compute
        the H2 norm of <literal>U</literal>. If <literal>CVids</literal> is
        given, the norm will be computed only on the listed convexes.</para>
      </listitem>

      <listitem>
        <para>DU = gf_compute(MF, U,('gradient',MeshFem mf_du) Compute the
        gradient of the field <literal>U</literal> defined on MeshFem
        <literal>mf_du</literal>. The gradient is interpolated on the MeshFem
        <literal>mf_du</literal>, and returned in <literal>DU</literal>. For
        example, if <literal>U</literal> is defined on a P2 MeshFem,
        <literal>DU</literal> should be evaluated on a P1-discontinuous
        MeshFem. <literal>mf</literal> and <literal>mf_du</literal> should
        share the same mesh. <literal>U</literal> may have any number of
        dimensions (i.e. this function is not restricted to the gradient of
        scalar fields, but may also be used for tensor fields). However the
        last dimension of <literal>U</literal> has to be equal to the number
        of dof of <literal>mf</literal>. For example, if <literal>U</literal>
        is a <emphasis>[3x3xNmf]</emphasis> array (where
        <literal>Nmf</literal> is the number of dof of <literal>mf</literal>),
        <literal>DU</literal> will be a <literal>[Nx3x3[xQ]xNmf_du]</literal>
        array, where <literal>N</literal> is the dimension of the mesh,
        <literal>Nmf_du</literal> is the number of dof of
        <literal>mf_du</literal>, and the optional <literal>Q</literal>
        dimension is inserted if <emphasis>Qdim_mf != Qdim_mf_du</emphasis>,
        where <literal>Qdim_mf</literal> is the Qdim of <literal>mf</literal>
        and <literal>Qdim_mf_du</literal> is the Qdim of
        <literal>mf_du</literal>.</para>
      </listitem>

      <listitem>
        <para>HU = gf_compute(MF, U,('hessian',MeshFem mf_h) Compute the
        hessian of the field <literal>U</literal> defined on MeshFem
        <literal>mf_h</literal>. See also <emphasis>gf_compute(MF,
        U,('gradient', MeshFem mf_du)</emphasis>.</para>
      </listitem>

      <listitem>
        <para>Ui = gf_compute(MF, U,('interpolate_on',list(MeshFem mfi | Slice
        sli)) Interpolate a field on another MeshFem or a Slice.</para>

        <itemizedlist>
          <listitem>
            <para>Interpolation on another MeshFem <literal>mfi</literal>:
            <literal>mfi</literal> has to be Lagrangian. If
            <literal>mf</literal> and <literal>mfi</literal> share the same
            mesh object, the interpolation will be much faster.</para>
          </listitem>

          <listitem>
            <para>Interpolation on a Slice <literal>sli</literal>: this is
            similar to interpolation on a refined P1-discontinuous mesh, but
            it is much faster.</para>
          </listitem>
        </itemizedlist>

        <para>This can also be used with
        <emphasis>gf_slice('points')</emphasis> to obtain field values at a
        given set of points. See also
        <emphasis>gf_asm('interpolation_matrix')</emphasis></para>
      </listitem>

      <listitem>
        <para>Ue = gf_compute(MF, U,('extrapolate_on',MeshFem mfe) Extrapolate
        a field on another MeshFem. If the mesh of <literal>mfe</literal> is
        stricly included in the mesh of <literal>mf</literal>, this function
        does stricly the same job as <emphasis>gf_compute(MF,
        U,('interpolate_on')</emphasis>. However, if the mesh of
        <literal>mfe</literal> is not exactly included in
        <literal>mf</literal> (imagine interpolation between a curved refined
        mesh and a coarse mesh), then values which are slightly outside
        <literal>mf</literal> will be extrapolated. See also
        <emphasis>gf_asm('extrapolation_matrix')</emphasis></para>
      </listitem>

      <listitem>
        <para>E = gf_compute(MF, U,('error_estimate',MeshIm mim) Compute an a
        posteriori error estimation. Currently there is only one which is
        available:</para>

        <para>for each convex, the jump of the normal derivative is integrated
        on its faces.</para>
      </listitem>

      <listitem>
        <para>[U2[,MF2,[,X[,Y[,Z]]]]] = gf_compute(MF,U,'interpolate on Q1
        grid',{'regular h', hxyz | 'regular N',Nxyz |X[,Y[,Z]]} Creates a
        cartesian Q1 mesh fem and interpolates U on it. The returned field U2
        is organized in a matrix such that in can be drawn via the MATLAB
        command 'pcolor'. The first dimension is the Qdim of
        <literal>MF</literal> (i.e. 1 if U is a scalar field). Example
        (<literal>mf_u</literal> is a 2D mesh_fem):</para>

        <programlisting role="example"><![CDATA[  
Uq = gf_compute(mf_u, U, 'interpolate on Q1 grid', 'regular h', [.05, .05]);
pcolor(squeeze(Uq(1,:,:)));
 ]]></programlisting>
      </listitem>

      <listitem>
        <para>E = gf_compute(MF, U, 'mesh edges deformation', N [,vec or mat
        CVLIST]) [OBSOLETE FUNCTION! will be removed in a future
        release]</para>

        <para>Evaluates the deformation of the mesh caused by the field
        <literal>U</literal> (for a 2D mesh, <literal>U</literal> must be a
        <emphasis>[2 x nb_dof]</emphasis> matrix). <literal>N</literal> is the
        refinment level (N&gt;=2) of the edges. <literal>CVLIST</literal> can
        be used to restrict the computation to the edges of the listed
        convexes (if <literal>CVLIST</literal> is a row vector), or to
        restrict the computations to certain faces of certain convexes when
        <literal>CVLIST</literal> is a two-rows matrix, the first row
        containing convex numbers and the second face numbers.</para>
      </listitem>

      <listitem>
        <para>UP = gf_compute(MF, U, 'eval on triangulated surface', int
        Nrefine,[vec CVLIST]) [OBSOLETE FUNCTION! will be removed in a future
        release]</para>

        <para>Utility function designed for 2D triangular meshes: returns a
        list of triangles coordinates with interpolated <literal>U</literal>
        values. This can be used for the accurate visualization of data
        defined on a discontinous high order element.</para>

        <para>On output, the six first rows of <literal>UP</literal> contains
        the triangle coordinates, and the others rows contain the interpolated
        values of <literal>U</literal> (one for each triangle vertex)
        <literal>CVLIST</literal> may indicate the list of convex number that
        should be consider, if not used then all the mesh convexes will be
        used. <literal>U</literal> should be a row vector.</para>
      </listitem>

      <listitem>
	<para>gf_compute(mf, U, 'convect', mesh_fem mf_v, vec V,
	  scalar dt, int nt, string option]) Compute a convection
	  of <literal>U</literal> with regards to a steady state
	  velocity field <literal>V</literal> with a Characteristic-Galerkin method. This
	  method is restricted to pure Lagrange fems for U. <literal>mf_v</literal> should represent
	  a continuous finite element method. <literal>dt</literal> is the integration time and <literal>nt</literal>
	  is the number of integration step on the caracteristics. <literal>option</literal> is an
	  option for the part of the boundary where there is a re-entrant convection.
	  <literal>option = 'extrapolation'</literal> for an extrapolation on the nearest element
	  or <literal>option = 'unchanged'</literal> for a constant value on that boundary.
	  This method is rather dissipative, but stable.</para>
      </listitem>
    </itemizedlist>
  </refsection>

  <refsection>
    <title>Examples</title>

    <para>Using the error estimate to refine the worst convexes: </para>
    <programlisting role="example"><![CDATA[  
E = gf_compute(mf, U, 'error_estimate', mim);
gf_mesh_set(m, 'refine', find(E < 1e-3));  
 ]]></programlisting>
  </refsection>

  <refsection>
    <title>See Also</title>

    <simplelist type="inline">
      <member><link linkend="gf_mesh">gf_mesh</link></member>
    </simplelist>
  </refsection>

  <refsection>
    <title>Authors</title>

    <para>Y. Collette</para>
  </refsection>
</refentry>
