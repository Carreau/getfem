
<!doctype html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module getfem_python_reference</title>
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong>getfem_python_reference</strong></big></big> (version 2970)</font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:/homes/doua/goulp/renard/source++/getfem++/gcc_eole/interface/src/python/getfem_python_reference.py">/homes/doua/goulp/renard/source++/getfem++/gcc_eole/interface/src/python/getfem_python_reference.py</a></font></td></tr></table>
    <p><tt>Getfem-interface&nbsp;classes.<br>
Provides&nbsp;access&nbsp;to&nbsp;the&nbsp;pseudo-objects&nbsp;exported&nbsp;by&nbsp;the&nbsp;python-getfem&nbsp;interface.</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#fffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="numpy.html">numpy</a><br>
</td><td width="25%" valign=top><a href="sys.html">sys</a><br>
</td><td width="25%" valign=top></td><td width="25%" valign=top></td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="getfem_python_reference.html#CvStruct">CvStruct</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#Eltm">Eltm</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#Fem">Fem</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#GeoTrans">GeoTrans</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#Integ">Integ</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#LevelSet">LevelSet</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#MdBrick">MdBrick</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#MdState">MdState</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#Mesh">Mesh</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#MeshFem">MeshFem</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#MeshIm">MeshIm</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#Model">Model</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#Poly">Poly</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#Precond">Precond</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#Slice">Slice</a>
</font></dt><dt><font face="helvetica, arial"><a href="getfem_python_reference.html#Spmat">Spmat</a>
</font></dt></dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="CvStruct">class <strong>CvStruct</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Descriptor&nbsp;for&nbsp;a&nbsp;convex&nbsp;structure.<br>
&nbsp;<br>
The&nbsp;convex&nbsp;structures&nbsp;are&nbsp;internal&nbsp;structures&nbsp;of&nbsp;getfem++.&nbsp;They&nbsp;do<br>
not&nbsp;contain&nbsp;points&nbsp;positions.&nbsp;These&nbsp;structures&nbsp;are&nbsp;recursive,&nbsp;since<br>
the&nbsp;faces&nbsp;of&nbsp;a&nbsp;convex&nbsp;structures&nbsp;are&nbsp;convex&nbsp;structures.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="CvStruct-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="CvStruct-__init__"><strong>__init__</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="CvStruct-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="CvStruct-basic_structure"><strong>basic_structure</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;simplest&nbsp;convex&nbsp;structure.<br>
&nbsp;<br>
Synopsis:&nbsp;cs&nbsp;=&nbsp;<a href="#CvStruct">CvStruct</a>.<a href="#CvStruct-basic_structure">basic_structure</a>()<br>
&nbsp;<br>
For&nbsp;example,&nbsp;the&nbsp;'basic&nbsp;structure'&nbsp;of&nbsp;the&nbsp;6-node&nbsp;triangle,&nbsp;is&nbsp;the&nbsp;canonical<br>
3-noded&nbsp;triangle.</tt></dd></dl>

<dl><dt><a name="CvStruct-dim"><strong>dim</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;convex&nbsp;structure.</tt></dd></dl>

<dl><dt><a name="CvStruct-face"><strong>face</strong></a>(self, F)</dt><dd><tt>Return&nbsp;the&nbsp;convex&nbsp;structure&nbsp;of&nbsp;the&nbsp;face&nbsp;`F`.</tt></dd></dl>

<dl><dt><a name="CvStruct-facepts"><strong>facepts</strong></a>(self, F)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;point&nbsp;indices&nbsp;for&nbsp;the&nbsp;face&nbsp;`F`.</tt></dd></dl>

<dl><dt><a name="CvStruct-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="CvStruct-nbpts"><strong>nbpts</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;number&nbsp;of&nbsp;points&nbsp;of&nbsp;the&nbsp;convex&nbsp;structure.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Eltm">class <strong>Eltm</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Descriptor&nbsp;for&nbsp;an&nbsp;elementary&nbsp;matrix&nbsp;type.<br>
&nbsp;<br>
If&nbsp;you&nbsp;have&nbsp;very&nbsp;particular&nbsp;assembling&nbsp;needs,&nbsp;or&nbsp;if&nbsp;you&nbsp;just&nbsp;want&nbsp;to&nbsp;<br>
check&nbsp;the&nbsp;content&nbsp;of&nbsp;an&nbsp;elementary&nbsp;matrix,&nbsp;this&nbsp;function&nbsp;might&nbsp;be<br>
useful.&nbsp;But&nbsp;the&nbsp;generic&nbsp;assembly&nbsp;abilities&nbsp;of&nbsp;getfem.asm_*&nbsp;should&nbsp;<br>
suit&nbsp;most&nbsp;needs.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Eltm-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="Eltm-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>Generates&nbsp;a&nbsp;descriptor&nbsp;for&nbsp;an&nbsp;elementary&nbsp;matrix&nbsp;type.<br>
&nbsp;<br>
<a href="#Eltm">Eltm</a>&nbsp;=&nbsp;<a href="#Eltm">Eltm</a>(...)<br>
&nbsp;<br>
*&nbsp;<a href="#Eltm">Eltm</a>('base',&nbsp;<a href="#Fem">Fem</a>&nbsp;FEM)<br>
&nbsp;&nbsp;return&nbsp;a&nbsp;descriptor&nbsp;for&nbsp;the&nbsp;integration&nbsp;of&nbsp;shape&nbsp;functions&nbsp;on<br>
&nbsp;&nbsp;elements,&nbsp;using&nbsp;the&nbsp;<a href="#Fem">Fem</a>&nbsp;`FEM`.<br>
*&nbsp;<a href="#Eltm">Eltm</a>('grad',&nbsp;<a href="#Fem">Fem</a>&nbsp;FEM)<br>
&nbsp;&nbsp;return&nbsp;a&nbsp;descriptor&nbsp;for&nbsp;the&nbsp;integration&nbsp;of&nbsp;the&nbsp;gradient&nbsp;of&nbsp;shape<br>
&nbsp;&nbsp;functions&nbsp;on&nbsp;elements,&nbsp;using&nbsp;the&nbsp;<a href="#Fem">Fem</a>&nbsp;`FEM`.<br>
*&nbsp;<a href="#Eltm">Eltm</a>('hessian',&nbsp;<a href="#Fem">Fem</a>&nbsp;FEM)<br>
&nbsp;&nbsp;return&nbsp;a&nbsp;descriptor&nbsp;for&nbsp;the&nbsp;integration&nbsp;of&nbsp;the&nbsp;hessian&nbsp;of&nbsp;shape<br>
&nbsp;&nbsp;functions&nbsp;on&nbsp;elements,&nbsp;using&nbsp;the&nbsp;<a href="#Fem">Fem</a>&nbsp;`FEM`.<br>
*&nbsp;<a href="#Eltm">Eltm</a>('normal')<br>
&nbsp;&nbsp;return&nbsp;a&nbsp;descriptor&nbsp;for&nbsp;the&nbsp;unit&nbsp;normal&nbsp;of&nbsp;convex&nbsp;faces.<br>
*&nbsp;<a href="#Eltm">Eltm</a>('grad_geotrans')<br>
&nbsp;&nbsp;return&nbsp;a&nbsp;descriptor&nbsp;to&nbsp;the&nbsp;gradient&nbsp;matrix&nbsp;of&nbsp;the&nbsp;geometric<br>
&nbsp;&nbsp;transformation.<br>
*&nbsp;<a href="#Eltm">Eltm</a>('grad_geotrans_inv')<br>
&nbsp;&nbsp;return&nbsp;a&nbsp;descriptor&nbsp;to&nbsp;the&nbsp;inverse&nbsp;of&nbsp;the&nbsp;gradient&nbsp;matrix&nbsp;of&nbsp;the<br>
&nbsp;&nbsp;geometric&nbsp;transformation&nbsp;(this&nbsp;is&nbsp;rarely&nbsp;used).<br>
*&nbsp;<a href="#Eltm">Eltm</a>('product',&nbsp;<a href="#Eltm">Eltm</a>&nbsp;A,&nbsp;<a href="#Eltm">Eltm</a>&nbsp;B)<br>
&nbsp;&nbsp;return&nbsp;a&nbsp;descriptor&nbsp;for&nbsp;the&nbsp;integration&nbsp;of&nbsp;the&nbsp;tensorial&nbsp;product<br>
&nbsp;&nbsp;of&nbsp;elementary&nbsp;matrices&nbsp;`A`&nbsp;and&nbsp;`B`.<br>
&nbsp;<br>
In&nbsp;order&nbsp;to&nbsp;obtain&nbsp;a&nbsp;numerical&nbsp;value&nbsp;of&nbsp;theses&nbsp;matrices,&nbsp;see&nbsp;<a href="#MeshIm">MeshIm</a>.eltm().</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Fem">class <strong>Fem</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>FEM&nbsp;(Finite&nbsp;Element&nbsp;Method)&nbsp;objects.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Fem-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="Fem-__init__"><strong>__init__</strong></a>(self, fem_name)</dt><dd><tt>Build&nbsp;a&nbsp;FEM&nbsp;object&nbsp;from&nbsp;a&nbsp;string&nbsp;description.<br>
&nbsp;<br>
<a href="#Fem">Fem</a>&nbsp;=&nbsp;<a href="#Fem">Fem</a>(string&nbsp;fem_name)<br>
&nbsp;<br>
The&nbsp;`fem_name`&nbsp;should&nbsp;contain&nbsp;a&nbsp;description&nbsp;of&nbsp;the&nbsp;finite&nbsp;element&nbsp;method.<br>
Please&nbsp;refer&nbsp;to&nbsp;the&nbsp;getfem++&nbsp;manual&nbsp;(especially&nbsp;the&nbsp;description&nbsp;of&nbsp;finite<br>
element&nbsp;and&nbsp;integration&nbsp;methods)&nbsp;for&nbsp;a&nbsp;complete&nbsp;reference.&nbsp;Here&nbsp;is&nbsp;a&nbsp;list<br>
of&nbsp;some&nbsp;of&nbsp;them:<br>
&nbsp;<br>
*&nbsp;FEM_PK(n,k)<br>
&nbsp;&nbsp;classical&nbsp;Lagrange&nbsp;element&nbsp;Pk&nbsp;on&nbsp;a&nbsp;simplex&nbsp;of&nbsp;dimension&nbsp;`n`.<br>
*&nbsp;FEM_PK_DISCONTINUOUS(N,K[,alpha])<br>
&nbsp;&nbsp;discontinuous&nbsp;Lagrange&nbsp;element&nbsp;Pk&nbsp;on&nbsp;a&nbsp;simplex&nbsp;of&nbsp;dimension&nbsp;`n`.<br>
*&nbsp;FEM_QK(n,k)<br>
&nbsp;&nbsp;classical&nbsp;Lagrange&nbsp;element&nbsp;Qk&nbsp;on&nbsp;quadrangles,&nbsp;hexahedrons&nbsp;etc.<br>
*&nbsp;FEM_QK_DISCONTINUOUS(n,k[,alpha])<br>
&nbsp;&nbsp;discontinuous&nbsp;Lagrange&nbsp;element&nbsp;Qk&nbsp;on&nbsp;quadrangles,&nbsp;hexahedrons&nbsp;etc.<br>
*&nbsp;FEM_Q2_INCOMPLETE<br>
&nbsp;&nbsp;incomplete&nbsp;2D&nbsp;Q2&nbsp;element&nbsp;with&nbsp;8&nbsp;dof&nbsp;(serendipity&nbsp;Quad&nbsp;8&nbsp;element).<br>
*&nbsp;FEM_PK_PRISM(n,k)<br>
&nbsp;&nbsp;classical&nbsp;Lagrange&nbsp;element&nbsp;Pk&nbsp;on&nbsp;a&nbsp;prism.<br>
*&nbsp;FEM_PK_PRISM_DISCONTINUOUS(n,k[,alpha])<br>
&nbsp;&nbsp;classical&nbsp;discontinuous&nbsp;Lagrange&nbsp;element&nbsp;Pk&nbsp;on&nbsp;a&nbsp;prism.<br>
*&nbsp;FEM_PK_WITH_CUBIC_BUBBLE(n,k)<br>
&nbsp;&nbsp;classical&nbsp;Lagrange&nbsp;element&nbsp;Pk&nbsp;on&nbsp;a&nbsp;simplex&nbsp;with&nbsp;an&nbsp;additional&nbsp;volumic<br>
&nbsp;&nbsp;bubble&nbsp;function.<br>
*&nbsp;FEM_P1_NONCONFORMING<br>
&nbsp;&nbsp;non-conforming&nbsp;P1&nbsp;method&nbsp;on&nbsp;a&nbsp;triangle.<br>
*&nbsp;FEM_P1_BUBBLE_FACE(n)<br>
&nbsp;&nbsp;P1&nbsp;method&nbsp;on&nbsp;a&nbsp;simplex&nbsp;with&nbsp;an&nbsp;additional&nbsp;bubble&nbsp;function&nbsp;on&nbsp;face&nbsp;0.<br>
*&nbsp;FEM_P1_BUBBLE_FACE_LAG<br>
&nbsp;&nbsp;P1&nbsp;method&nbsp;on&nbsp;a&nbsp;simplex&nbsp;with&nbsp;an&nbsp;additional&nbsp;lagrange&nbsp;dof&nbsp;on&nbsp;face&nbsp;0.<br>
*&nbsp;FEM_PK_HIERARCHICAL(n,k)<br>
&nbsp;&nbsp;PK&nbsp;element&nbsp;with&nbsp;a&nbsp;hierarchical&nbsp;basis.<br>
*&nbsp;FEM_QK_HIERARCHICAL(n,k)<br>
&nbsp;&nbsp;QK&nbsp;element&nbsp;with&nbsp;a&nbsp;hierarchical&nbsp;basis<br>
*&nbsp;FEM_PK_PRISM_HIERARCHICAL(n,k)<br>
&nbsp;&nbsp;PK&nbsp;element&nbsp;on&nbsp;a&nbsp;prism&nbsp;with&nbsp;a&nbsp;hierarchical&nbsp;basis.<br>
*&nbsp;FEM_STRUCTURED_COMPOSITE(FEM,k)<br>
&nbsp;&nbsp;Composite&nbsp;fem&nbsp;on&nbsp;a&nbsp;grid&nbsp;with&nbsp;`k`&nbsp;divisions.<br>
*&nbsp;FEM_PK_HIERARCHICAL_COMPOSITE(n,k,s)<br>
&nbsp;&nbsp;Pk&nbsp;composite&nbsp;element&nbsp;on&nbsp;a&nbsp;grid&nbsp;with&nbsp;`s`&nbsp;subdivisions&nbsp;and&nbsp;with&nbsp;a<br>
&nbsp;&nbsp;hierarchical&nbsp;basis.<br>
*&nbsp;FEM_PK_FULL_HIERARCHICAL_COMPOSITE(n,k,s)<br>
&nbsp;&nbsp;Pk&nbsp;composite&nbsp;element&nbsp;with&nbsp;`s`&nbsp;subdivisions&nbsp;and&nbsp;a&nbsp;hierarchical&nbsp;basis<br>
&nbsp;&nbsp;on&nbsp;both&nbsp;degree&nbsp;and&nbsp;subdivision.<br>
*&nbsp;FEM_PRODUCT(FEM1,FEM2)<br>
&nbsp;&nbsp;tensorial&nbsp;product&nbsp;of&nbsp;two&nbsp;polynomial&nbsp;elements.<br>
*&nbsp;FEM_HERMITE(n)<br>
&nbsp;&nbsp;Hermite&nbsp;element&nbsp;P3&nbsp;on&nbsp;a&nbsp;simplex&nbsp;of&nbsp;dimension&nbsp;`n&nbsp;=&nbsp;1,&nbsp;2,&nbsp;3`.<br>
*&nbsp;FEM_ARGYRIS<br>
&nbsp;&nbsp;Argyris&nbsp;element&nbsp;P5&nbsp;on&nbsp;the&nbsp;triangle.<br>
*&nbsp;FEM_HCT_TRIANGLE<br>
&nbsp;&nbsp;Hsieh-Clough-Tocher&nbsp;element&nbsp;on&nbsp;the&nbsp;triangle&nbsp;(composite&nbsp;P3<br>
&nbsp;&nbsp;element&nbsp;which&nbsp;is&nbsp;C^1),&nbsp;should&nbsp;be&nbsp;used&nbsp;with&nbsp;IM_HCT_COMPOSITE()<br>
&nbsp;&nbsp;integration&nbsp;method.<br>
*&nbsp;FEM_QUADC1_COMPOSITE<br>
&nbsp;&nbsp;Quadrilateral&nbsp;element,&nbsp;composite&nbsp;P3&nbsp;element&nbsp;and&nbsp;C^1&nbsp;(16&nbsp;dof).<br>
*&nbsp;FEM_REDUCED_QUADC1_COMPOSITE<br>
&nbsp;&nbsp;Quadrilateral&nbsp;element,&nbsp;composite&nbsp;P3&nbsp;element&nbsp;and&nbsp;C^1&nbsp;(12&nbsp;dof).<br>
*&nbsp;FEM_RT0(n)<br>
&nbsp;&nbsp;Raviart-Thomas&nbsp;element&nbsp;of&nbsp;order&nbsp;0&nbsp;on&nbsp;a&nbsp;simplex&nbsp;of&nbsp;dimension&nbsp;`n`.<br>
*&nbsp;FEM_NEDELEC(n)<br>
&nbsp;&nbsp;Nedelec&nbsp;edge&nbsp;element&nbsp;of&nbsp;order&nbsp;0&nbsp;on&nbsp;a&nbsp;simplex&nbsp;of&nbsp;dimension&nbsp;`n`.<br>
&nbsp;<br>
Of&nbsp;course,&nbsp;you&nbsp;have&nbsp;to&nbsp;ensure&nbsp;that&nbsp;the&nbsp;selected&nbsp;fem&nbsp;is&nbsp;compatible&nbsp;with<br>
the&nbsp;geometric&nbsp;transformation:&nbsp;a&nbsp;Pk&nbsp;fem&nbsp;has&nbsp;no&nbsp;meaning&nbsp;on&nbsp;a&nbsp;quadrangle.<br>
&nbsp;<br>
**SPECIAL&nbsp;FEM:**<br>
&nbsp;<br>
*&nbsp;<a href="#Fem">Fem</a>&nbsp;=&nbsp;<a href="#Fem">Fem</a>('interpolated_fem',&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;[ivec&nbsp;blocked_dof])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;special&nbsp;<a href="#Fem">Fem</a>&nbsp;which&nbsp;is&nbsp;interpolated&nbsp;from&nbsp;another&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
&nbsp;&nbsp;Using&nbsp;this&nbsp;special&nbsp;finite&nbsp;element,&nbsp;it&nbsp;is&nbsp;possible&nbsp;to&nbsp;interpolate&nbsp;a&nbsp;given<br>
&nbsp;&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mf`&nbsp;on&nbsp;another&nbsp;mesh,&nbsp;given&nbsp;the&nbsp;integration&nbsp;method&nbsp;`mim`&nbsp;that&nbsp;will<br>
&nbsp;&nbsp;be&nbsp;used&nbsp;on&nbsp;this&nbsp;mesh.<br>
&nbsp;<br>
&nbsp;&nbsp;Note&nbsp;that&nbsp;this&nbsp;finite&nbsp;element&nbsp;may&nbsp;be&nbsp;quite&nbsp;slow,&nbsp;and&nbsp;eats&nbsp;much&nbsp;memory.</tt></dd></dl>

<dl><dt><a name="Fem-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Fem-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Fem-base_value"><strong>base_value</strong></a>(self, p)</dt><dd><tt>Evaluate&nbsp;all&nbsp;basis&nbsp;functions&nbsp;of&nbsp;the&nbsp;FEM&nbsp;at&nbsp;point&nbsp;`p`.<br>
&nbsp;<br>
Synopsis:&nbsp;E&nbsp;=&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-base_value">base_value</a>(mat&nbsp;p)<br>
&nbsp;<br>
`p`&nbsp;is&nbsp;supposed&nbsp;to&nbsp;be&nbsp;in&nbsp;the&nbsp;reference&nbsp;convex!</tt></dd></dl>

<dl><dt><a name="Fem-char"><strong>char</strong></a>(self)</dt><dd><tt>Ouput&nbsp;a&nbsp;(unique)&nbsp;string&nbsp;representation&nbsp;of&nbsp;the&nbsp;<a href="#Fem">Fem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;string&nbsp;=&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-char">char</a>()<br>
&nbsp;<br>
This&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;perform&nbsp;comparisons&nbsp;between&nbsp;two&nbsp;different&nbsp;<a href="#Fem">Fem</a>&nbsp;objects.</tt></dd></dl>

<dl><dt><a name="Fem-dim"><strong>dim</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;dimension&nbsp;(dimension&nbsp;of&nbsp;the&nbsp;reference&nbsp;convex)&nbsp;of&nbsp;the&nbsp;<a href="#Fem">Fem</a>.</tt></dd></dl>

<dl><dt><a name="Fem-estimated_degree"><strong>estimated_degree</strong></a>(self)</dt><dd><tt>Return&nbsp;an&nbsp;estimation&nbsp;of&nbsp;the&nbsp;polynomial&nbsp;degree&nbsp;of&nbsp;the&nbsp;<a href="#Fem">Fem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;d&nbsp;=&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-estimated_degree">estimated_degree</a>()<br>
&nbsp;<br>
This&nbsp;is&nbsp;an&nbsp;estimation&nbsp;for&nbsp;fem&nbsp;which&nbsp;are&nbsp;not&nbsp;polynomials.</tt></dd></dl>

<dl><dt><a name="Fem-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Fem-grad_base_value"><strong>grad_base_value</strong></a>(self, p)</dt><dd><tt>Evaluate&nbsp;the&nbsp;gradient&nbsp;of&nbsp;all&nbsp;base&nbsp;functions&nbsp;of&nbsp;the&nbsp;<a href="#Fem">Fem</a>&nbsp;at&nbsp;point&nbsp;`p`.<br>
&nbsp;<br>
Synopsis:&nbsp;ED&nbsp;=&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-grad_base_value">grad_base_value</a>(mat&nbsp;p)<br>
&nbsp;<br>
`p`&nbsp;is&nbsp;supposed&nbsp;to&nbsp;be&nbsp;in&nbsp;the&nbsp;reference&nbsp;convex!</tt></dd></dl>

<dl><dt><a name="Fem-hess_base_value"><strong>hess_base_value</strong></a>(self, p)</dt><dd><tt>Evaluate&nbsp;the&nbsp;Hessian&nbsp;of&nbsp;all&nbsp;base&nbsp;functions&nbsp;of&nbsp;the&nbsp;<a href="#Fem">Fem</a>&nbsp;at&nbsp;point&nbsp;`p`.<br>
&nbsp;<br>
Synopsis:&nbsp;EH&nbsp;=&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-hess_base_value">hess_base_value</a>(mat&nbsp;p)<br>
&nbsp;<br>
`p`&nbsp;is&nbsp;supposed&nbsp;to&nbsp;be&nbsp;in&nbsp;the&nbsp;reference&nbsp;convex!.</tt></dd></dl>

<dl><dt><a name="Fem-is_equivalent"><strong>is_equivalent</strong></a>(self)</dt><dd><tt>Return&nbsp;0&nbsp;if&nbsp;the&nbsp;<a href="#Fem">Fem</a>&nbsp;is&nbsp;not&nbsp;equivalent.<br>
&nbsp;<br>
Synopsis:&nbsp;b&nbsp;=&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-is_equivalent">is_equivalent</a>()<br>
&nbsp;<br>
Equivalent&nbsp;<a href="#Fem">Fem</a>&nbsp;are&nbsp;evaluated&nbsp;on&nbsp;the&nbsp;reference&nbsp;convex.&nbsp;This&nbsp;is&nbsp;the&nbsp;case&nbsp;of&nbsp;most<br>
classical&nbsp;<a href="#Fem">Fem</a>'s.</tt></dd></dl>

<dl><dt><a name="Fem-is_lagrange"><strong>is_lagrange</strong></a>(self)</dt><dd><tt>Return&nbsp;0&nbsp;if&nbsp;the&nbsp;<a href="#Fem">Fem</a>&nbsp;is&nbsp;not&nbsp;of&nbsp;Lagrange&nbsp;type.</tt></dd></dl>

<dl><dt><a name="Fem-is_polynomial"><strong>is_polynomial</strong></a>(self)</dt><dd><tt>Return&nbsp;0&nbsp;if&nbsp;the&nbsp;basis&nbsp;functions&nbsp;are&nbsp;not&nbsp;polynomials.</tt></dd></dl>

<dl><dt><a name="Fem-nbdof"><strong>nbdof</strong></a>(self, cv<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;the&nbsp;number&nbsp;of&nbsp;dof&nbsp;for&nbsp;the&nbsp;<a href="#Fem">Fem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;n&nbsp;=&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-nbdof">nbdof</a>([,&nbsp;int&nbsp;cv])<br>
&nbsp;<br>
Some&nbsp;specific&nbsp;<a href="#Fem">Fem</a>&nbsp;(for&nbsp;example&nbsp;'interpolated_fem')&nbsp;may&nbsp;require&nbsp;a&nbsp;convex&nbsp;number<br>
`cv`&nbsp;to&nbsp;give&nbsp;their&nbsp;result.&nbsp;In&nbsp;most&nbsp;of&nbsp;the&nbsp;case,&nbsp;you&nbsp;can&nbsp;omit&nbsp;this&nbsp;convex<br>
number.</tt></dd></dl>

<dl><dt><a name="Fem-poly_str"><strong>poly_str</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;polynomial&nbsp;expressions&nbsp;of&nbsp;its&nbsp;basis&nbsp;functions&nbsp;in&nbsp;the&nbsp;reference<br>
convex.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-poly_str">poly_str</a>()<br>
&nbsp;<br>
The&nbsp;result&nbsp;is&nbsp;expressed&nbsp;as&nbsp;a&nbsp;tuple&nbsp;of&nbsp;strings.&nbsp;Of&nbsp;course&nbsp;this&nbsp;will&nbsp;fail&nbsp;on<br>
non-polynomial&nbsp;<a href="#Fem">Fem</a>'s.</tt></dd></dl>

<dl><dt><a name="Fem-pts"><strong>pts</strong></a>(self, cv<font color="#909090">=None</font>)</dt><dd><tt>Get&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;dof&nbsp;on&nbsp;the&nbsp;reference&nbsp;element.<br>
&nbsp;<br>
Synopsis:&nbsp;P&nbsp;=&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-pts">pts</a>([,&nbsp;int&nbsp;cv])<br>
&nbsp;<br>
Some&nbsp;specific&nbsp;<a href="#Fem">Fem</a>&nbsp;may&nbsp;require&nbsp;a&nbsp;convex&nbsp;number&nbsp;`cv`&nbsp;to&nbsp;give&nbsp;their&nbsp;result&nbsp;(for<br>
example&nbsp;'interpolated_fem').&nbsp;In&nbsp;most&nbsp;of&nbsp;the&nbsp;case,&nbsp;you&nbsp;can&nbsp;omit&nbsp;this&nbsp;convex<br>
number.</tt></dd></dl>

<dl><dt><a name="Fem-target_dim"><strong>target_dim</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;target&nbsp;space.<br>
&nbsp;<br>
Synopsis:&nbsp;td&nbsp;=&nbsp;<a href="#Fem">Fem</a>.<a href="#Fem-target_dim">target_dim</a>()<br>
&nbsp;<br>
The&nbsp;target&nbsp;space&nbsp;dimension&nbsp;is&nbsp;usually&nbsp;1,&nbsp;except&nbsp;for&nbsp;vector&nbsp;<a href="#Fem">Fem</a>&nbsp;(none&nbsp;of&nbsp;them<br>
has&nbsp;been&nbsp;implemented&nbsp;in&nbsp;getfem++&nbsp;for&nbsp;now).</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="GeoTrans">class <strong>GeoTrans</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>General&nbsp;function&nbsp;for&nbsp;building&nbsp;descriptors&nbsp;to&nbsp;geometric&nbsp;transformations.<br>
&nbsp;<br>
The&nbsp;geometric&nbsp;transformation&nbsp;must&nbsp;be&nbsp;used&nbsp;when&nbsp;you&nbsp;are&nbsp;building<br>
a&nbsp;custom&nbsp;mesh&nbsp;convex&nbsp;by&nbsp;convex&nbsp;(see&nbsp;the&nbsp;add_convex()&nbsp;function&nbsp;of&nbsp;<br>
getfem.<a href="#Mesh">Mesh</a>):&nbsp;it&nbsp;also&nbsp;defines&nbsp;the&nbsp;kind&nbsp;of&nbsp;convex&nbsp;(triangle,<br>
hexahedron,&nbsp;prism,&nbsp;etc..)<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="GeoTrans-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="GeoTrans-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>Build&nbsp;a&nbsp;<a href="#GeoTrans">GeoTrans</a>&nbsp;object&nbsp;from&nbsp;a&nbsp;string&nbsp;description.<br>
&nbsp;<br>
<a href="#GeoTrans">GeoTrans</a>&nbsp;=&nbsp;<a href="#GeoTrans">GeoTrans</a>(string&nbsp;name)<br>
&nbsp;<br>
The&nbsp;name&nbsp;argument&nbsp;contains&nbsp;the&nbsp;specification&nbsp;of&nbsp;the&nbsp;geometric<br>
transformation&nbsp;as&nbsp;a&nbsp;string,&nbsp;which&nbsp;may&nbsp;be:<br>
&nbsp;<br>
*&nbsp;GT_PK(n,k)<br>
&nbsp;&nbsp;Transformation&nbsp;on&nbsp;simplexes,&nbsp;dim&nbsp;`n`,&nbsp;degree&nbsp;`k`.<br>
*&nbsp;GT_QK(n,k)<br>
&nbsp;&nbsp;Transformation&nbsp;on&nbsp;parallelepipeds,&nbsp;dim&nbsp;`n`,&nbsp;degree&nbsp;`k`.<br>
*&nbsp;GT_PRISM(n,k)<br>
&nbsp;&nbsp;Transformation&nbsp;on&nbsp;prisms,&nbsp;dim&nbsp;`n`,&nbsp;degree&nbsp;`k`.<br>
*&nbsp;GT_PRODUCT(A,B)<br>
&nbsp;&nbsp;Tensorial&nbsp;product&nbsp;of&nbsp;two&nbsp;transformations.<br>
*&nbsp;GT_LINEAR_PRODUCT(A,B)<br>
&nbsp;&nbsp;Linear&nbsp;tensorial&nbsp;product&nbsp;of&nbsp;two&nbsp;transformations</tt></dd></dl>

<dl><dt><a name="GeoTrans-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="GeoTrans-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="GeoTrans-char"><strong>char</strong></a>(self)</dt><dd><tt>Output&nbsp;a&nbsp;(unique)&nbsp;string&nbsp;representation&nbsp;of&nbsp;the&nbsp;<a href="#GeoTrans">GeoTrans</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;s&nbsp;=&nbsp;<a href="#GeoTrans">GeoTrans</a>.<a href="#GeoTrans-char">char</a>()<br>
&nbsp;<br>
This&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;perform&nbsp;comparisons&nbsp;between&nbsp;two&nbsp;different&nbsp;<a href="#GeoTrans">GeoTrans</a><br>
objects.</tt></dd></dl>

<dl><dt><a name="GeoTrans-dim"><strong>dim</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;<a href="#GeoTrans">GeoTrans</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;d&nbsp;=&nbsp;<a href="#GeoTrans">GeoTrans</a>.<a href="#GeoTrans-dim">dim</a>()<br>
&nbsp;<br>
This&nbsp;is&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;source&nbsp;space,&nbsp;i.e.&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;reference<br>
convex.</tt></dd></dl>

<dl><dt><a name="GeoTrans-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="GeoTrans-is_linear"><strong>is_linear</strong></a>(self)</dt><dd><tt>Return&nbsp;0&nbsp;if&nbsp;the&nbsp;<a href="#GeoTrans">GeoTrans</a>&nbsp;is&nbsp;not&nbsp;linear.</tt></dd></dl>

<dl><dt><a name="GeoTrans-nbpts"><strong>nbpts</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;number&nbsp;of&nbsp;points&nbsp;of&nbsp;the&nbsp;<a href="#GeoTrans">GeoTrans</a>.</tt></dd></dl>

<dl><dt><a name="GeoTrans-normals"><strong>normals</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;normals&nbsp;for&nbsp;each&nbsp;face&nbsp;of&nbsp;the&nbsp;reference&nbsp;convex&nbsp;of&nbsp;the&nbsp;<a href="#GeoTrans">GeoTrans</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;N&nbsp;=&nbsp;<a href="#GeoTrans">GeoTrans</a>.<a href="#GeoTrans-normals">normals</a>()<br>
&nbsp;<br>
The&nbsp;normals&nbsp;are&nbsp;stored&nbsp;in&nbsp;the&nbsp;columns&nbsp;of&nbsp;the&nbsp;output&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="GeoTrans-pts"><strong>pts</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;reference&nbsp;convex&nbsp;points&nbsp;of&nbsp;the&nbsp;<a href="#GeoTrans">GeoTrans</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;P&nbsp;=&nbsp;<a href="#GeoTrans">GeoTrans</a>.<a href="#GeoTrans-pts">pts</a>()<br>
&nbsp;<br>
The&nbsp;points&nbsp;are&nbsp;stored&nbsp;in&nbsp;the&nbsp;columns&nbsp;of&nbsp;the&nbsp;output&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="GeoTrans-transform"><strong>transform</strong></a>(self, G, Pr)</dt><dd><tt>Apply&nbsp;the&nbsp;<a href="#GeoTrans">GeoTrans</a>&nbsp;to&nbsp;a&nbsp;set&nbsp;of&nbsp;points.<br>
&nbsp;<br>
Synopsis:&nbsp;Pt&nbsp;=&nbsp;<a href="#GeoTrans">GeoTrans</a>.<a href="#GeoTrans-transform">transform</a>(mat&nbsp;G,&nbsp;mat&nbsp;Pr)<br>
&nbsp;<br>
`G`&nbsp;is&nbsp;the&nbsp;set&nbsp;of&nbsp;vertices&nbsp;of&nbsp;the&nbsp;real&nbsp;convex,&nbsp;`Pr`&nbsp;is&nbsp;the&nbsp;set&nbsp;of&nbsp;points&nbsp;(in<br>
the&nbsp;reference&nbsp;convex)&nbsp;that&nbsp;are&nbsp;to&nbsp;be&nbsp;transformed.&nbsp;The&nbsp;corresponding&nbsp;set&nbsp;of<br>
points&nbsp;in&nbsp;the&nbsp;real&nbsp;convex&nbsp;is&nbsp;returned.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Integ">class <strong>Integ</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Integration&nbsp;Method&nbsp;Objects.<br>
&nbsp;<br>
General&nbsp;object&nbsp;for&nbsp;obtaining&nbsp;handles&nbsp;to&nbsp;various&nbsp;integrations<br>
methods&nbsp;on&nbsp;convexes&nbsp;(used&nbsp;when&nbsp;the&nbsp;elementary&nbsp;matrices&nbsp;are&nbsp;built).<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Integ-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="Integ-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>Return&nbsp;a&nbsp;FEM&nbsp;Integration&nbsp;Method&nbsp;from&nbsp;a&nbsp;string&nbsp;description.<br>
&nbsp;<br>
<a href="#Integ">Integ</a>&nbsp;=&nbsp;<a href="#Integ">Integ</a>(string&nbsp;method)<br>
&nbsp;<br>
Here&nbsp;is&nbsp;a&nbsp;list&nbsp;of&nbsp;some&nbsp;integration&nbsp;methods&nbsp;defined&nbsp;in&nbsp;getfem++<br>
(see&nbsp;the&nbsp;description&nbsp;of&nbsp;finite&nbsp;element&nbsp;and&nbsp;integration&nbsp;methods<br>
for&nbsp;a&nbsp;complete&nbsp;reference):<br>
&nbsp;<br>
*&nbsp;IM_EXACT_SIMPLEX(n)<br>
&nbsp;&nbsp;Exact&nbsp;integration&nbsp;on&nbsp;simplices&nbsp;(works&nbsp;only&nbsp;with&nbsp;linear&nbsp;geometric<br>
&nbsp;&nbsp;transformations&nbsp;and&nbsp;PK&nbsp;<a href="#Fem">Fem</a>'s).<br>
*&nbsp;IM_PRODUCT(A,B)<br>
&nbsp;&nbsp;Product&nbsp;of&nbsp;two&nbsp;integration&nbsp;methods.<br>
*&nbsp;IM_EXACT_PARALLELEPIPED(n)<br>
&nbsp;&nbsp;Exact&nbsp;integration&nbsp;on&nbsp;parallelepipeds.<br>
*&nbsp;IM_EXACT_PRISM(n)<br>
&nbsp;&nbsp;Exact&nbsp;integration&nbsp;on&nbsp;prisms.<br>
*&nbsp;IM_GAUSS1D(k)<br>
&nbsp;&nbsp;Gauss&nbsp;method&nbsp;on&nbsp;the&nbsp;segment,&nbsp;order&nbsp;`k=1,3,...99`.<br>
*&nbsp;IM_NC(n,k)<br>
&nbsp;&nbsp;Newton-Cotes&nbsp;approximative&nbsp;integration&nbsp;on&nbsp;simplexes,&nbsp;order&nbsp;`k`.<br>
*&nbsp;IM_NC_PARALLELEPIPED(n,k)<br>
&nbsp;&nbsp;Product&nbsp;of&nbsp;Newton-Cotes&nbsp;integration&nbsp;on&nbsp;parallelepipeds.<br>
*&nbsp;IM_NC_PRISM(n,k)<br>
&nbsp;&nbsp;Product&nbsp;of&nbsp;Newton-Cotes&nbsp;integration&nbsp;on&nbsp;prisms.<br>
*&nbsp;IM_GAUSS_PARALLELEPIPED(n,k)<br>
&nbsp;&nbsp;Product&nbsp;of&nbsp;Gauss1D&nbsp;integration&nbsp;on&nbsp;parallelepipeds.<br>
*&nbsp;IM_TRIANGLE(k)<br>
&nbsp;&nbsp;Gauss&nbsp;methods&nbsp;on&nbsp;triangles&nbsp;`k=1,3,5,6,7,8,9,10,13,17,19`.<br>
*&nbsp;IM_QUAD(k)<br>
&nbsp;&nbsp;Gauss&nbsp;methods&nbsp;on&nbsp;quadrilaterons&nbsp;`k=2,&nbsp;3,&nbsp;5,&nbsp;..&nbsp;17`.&nbsp;Note&nbsp;that<br>
&nbsp;&nbsp;IM_GAUSS_PARALLELEPIPED&nbsp;should&nbsp;be&nbsp;prefered&nbsp;for&nbsp;QK&nbsp;<a href="#Fem">Fem</a>'s.<br>
*&nbsp;IM_TETRAHEDRON(k)<br>
&nbsp;&nbsp;Gauss&nbsp;methods&nbsp;on&nbsp;tetrahedrons&nbsp;`k=1,&nbsp;2,&nbsp;3,&nbsp;5,&nbsp;6&nbsp;or&nbsp;8`.<br>
*&nbsp;IM_SIMPLEX4D(3)<br>
&nbsp;&nbsp;Gauss&nbsp;method&nbsp;on&nbsp;a&nbsp;4-dimensional&nbsp;simplex.<br>
*&nbsp;IM_STRUCTURED_COMPOSITE(im,k)<br>
&nbsp;&nbsp;Composite&nbsp;method&nbsp;on&nbsp;a&nbsp;grid&nbsp;with&nbsp;`k`&nbsp;divisions.<br>
*&nbsp;IM_HCT_COMPOSITE(im)<br>
&nbsp;&nbsp;Composite&nbsp;integration&nbsp;suited&nbsp;to&nbsp;the&nbsp;HCT&nbsp;composite&nbsp;finite&nbsp;element.<br>
&nbsp;<br>
Example:<br>
-&nbsp;<a href="#Integ">Integ</a>('IM_PRODUCT(IM_GAUSS1D(5),IM_GAUSS1D(5))')<br>
is&nbsp;the&nbsp;same&nbsp;as:<br>
-&nbsp;<a href="#Integ">Integ</a>('IM_GAUSS_PARALLELEPIPED(2,5)')<br>
&nbsp;<br>
Note&nbsp;that&nbsp;'exact&nbsp;integration'&nbsp;should&nbsp;be&nbsp;avoided&nbsp;in&nbsp;general,&nbsp;since&nbsp;they<br>
only&nbsp;apply&nbsp;to&nbsp;linear&nbsp;geometric&nbsp;transformations,&nbsp;are&nbsp;quite&nbsp;slow,&nbsp;and<br>
subject&nbsp;to&nbsp;numerical&nbsp;stability&nbsp;problems&nbsp;for&nbsp;high&nbsp;degree&nbsp;<a href="#Fem">Fem</a>'s.</tt></dd></dl>

<dl><dt><a name="Integ-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Integ-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Integ-char"><strong>char</strong></a>(self)</dt><dd><tt>Ouput&nbsp;a&nbsp;(unique)&nbsp;string&nbsp;representation&nbsp;of&nbsp;the&nbsp;integration&nbsp;method.<br>
&nbsp;<br>
Synopsis:&nbsp;s&nbsp;=&nbsp;<a href="#Integ">Integ</a>.<a href="#Integ-char">char</a>()<br>
&nbsp;<br>
This&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;comparisons&nbsp;between&nbsp;two&nbsp;different&nbsp;<a href="#Integ">Integ</a>&nbsp;objects.</tt></dd></dl>

<dl><dt><a name="Integ-coeffs"><strong>coeffs</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;coefficients&nbsp;associated&nbsp;to&nbsp;each&nbsp;integration&nbsp;point.<br>
&nbsp;<br>
Synopsis:&nbsp;Cp&nbsp;=&nbsp;<a href="#Integ">Integ</a>.<a href="#Integ-coeffs">coeffs</a>()<br>
&nbsp;<br>
Only&nbsp;for&nbsp;approximate&nbsp;methods,&nbsp;this&nbsp;has&nbsp;no&nbsp;meaning&nbsp;for&nbsp;exact&nbsp;integration<br>
methods!</tt></dd></dl>

<dl><dt><a name="Integ-dim"><strong>dim</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;reference&nbsp;convex&nbsp;of&nbsp;the&nbsp;method.</tt></dd></dl>

<dl><dt><a name="Integ-face_coeffs"><strong>face_coeffs</strong></a>(self, F)</dt><dd><tt>Returns&nbsp;the&nbsp;coefficients&nbsp;associated&nbsp;to&nbsp;each&nbsp;integration&nbsp;of&nbsp;a&nbsp;face.<br>
&nbsp;<br>
Synopsis:&nbsp;Cf&nbsp;=&nbsp;<a href="#Integ">Integ</a>.<a href="#Integ-face_coeffs">face_coeffs</a>(F)<br>
&nbsp;<br>
Only&nbsp;for&nbsp;approximate&nbsp;methods,&nbsp;this&nbsp;has&nbsp;no&nbsp;meaning&nbsp;for&nbsp;exact&nbsp;integration<br>
methods!</tt></dd></dl>

<dl><dt><a name="Integ-face_pts"><strong>face_pts</strong></a>(self, F)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;integration&nbsp;points&nbsp;for&nbsp;a&nbsp;face.<br>
&nbsp;<br>
Synopsis:&nbsp;Pf&nbsp;=&nbsp;<a href="#Integ">Integ</a>.<a href="#Integ-face_pts">face_pts</a>(F)<br>
&nbsp;<br>
Only&nbsp;for&nbsp;approximate&nbsp;methods,&nbsp;this&nbsp;has&nbsp;no&nbsp;meaning&nbsp;for&nbsp;exact&nbsp;integration<br>
methods!</tt></dd></dl>

<dl><dt><a name="Integ-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Integ-is_exact"><strong>is_exact</strong></a>(self)</dt><dd><tt>Return&nbsp;0&nbsp;if&nbsp;the&nbsp;integration&nbsp;is&nbsp;an&nbsp;approximate&nbsp;one.</tt></dd></dl>

<dl><dt><a name="Integ-nbpts"><strong>nbpts</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;integration&nbsp;points.<br>
&nbsp;<br>
Synopsis:&nbsp;n&nbsp;=&nbsp;<a href="#Integ">Integ</a>.<a href="#Integ-nbpts">nbpts</a>()<br>
&nbsp;<br>
Count&nbsp;the&nbsp;points&nbsp;for&nbsp;the&nbsp;volume&nbsp;integration,&nbsp;and&nbsp;points&nbsp;for&nbsp;surface<br>
integration&nbsp;on&nbsp;each&nbsp;face&nbsp;of&nbsp;the&nbsp;reference&nbsp;convex.<br>
&nbsp;<br>
Only&nbsp;for&nbsp;approximate&nbsp;methods,&nbsp;this&nbsp;has&nbsp;no&nbsp;meaning&nbsp;for&nbsp;exact&nbsp;integration<br>
methods!</tt></dd></dl>

<dl><dt><a name="Integ-pts"><strong>pts</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;integration&nbsp;points<br>
&nbsp;<br>
Synopsis:&nbsp;Pp&nbsp;=&nbsp;<a href="#Integ">Integ</a>.<a href="#Integ-pts">pts</a>()<br>
&nbsp;<br>
Only&nbsp;for&nbsp;approximate&nbsp;methods,&nbsp;this&nbsp;has&nbsp;no&nbsp;meaning&nbsp;for&nbsp;exact&nbsp;integration<br>
methods!</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LevelSet">class <strong>LevelSet</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Getfem&nbsp;Level-Set&nbsp;Object.<br>
&nbsp;<br>
getfem++&nbsp;deals&nbsp;with&nbsp;level-set&nbsp;definied&nbsp;by&nbsp;piecewise&nbsp;polynomial<br>
function&nbsp;on&nbsp;a&nbsp;mesh.&nbsp;It&nbsp;will&nbsp;be&nbsp;defined&nbsp;as&nbsp;the&nbsp;zero&nbsp;of&nbsp;this&nbsp;function.<br>
The&nbsp;level-set&nbsp;is&nbsp;represented&nbsp;by&nbsp;a&nbsp;function&nbsp;defined&nbsp;on&nbsp;a&nbsp;lagrange&nbsp;fem<br>
of&nbsp;a&nbsp;certain&nbsp;degree&nbsp;on&nbsp;a&nbsp;mesh.<br>
&nbsp;<br>
**IMPORTANT:**<br>
&nbsp;<br>
All&nbsp;tools&nbsp;listed&nbsp;below&nbsp;needs&nbsp;the&nbsp;package&nbsp;qhull&nbsp;installed&nbsp;on&nbsp;your<br>
system.&nbsp;This&nbsp;package&nbsp;is&nbsp;widely&nbsp;available.&nbsp;It&nbsp;computes&nbsp;convex&nbsp;hull<br>
and&nbsp;delaunay&nbsp;triangulations&nbsp;in&nbsp;arbitrary&nbsp;dimension.&nbsp;Everything<br>
here&nbsp;is&nbsp;considered&nbsp;*work&nbsp;in&nbsp;progress*,&nbsp;it&nbsp;is&nbsp;still&nbsp;subject&nbsp;to<br>
major&nbsp;changes&nbsp;if&nbsp;needed.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="LevelSet-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="LevelSet-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;<a href="#LevelSet">LevelSet</a>&nbsp;objects.<br>
&nbsp;<br>
<a href="#LevelSet">LevelSet</a>&nbsp;=&nbsp;<a href="#LevelSet">LevelSet</a>(...)<br>
&nbsp;<br>
The&nbsp;level-set&nbsp;object&nbsp;is&nbsp;represented&nbsp;by&nbsp;a&nbsp;primary&nbsp;level-set&nbsp;and&nbsp;optionally<br>
a&nbsp;secondary&nbsp;level-set&nbsp;used&nbsp;to&nbsp;represent&nbsp;fractures&nbsp;(if&nbsp;p(x)&nbsp;is&nbsp;the&nbsp;primary<br>
level-set&nbsp;function&nbsp;and&nbsp;s(x)&nbsp;is&nbsp;the&nbsp;secondary&nbsp;level-set,&nbsp;the&nbsp;crack&nbsp;is&nbsp;defined<br>
by&nbsp;p(x)=0&nbsp;and&nbsp;s(x)&lt;=0:&nbsp;the&nbsp;role&nbsp;of&nbsp;the&nbsp;secondary&nbsp;is&nbsp;stop&nbsp;the&nbsp;crack).<br>
&nbsp;<br>
*&nbsp;<a href="#LevelSet">LevelSet</a>(<a href="#Mesh">Mesh</a>&nbsp;m,&nbsp;int&nbsp;d)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;<a href="#LevelSet">LevelSet</a>&nbsp;object&nbsp;on&nbsp;a&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m&nbsp;represented&nbsp;by&nbsp;a&nbsp;primary&nbsp;function<br>
&nbsp;&nbsp;defined&nbsp;on&nbsp;a&nbsp;lagrange&nbsp;<a href="#Fem">Fem</a>&nbsp;of&nbsp;degree&nbsp;d.<br>
*&nbsp;<a href="#LevelSet">LevelSet</a>(<a href="#Mesh">Mesh</a>&nbsp;m,&nbsp;int&nbsp;d,&nbsp;string&nbsp;poly1)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;<a href="#LevelSet">LevelSet</a>&nbsp;object&nbsp;on&nbsp;a&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m&nbsp;represented&nbsp;by&nbsp;a&nbsp;primary&nbsp;function<br>
&nbsp;&nbsp;defined&nbsp;by&nbsp;the&nbsp;polynomial&nbsp;expression&nbsp;poly1&nbsp;on&nbsp;a&nbsp;lagrange&nbsp;<a href="#Fem">Fem</a>&nbsp;of<br>
&nbsp;&nbsp;degree&nbsp;d.<br>
*&nbsp;<a href="#LevelSet">LevelSet</a>(<a href="#Mesh">Mesh</a>&nbsp;m,&nbsp;int&nbsp;d,&nbsp;'with_secondary'&nbsp;[,&nbsp;string&nbsp;poly2])<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;<a href="#LevelSet">LevelSet</a>&nbsp;object&nbsp;on&nbsp;a&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m&nbsp;represented&nbsp;by&nbsp;a&nbsp;primary&nbsp;function<br>
&nbsp;&nbsp;defined&nbsp;by&nbsp;the&nbsp;polynomial&nbsp;expression&nbsp;poly1&nbsp;and&nbsp;a&nbsp;secondary&nbsp;function,<br>
&nbsp;&nbsp;both&nbsp;on&nbsp;a&nbsp;lagrange&nbsp;<a href="#Fem">Fem</a>&nbsp;of&nbsp;degree&nbsp;d.<br>
*&nbsp;<a href="#LevelSet">LevelSet</a>(<a href="#Mesh">Mesh</a>&nbsp;m,&nbsp;int&nbsp;d,&nbsp;string&nbsp;poly1,&nbsp;string&nbsp;poly2)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;<a href="#LevelSet">LevelSet</a>&nbsp;object&nbsp;on&nbsp;a&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m&nbsp;represented&nbsp;by&nbsp;a&nbsp;primary&nbsp;function<br>
&nbsp;&nbsp;defined&nbsp;by&nbsp;the&nbsp;polynomial&nbsp;expression&nbsp;poly1&nbsp;and&nbsp;a&nbsp;secondary&nbsp;function<br>
&nbsp;&nbsp;defined&nbsp;by&nbsp;the&nbsp;polynomial&nbsp;expression&nbsp;poly2,&nbsp;both&nbsp;on&nbsp;a&nbsp;lagrange&nbsp;<a href="#Fem">Fem</a><br>
&nbsp;&nbsp;of&nbsp;degree&nbsp;d.</tt></dd></dl>

<dl><dt><a name="LevelSet-degree"><strong>degree</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;degree&nbsp;of&nbsp;lagrange&nbsp;representation.</tt></dd></dl>

<dl><dt><a name="LevelSet-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="LevelSet-memsize"><strong>memsize</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;(in&nbsp;bytes)&nbsp;used&nbsp;by&nbsp;the&nbsp;level-set.</tt></dd></dl>

<dl><dt><a name="LevelSet-mf"><strong>mf</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;reference&nbsp;on&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;object.</tt></dd></dl>

<dl><dt><a name="LevelSet-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="LevelSet-set_values"><strong>set_values</strong></a>(self, *args)</dt><dd><tt>Set&nbsp;values&nbsp;of&nbsp;the&nbsp;vector&nbsp;of&nbsp;dof&nbsp;for&nbsp;the&nbsp;level-set&nbsp;functions.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#LevelSet">LevelSet</a>.<a href="#LevelSet-set_values">set_values</a>({mat&nbsp;v1|string&nbsp;poly1}[,&nbsp;{mat&nbsp;v2|string&nbsp;poly2}])<br>
&nbsp;<br>
Set&nbsp;the&nbsp;primary&nbsp;function&nbsp;with&nbsp;the&nbsp;vector&nbsp;of&nbsp;dof&nbsp;`v1`&nbsp;(or&nbsp;the&nbsp;polynomial<br>
expression&nbsp;`poly1`)&nbsp;and&nbsp;the&nbsp;secondary&nbsp;function&nbsp;(if&nbsp;any)&nbsp;with&nbsp;the&nbsp;vector&nbsp;of<br>
dof&nbsp;`v2`&nbsp;(or&nbsp;the&nbsp;polynomial&nbsp;expression&nbsp;`poly2`)</tt></dd></dl>

<dl><dt><a name="LevelSet-simplify"><strong>simplify</strong></a>(self, eps<font color="#909090">=0.01</font>)</dt><dd><tt>Simplify&nbsp;dof&nbsp;of&nbsp;level-set&nbsp;optionally&nbsp;with&nbsp;the&nbsp;parameter&nbsp;`eps`.</tt></dd></dl>

<dl><dt><a name="LevelSet-values"><strong>values</strong></a>(self, nls)</dt><dd><tt>Return&nbsp;the&nbsp;vector&nbsp;of&nbsp;dof&nbsp;for&nbsp;`nls`&nbsp;funtion.<br>
&nbsp;<br>
Synopsis:&nbsp;V&nbsp;=&nbsp;<a href="#LevelSet">LevelSet</a>.<a href="#LevelSet-values">values</a>(int&nbsp;nls)<br>
&nbsp;<br>
If&nbsp;`nls`&nbsp;is&nbsp;0,&nbsp;the&nbsp;method&nbsp;return&nbsp;the&nbsp;vector&nbsp;of&nbsp;dof&nbsp;for&nbsp;the&nbsp;primary&nbsp;level-set<br>
funtion.&nbsp;If&nbsp;`nls`&nbsp;is&nbsp;1,&nbsp;the&nbsp;method&nbsp;return&nbsp;the&nbsp;vector&nbsp;of&nbsp;dof&nbsp;for&nbsp;the&nbsp;secondary<br>
level-set&nbsp;function&nbsp;(if&nbsp;any).</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="MdBrick">class <strong>MdBrick</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Getfem&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;Object.<br>
&nbsp;<br>
A&nbsp;model&nbsp;brick&nbsp;is&nbsp;basically&nbsp;an&nbsp;object&nbsp;which&nbsp;modifies&nbsp;a&nbsp;global&nbsp;tangent<br>
matrix&nbsp;and&nbsp;its&nbsp;associated&nbsp;right&nbsp;hand&nbsp;side.&nbsp;Typical&nbsp;modifications&nbsp;are<br>
insertion&nbsp;of&nbsp;the&nbsp;stiffness&nbsp;matrix&nbsp;for&nbsp;the&nbsp;problem&nbsp;considered&nbsp;(linear<br>
elasticity,&nbsp;laplacian,&nbsp;...),&nbsp;handling&nbsp;of&nbsp;a&nbsp;set&nbsp;of&nbsp;contraints,&nbsp;Dirichlet<br>
condition,&nbsp;addition&nbsp;of&nbsp;a&nbsp;source&nbsp;term&nbsp;to&nbsp;the&nbsp;right&nbsp;hand&nbsp;side,&nbsp;etc.&nbsp;The<br>
global&nbsp;tangent&nbsp;matrix&nbsp;and&nbsp;its&nbsp;right&nbsp;hand&nbsp;side&nbsp;are&nbsp;stored&nbsp;in&nbsp;a&nbsp;<a href="#MdState">MdState</a><br>
object.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="MdBrick-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="MdBrick-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;objects.<br>
&nbsp;<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('constraint',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;string&nbsp;CTYPE[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;generic&nbsp;constraint&nbsp;brick.&nbsp;It&nbsp;may&nbsp;be&nbsp;useful&nbsp;in&nbsp;some&nbsp;situations,<br>
&nbsp;&nbsp;such&nbsp;as&nbsp;the&nbsp;Stokes&nbsp;problem&nbsp;where&nbsp;the&nbsp;pressure&nbsp;is&nbsp;defined&nbsp;modulo&nbsp;a&nbsp;constant.<br>
&nbsp;&nbsp;In&nbsp;such&nbsp;a&nbsp;situation,&nbsp;this&nbsp;brick&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;add&nbsp;an&nbsp;additional&nbsp;constraint<br>
&nbsp;&nbsp;on&nbsp;the&nbsp;pressure&nbsp;value.<br>
&nbsp;&nbsp;`CTYPE`&nbsp;has&nbsp;to&nbsp;be&nbsp;chosen&nbsp;among&nbsp;'augmented',&nbsp;'penalized',&nbsp;and&nbsp;'eliminated'.<br>
&nbsp;&nbsp;The&nbsp;constraint&nbsp;can&nbsp;be&nbsp;specified&nbsp;with&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-set_constraints">set_constraints</a>().&nbsp;Note&nbsp;that<br>
&nbsp;&nbsp;Dirichlet&nbsp;bricks&nbsp;(except&nbsp;the&nbsp;'generalized&nbsp;Dirichlet'&nbsp;one)&nbsp;are&nbsp;also<br>
&nbsp;&nbsp;specializations&nbsp;of&nbsp;the&nbsp;'constraint'&nbsp;brick.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('dirichlet',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;int&nbsp;bnum,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_m,&nbsp;string&nbsp;CTYPE[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;Dirichlet&nbsp;condition&nbsp;brick&nbsp;which&nbsp;impose&nbsp;the&nbsp;value&nbsp;of&nbsp;a&nbsp;field&nbsp;along&nbsp;a<br>
&nbsp;&nbsp;mesh&nbsp;boundary.&nbsp;The&nbsp;`bnum`&nbsp;parameter&nbsp;selects&nbsp;on&nbsp;which&nbsp;mesh&nbsp;region&nbsp;the<br>
&nbsp;&nbsp;Dirichlet&nbsp;condition&nbsp;is&nbsp;imposed.&nbsp;`CTYPE`&nbsp;has&nbsp;to&nbsp;be&nbsp;chosen&nbsp;among&nbsp;'augmented',<br>
&nbsp;&nbsp;'penalized',&nbsp;and&nbsp;'eliminated'.&nbsp;The&nbsp;`mf_m`&nbsp;may&nbsp;generally&nbsp;be&nbsp;taken&nbsp;as&nbsp;the<br>
&nbsp;&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;of&nbsp;the&nbsp;unknown,&nbsp;but&nbsp;for&nbsp;'augmented'&nbsp;Dirichlet&nbsp;conditions,&nbsp;you&nbsp;may<br>
&nbsp;&nbsp;have&nbsp;to&nbsp;respect&nbsp;the&nbsp;Inf-Sup&nbsp;condition&nbsp;and&nbsp;choose&nbsp;an&nbsp;adequate&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('dirichlet_on_normal_component',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;int&nbsp;bnum,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_m,&nbsp;string&nbsp;CTYPE[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;Dirichlet&nbsp;condition&nbsp;brick&nbsp;which&nbsp;imposes&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;normal<br>
&nbsp;&nbsp;component&nbsp;of&nbsp;a&nbsp;vector&nbsp;field.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('dirichlet_on_normal_derivative',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;int&nbsp;bnum,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_m,&nbsp;string&nbsp;CTYPE[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;Dirichlet&nbsp;condition&nbsp;brick&nbsp;which&nbsp;imposes&nbsp;the&nbsp;value&nbsp;of&nbsp;the&nbsp;normal<br>
&nbsp;&nbsp;derivative&nbsp;of&nbsp;the&nbsp;unknown.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('generalized_dirichlet',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;int&nbsp;bnum[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;This&nbsp;is&nbsp;the&nbsp;"old"&nbsp;Dirichlet&nbsp;brick&nbsp;of&nbsp;getfem.&nbsp;This&nbsp;brick&nbsp;can&nbsp;be&nbsp;used&nbsp;to<br>
&nbsp;&nbsp;impose&nbsp;general&nbsp;Dirichlet&nbsp;conditions&nbsp;`h(x)u(x)&nbsp;=&nbsp;r(x)`,&nbsp;however&nbsp;it&nbsp;may&nbsp;have<br>
&nbsp;&nbsp;some&nbsp;issues&nbsp;with&nbsp;elaborated&nbsp;<a href="#Fem">Fem</a>'s&nbsp;(such&nbsp;as&nbsp;Argyris,&nbsp;etc).&nbsp;It&nbsp;should&nbsp;be<br>
&nbsp;&nbsp;avoided&nbsp;when&nbsp;possible.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('source_term',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb[,&nbsp;int&nbsp;bnum=-1[,&nbsp;int&nbsp;nfem]])<br>
&nbsp;&nbsp;Add&nbsp;a&nbsp;boundary&nbsp;or&nbsp;volumic&nbsp;source&nbsp;term&nbsp;(&nbsp;\int&nbsp;B.v&nbsp;).&nbsp;If&nbsp;`bnum`&nbsp;is&nbsp;omitted<br>
&nbsp;&nbsp;(or&nbsp;set&nbsp;to&nbsp;-1)&nbsp;,&nbsp;the&nbsp;brick&nbsp;adds&nbsp;a&nbsp;volumic&nbsp;source&nbsp;term&nbsp;on&nbsp;the&nbsp;whole&nbsp;mesh.<br>
&nbsp;&nbsp;For&nbsp;`bnum`&nbsp;&gt;=&nbsp;0,&nbsp;the&nbsp;source&nbsp;term&nbsp;is&nbsp;imposed&nbsp;on&nbsp;the&nbsp;mesh&nbsp;region&nbsp;`bnum`.&nbsp;Use<br>
&nbsp;&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-set_param">set_param</a>('source&nbsp;term',mf,B)&nbsp;to&nbsp;set&nbsp;the&nbsp;source&nbsp;term&nbsp;field.&nbsp;The<br>
&nbsp;&nbsp;source&nbsp;term&nbsp;is&nbsp;expected&nbsp;as&nbsp;a&nbsp;vector&nbsp;field&nbsp;of&nbsp;size&nbsp;Q&nbsp;(with&nbsp;Q&nbsp;=&nbsp;qdim).<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('normal_source_term',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;int&nbsp;bnum[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Add&nbsp;a&nbsp;boundary&nbsp;source&nbsp;term&nbsp;(&nbsp;\int&nbsp;(Bn).v&nbsp;).&nbsp;The&nbsp;source&nbsp;term&nbsp;is&nbsp;imposed&nbsp;on<br>
&nbsp;&nbsp;the&nbsp;mesh&nbsp;region&nbsp;`bnum`&nbsp;(which&nbsp;of&nbsp;course&nbsp;is&nbsp;not&nbsp;allowed&nbsp;to&nbsp;be&nbsp;a&nbsp;volumic<br>
&nbsp;&nbsp;region,&nbsp;only&nbsp;boundary&nbsp;regions&nbsp;are&nbsp;allowed).&nbsp;Use&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-set_param">set_param</a>('source<br>
&nbsp;&nbsp;term',mf,B)&nbsp;to&nbsp;set&nbsp;the&nbsp;source&nbsp;term&nbsp;field.&nbsp;The&nbsp;source&nbsp;term&nbsp;B&nbsp;is&nbsp;expected&nbsp;as<br>
&nbsp;&nbsp;tensor&nbsp;field&nbsp;of&nbsp;size&nbsp;QxN&nbsp;(with&nbsp;Q&nbsp;=&nbsp;qdim,&nbsp;N&nbsp;=&nbsp;mesh&nbsp;dim).&nbsp;For&nbsp;example,&nbsp;if&nbsp;you<br>
&nbsp;&nbsp;consider&nbsp;an&nbsp;elasticity&nbsp;problem,&nbsp;this&nbsp;brick&nbsp;may&nbsp;be&nbsp;used&nbsp;to&nbsp;impose&nbsp;a&nbsp;force&nbsp;on<br>
&nbsp;&nbsp;the&nbsp;boundary&nbsp;with&nbsp;B&nbsp;as&nbsp;the&nbsp;stress&nbsp;tensor.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('normal_derivative_source_term',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;parent,&nbsp;int&nbsp;bnum[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Add&nbsp;a&nbsp;boundary&nbsp;source&nbsp;term&nbsp;(&nbsp;\int&nbsp;(\partial_n&nbsp;B).v&nbsp;).&nbsp;The&nbsp;source&nbsp;term&nbsp;is<br>
&nbsp;&nbsp;imposed&nbsp;on&nbsp;the&nbsp;mesh&nbsp;region&nbsp;`bnum`.&nbsp;Use&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-set_param">set_param</a>('source<br>
&nbsp;&nbsp;term',mf,B)&nbsp;to&nbsp;set&nbsp;the&nbsp;source&nbsp;term&nbsp;field,&nbsp;which&nbsp;is&nbsp;expected&nbsp;as&nbsp;a&nbsp;vector<br>
&nbsp;&nbsp;field&nbsp;of&nbsp;size&nbsp;Q&nbsp;(with&nbsp;Q&nbsp;=&nbsp;qdim).<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('neumann&nbsp;KirchhoffLove&nbsp;source&nbsp;term',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;int&nbsp;bnum[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Add&nbsp;a&nbsp;boundary&nbsp;source&nbsp;term&nbsp;for&nbsp;neumann&nbsp;Kirchhoff-Love&nbsp;plate&nbsp;problems.<br>
&nbsp;&nbsp;Should&nbsp;be&nbsp;used&nbsp;with&nbsp;the&nbsp;Kirchhoff-Love&nbsp;flavour&nbsp;of&nbsp;the&nbsp;bilaplacian&nbsp;brick.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('qu_term',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb[,&nbsp;int&nbsp;bnum[,&nbsp;int&nbsp;nfem]])<br>
&nbsp;&nbsp;Update&nbsp;the&nbsp;tangent&nbsp;matrix&nbsp;with&nbsp;a&nbsp;\int&nbsp;(Qu).v&nbsp;term.&nbsp;The&nbsp;Q(x)&nbsp;parameter&nbsp;is&nbsp;a<br>
&nbsp;&nbsp;matrix&nbsp;field&nbsp;of&nbsp;size&nbsp;qdim&nbsp;x&nbsp;qdim.&nbsp;An&nbsp;example&nbsp;of&nbsp;use&nbsp;is&nbsp;for&nbsp;the&nbsp;"iku"&nbsp;part<br>
&nbsp;&nbsp;of&nbsp;Robin&nbsp;boundary&nbsp;conditions&nbsp;\partial_n&nbsp;u&nbsp;+&nbsp;iku&nbsp;=&nbsp;...<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('mass_matrix',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u[,&nbsp;'real'|'complex'])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;mass-matrix&nbsp;brick.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('generic_elliptic',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfu[,&nbsp;'scalar'|'matrix'|'tensor'][,&nbsp;'real'|'complex'])<br>
&nbsp;&nbsp;Setup&nbsp;a&nbsp;generic&nbsp;elliptic&nbsp;problem.&nbsp;a(x)*grad(U).grad(V)<br>
&nbsp;<br>
&nbsp;&nbsp;The&nbsp;brick&nbsp;parameter&nbsp;`a`&nbsp;may&nbsp;be&nbsp;a&nbsp;scalar&nbsp;field,&nbsp;a&nbsp;matrix&nbsp;field,&nbsp;or&nbsp;a&nbsp;tensor<br>
&nbsp;&nbsp;field&nbsp;(default&nbsp;is&nbsp;scalar).<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('helmholtz',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfu[,&nbsp;'real'|'complex'])<br>
&nbsp;&nbsp;Setup&nbsp;a&nbsp;Helmholtz&nbsp;problem.&nbsp;The&nbsp;brick&nbsp;has&nbsp;one&nbsp;parameter,&nbsp;'wave_number'.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('isotropic_linearized_elasticity',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfu)<br>
&nbsp;&nbsp;Setup&nbsp;a&nbsp;linear&nbsp;elasticity&nbsp;problem.&nbsp;The&nbsp;brick&nbsp;has&nbsp;two&nbsp;scalar&nbsp;parameter,<br>
&nbsp;&nbsp;'lambda'&nbsp;and&nbsp;'mu'&nbsp;(the&nbsp;Lame&nbsp;coefficients).<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('linear_incompressibility_term',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfp[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Add&nbsp;an&nbsp;incompressibily&nbsp;constraint&nbsp;(div&nbsp;u&nbsp;=&nbsp;0).<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('nonlinear_elasticity',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfu,&nbsp;string&nbsp;law)<br>
&nbsp;&nbsp;Setup&nbsp;a&nbsp;nonlinear&nbsp;elasticity&nbsp;(large&nbsp;deformations)&nbsp;problem.<br>
&nbsp;<br>
&nbsp;&nbsp;The&nbsp;material&nbsp;`law`&nbsp;can&nbsp;be&nbsp;chosen&nbsp;among:<br>
&nbsp;&nbsp;-&nbsp;'SaintVenant&nbsp;Kirchhoff'<br>
&nbsp;&nbsp;Linearized&nbsp;material&nbsp;law.<br>
&nbsp;&nbsp;-&nbsp;'Mooney&nbsp;Rivlin'<br>
&nbsp;&nbsp;To&nbsp;be&nbsp;used&nbsp;with&nbsp;the&nbsp;nonlinear&nbsp;incompressibily&nbsp;term.<br>
&nbsp;&nbsp;-&nbsp;'Ciarlet&nbsp;Geymonat'<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('nonlinear_elasticity_incompressibility_term',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfp[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Add&nbsp;an&nbsp;incompressibily&nbsp;constraint&nbsp;to&nbsp;a&nbsp;large&nbsp;strain&nbsp;elasticity&nbsp;problem.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('small_deformations_plasticity',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfu,&nbsp;scalar&nbsp;THRESHOLD)<br>
&nbsp;&nbsp;Setup&nbsp;a&nbsp;plasticity&nbsp;problem&nbsp;(with&nbsp;small&nbsp;deformations).&nbsp;The&nbsp;`THRESHOLD`<br>
&nbsp;&nbsp;parameter&nbsp;is&nbsp;the&nbsp;maximum&nbsp;value&nbsp;of&nbsp;the&nbsp;Von&nbsp;Mises&nbsp;stress&nbsp;before<br>
&nbsp;&nbsp;'plastification'&nbsp;of&nbsp;the&nbsp;material.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('dynamic',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;scalar&nbsp;rho[,&nbsp;int&nbsp;numfem])<br>
&nbsp;&nbsp;Dynamic&nbsp;brick.&nbsp;This&nbsp;brick&nbsp;is&nbsp;not&nbsp;ready.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('bilaplacian',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfu[,&nbsp;'Kirchhoff-Love'])<br>
&nbsp;&nbsp;Setup&nbsp;a&nbsp;bilaplacian&nbsp;problem.&nbsp;If&nbsp;the&nbsp;'Kirchhoff-Love'&nbsp;option&nbsp;is&nbsp;specified,<br>
&nbsp;&nbsp;the&nbsp;Kirchhoff-Love&nbsp;plate&nbsp;model&nbsp;is&nbsp;used.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('navier_stokes',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfu,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfp)<br>
&nbsp;&nbsp;Setup&nbsp;a&nbsp;Navier-Stokes&nbsp;problem&nbsp;(this&nbsp;brick&nbsp;is&nbsp;not&nbsp;ready,&nbsp;do&nbsp;not&nbsp;use&nbsp;it).<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('isotropic_linearized_plate',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mims,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfut,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfu3,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mftheta,&nbsp;scalar&nbsp;eps)<br>
&nbsp;&nbsp;Setup&nbsp;a&nbsp;linear&nbsp;plate&nbsp;model&nbsp;brick.&nbsp;For&nbsp;moderately&nbsp;thick&nbsp;plates,&nbsp;using&nbsp;the<br>
&nbsp;&nbsp;Reissner-Mindlin&nbsp;model.&nbsp;`eps`&nbsp;is&nbsp;the&nbsp;plate&nbsp;thinkness,&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mfut`<br>
&nbsp;&nbsp;and&nbsp;`mfu3`&nbsp;are&nbsp;used&nbsp;respectively&nbsp;for&nbsp;the&nbsp;membrane&nbsp;displacement&nbsp;and&nbsp;the<br>
&nbsp;&nbsp;transverse&nbsp;displacement&nbsp;of&nbsp;the&nbsp;plate.&nbsp;The&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mftheta`&nbsp;is&nbsp;the&nbsp;rotation<br>
&nbsp;&nbsp;of&nbsp;the&nbsp;normal&nbsp;("section&nbsp;rotations").&nbsp;The&nbsp;second&nbsp;integration&nbsp;method&nbsp;`mims`<br>
&nbsp;&nbsp;can&nbsp;be&nbsp;chosen&nbsp;equal&nbsp;to&nbsp;`mim`,&nbsp;or&nbsp;different&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;perform&nbsp;sub-<br>
&nbsp;&nbsp;integration&nbsp;on&nbsp;the&nbsp;transverse&nbsp;shear&nbsp;term&nbsp;(mitc4&nbsp;projection).&nbsp;This&nbsp;brick<br>
&nbsp;&nbsp;has&nbsp;two&nbsp;parameters&nbsp;"lambda"&nbsp;and&nbsp;"mu"&nbsp;(the&nbsp;Lame&nbsp;coefficients)<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('mixed_isotropic_linearized_plate',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfut,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfu3,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mftheta,&nbsp;scalar&nbsp;eps)<br>
&nbsp;&nbsp;Setup&nbsp;a&nbsp;mixed&nbsp;linear&nbsp;plate&nbsp;model&nbsp;brick.&nbsp;For&nbsp;thin&nbsp;plates,&nbsp;using&nbsp;Kirchhoff-<br>
&nbsp;&nbsp;Love&nbsp;model.&nbsp;For&nbsp;a&nbsp;non-mixed&nbsp;version,&nbsp;use&nbsp;the&nbsp;bilaplacian&nbsp;brick.<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('plate_source_term',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb[,&nbsp;int&nbsp;bnum=-1[,&nbsp;int&nbsp;nfem]])<br>
&nbsp;&nbsp;Add&nbsp;a&nbsp;boundary&nbsp;or&nbsp;a&nbsp;volumic&nbsp;source&nbsp;term&nbsp;to&nbsp;a&nbsp;plate&nbsp;problem.&nbsp;This&nbsp;brick&nbsp;has<br>
&nbsp;&nbsp;two&nbsp;parameters:&nbsp;"B"&nbsp;is&nbsp;the&nbsp;displacement&nbsp;(ut&nbsp;and&nbsp;u3)&nbsp;source&nbsp;term,&nbsp;"M"&nbsp;is&nbsp;the<br>
&nbsp;&nbsp;moment&nbsp;source&nbsp;term&nbsp;(i.e.&nbsp;the&nbsp;source&nbsp;term&nbsp;on&nbsp;the&nbsp;rotation&nbsp;of&nbsp;the&nbsp;normal).<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('plate_simple_support',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;int&nbsp;bnum,&nbsp;string&nbsp;CTYPE[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Add&nbsp;a&nbsp;"simple&nbsp;support"&nbsp;boundary&nbsp;condition&nbsp;to&nbsp;a&nbsp;plate&nbsp;problem.&nbsp;Homogeneous<br>
&nbsp;&nbsp;Dirichlet&nbsp;condition&nbsp;on&nbsp;the&nbsp;displacement,&nbsp;free&nbsp;rotation.&nbsp;`CTYPE`&nbsp;specifies<br>
&nbsp;&nbsp;how&nbsp;the&nbsp;constraint&nbsp;is&nbsp;enforced&nbsp;('penalized',&nbsp;'augmented'&nbsp;or&nbsp;'eliminated').<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('plate_clamped_support',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb,&nbsp;int&nbsp;bnum,&nbsp;string&nbsp;CTYPE[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Add&nbsp;a&nbsp;"clamped&nbsp;support"&nbsp;boundary&nbsp;condition&nbsp;to&nbsp;a&nbsp;plate&nbsp;problem.&nbsp;Homogeneous<br>
&nbsp;&nbsp;Dirichlet&nbsp;condition&nbsp;on&nbsp;the&nbsp;displacement&nbsp;and&nbsp;on&nbsp;the&nbsp;rotation.&nbsp;`CTYPE`<br>
&nbsp;&nbsp;specifies&nbsp;how&nbsp;the&nbsp;constraint&nbsp;is&nbsp;enforced&nbsp;('penalized',&nbsp;'augmented'&nbsp;or<br>
&nbsp;&nbsp;'eliminated').<br>
*&nbsp;B&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>('plate_closing',&nbsp;<a href="#MdBrick">MdBrick</a>&nbsp;pb[,&nbsp;int&nbsp;nfem])<br>
&nbsp;&nbsp;Add&nbsp;a&nbsp;free&nbsp;edges&nbsp;condition&nbsp;for&nbsp;the&nbsp;mixed&nbsp;plate&nbsp;model&nbsp;brick.&nbsp;This&nbsp;brick&nbsp;is<br>
&nbsp;&nbsp;required&nbsp;when&nbsp;the&nbsp;mixed&nbsp;linearized&nbsp;plate&nbsp;brick&nbsp;is&nbsp;used.&nbsp;It&nbsp;must&nbsp;be&nbsp;inserted<br>
&nbsp;&nbsp;after&nbsp;all&nbsp;other&nbsp;boundary&nbsp;conditions&nbsp;(the&nbsp;reason&nbsp;is&nbsp;that&nbsp;the&nbsp;brick&nbsp;has&nbsp;to<br>
&nbsp;&nbsp;inspect&nbsp;all&nbsp;other&nbsp;boundary&nbsp;conditions&nbsp;to&nbsp;determine&nbsp;the&nbsp;number&nbsp;of<br>
&nbsp;&nbsp;disconnected&nbsp;boundary&nbsp;parts&nbsp;which&nbsp;are&nbsp;free&nbsp;edges).</tt></dd></dl>

<dl><dt><a name="MdBrick-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="MdBrick-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="MdBrick-dim"><strong>dim</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;main&nbsp;mesh&nbsp;(2&nbsp;for&nbsp;a&nbsp;2D&nbsp;mesh,&nbsp;etc).</tt></dd></dl>

<dl><dt><a name="MdBrick-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="MdBrick-is_coercive"><strong>is_coercive</strong></a>(self)</dt><dd><tt>Return&nbsp;true&nbsp;if&nbsp;the&nbsp;problem&nbsp;is&nbsp;coercive.</tt></dd></dl>

<dl><dt><a name="MdBrick-is_complex"><strong>is_complex</strong></a>(self)</dt><dd><tt>Return&nbsp;true&nbsp;if&nbsp;the&nbsp;problem&nbsp;uses&nbsp;complex&nbsp;numbers.</tt></dd></dl>

<dl><dt><a name="MdBrick-is_linear"><strong>is_linear</strong></a>(self)</dt><dd><tt>Return&nbsp;true&nbsp;if&nbsp;the&nbsp;problem&nbsp;is&nbsp;linear.</tt></dd></dl>

<dl><dt><a name="MdBrick-is_symmetric"><strong>is_symmetric</strong></a>(self)</dt><dd><tt>Return&nbsp;true&nbsp;if&nbsp;the&nbsp;problem&nbsp;is&nbsp;symmetric.</tt></dd></dl>

<dl><dt><a name="MdBrick-memsize"><strong>memsize</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;(in&nbsp;bytes)&nbsp;used&nbsp;by&nbsp;the&nbsp;model&nbsp;brick.</tt></dd></dl>

<dl><dt><a name="MdBrick-mixed_variables"><strong>mixed_variables</strong></a>(self)</dt><dd><tt>Identify&nbsp;the&nbsp;indices&nbsp;of&nbsp;mixed&nbsp;variables&nbsp;(typically&nbsp;the&nbsp;pressure,&nbsp;etc.)&nbsp;in&nbsp;the<br>
tangent&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="MdBrick-nb_constraints"><strong>nb_constraints</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;dof&nbsp;constraints&nbsp;of&nbsp;the&nbsp;current&nbsp;problem.<br>
&nbsp;<br>
Synopsis:&nbsp;n&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-nb_constraints">nb_constraints</a>()<br>
&nbsp;<br>
This&nbsp;is&nbsp;the&nbsp;sum&nbsp;of&nbsp;the&nbsp;brick&nbsp;specific&nbsp;dof&nbsp;constraints&nbsp;plus&nbsp;the&nbsp;dof&nbsp;constraints<br>
of&nbsp;the&nbsp;parent&nbsp;bricks.</tt></dd></dl>

<dl><dt><a name="MdBrick-nbdof"><strong>nbdof</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;dof&nbsp;of&nbsp;the&nbsp;current&nbsp;problem.<br>
&nbsp;<br>
Synopsis:&nbsp;n&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-nbdof">nbdof</a>()<br>
&nbsp;<br>
This&nbsp;is&nbsp;the&nbsp;sum&nbsp;of&nbsp;the&nbsp;brick&nbsp;specific&nbsp;dof&nbsp;plus&nbsp;the&nbsp;dof&nbsp;of&nbsp;the&nbsp;parent&nbsp;bricks.</tt></dd></dl>

<dl><dt><a name="MdBrick-param"><strong>param</strong></a>(self, parameter_name)</dt><dd><tt>Get&nbsp;the&nbsp;parameter&nbsp;value.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-param">param</a>(string&nbsp;parameter_name)<br>
&nbsp;<br>
When&nbsp;the&nbsp;parameter&nbsp;has&nbsp;been&nbsp;assigned&nbsp;a&nbsp;specific&nbsp;<a href="#MeshFem">MeshFem</a>,&nbsp;it&nbsp;is&nbsp;returned&nbsp;as&nbsp;a<br>
large&nbsp;array&nbsp;(the&nbsp;last&nbsp;dimension&nbsp;being&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;dof).&nbsp;When&nbsp;no&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;has<br>
been&nbsp;assigned,&nbsp;the&nbsp;parameter&nbsp;is&nbsp;considered&nbsp;to&nbsp;be&nbsp;constant&nbsp;over&nbsp;the&nbsp;mesh.</tt></dd></dl>

<dl><dt><a name="MdBrick-param_list"><strong>param_list</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;list&nbsp;of&nbsp;parameters&nbsp;names.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-param_list">param_list</a>()<br>
&nbsp;<br>
Each&nbsp;brick&nbsp;embeds&nbsp;a&nbsp;number&nbsp;of&nbsp;parameters&nbsp;(the&nbsp;Lame&nbsp;coefficients&nbsp;for&nbsp;the<br>
linearized&nbsp;elasticity&nbsp;brick,&nbsp;the&nbsp;wave&nbsp;number&nbsp;for&nbsp;the&nbsp;Helmholtz&nbsp;brick,...),<br>
described&nbsp;as&nbsp;a&nbsp;(scalar,&nbsp;or&nbsp;vector,&nbsp;tensor&nbsp;etc)&nbsp;field&nbsp;on&nbsp;a&nbsp;mesh_fem.&nbsp;You&nbsp;can<br>
read/change&nbsp;the&nbsp;parameter&nbsp;values&nbsp;with&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-param">param</a>()&nbsp;and&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-set_param">set_param</a>().</tt></dd></dl>

<dl><dt><a name="MdBrick-penalization_epsilon"><strong>penalization_epsilon</strong></a>(self, eps)</dt><dd><tt>Change&nbsp;the&nbsp;penalization&nbsp;coefficient&nbsp;of&nbsp;a&nbsp;constraint&nbsp;brick.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-penalization_epsilon">penalization_epsilon</a>(scalar&nbsp;eps)<br>
&nbsp;<br>
This&nbsp;is&nbsp;only&nbsp;applicable&nbsp;to&nbsp;the&nbsp;bricks&nbsp;which&nbsp;inherit&nbsp;from&nbsp;the&nbsp;constraint&nbsp;brick,<br>
such&nbsp;as&nbsp;the&nbsp;Dirichlet&nbsp;ones.&nbsp;And&nbsp;of&nbsp;course&nbsp;it&nbsp;is&nbsp;not&nbsp;effective&nbsp;when&nbsp;the<br>
constraint&nbsp;is&nbsp;enforced&nbsp;via&nbsp;direct&nbsp;elimination&nbsp;or&nbsp;via&nbsp;Lagrange&nbsp;multipliers.&nbsp;The<br>
default&nbsp;value&nbsp;of&nbsp;`eps`&nbsp;is&nbsp;1e-9.</tt></dd></dl>

<dl><dt><a name="MdBrick-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="MdBrick-set_constraints"><strong>set_constraints</strong></a>(self, H, R)</dt><dd><tt>Set&nbsp;the&nbsp;constraints&nbsp;imposed&nbsp;by&nbsp;a&nbsp;constraint&nbsp;brick.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-set_constraints">set_constraints</a>(mat&nbsp;H,&nbsp;vec&nbsp;R)<br>
&nbsp;<br>
This&nbsp;is&nbsp;only&nbsp;applicable&nbsp;to&nbsp;the&nbsp;bricks&nbsp;which&nbsp;inherit&nbsp;from&nbsp;the&nbsp;constraint&nbsp;brick,<br>
such&nbsp;as&nbsp;the&nbsp;Dirichlet&nbsp;ones.&nbsp;Imposes&nbsp;`H.U=R`.</tt></dd></dl>

<dl><dt><a name="MdBrick-set_constraints_rhs"><strong>set_constraints_rhs</strong></a>(self, H, R)</dt><dd><tt>Set&nbsp;the&nbsp;right&nbsp;hand&nbsp;side&nbsp;of&nbsp;the&nbsp;constraints&nbsp;imposed&nbsp;by&nbsp;a&nbsp;constraint&nbsp;brick.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-set_constraints_rhs">set_constraints_rhs</a>(mat&nbsp;H,&nbsp;vec&nbsp;R)<br>
&nbsp;<br>
This&nbsp;is&nbsp;only&nbsp;applicable&nbsp;to&nbsp;the&nbsp;bricks&nbsp;which&nbsp;inherit&nbsp;from&nbsp;the&nbsp;constraint&nbsp;brick,<br>
such&nbsp;as&nbsp;the&nbsp;Dirichlet&nbsp;ones.</tt></dd></dl>

<dl><dt><a name="MdBrick-set_param"><strong>set_param</strong></a>(self, name, *args)</dt><dd><tt>Change&nbsp;the&nbsp;value&nbsp;of&nbsp;a&nbsp;brick&nbsp;parameter.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-set_param">set_param</a>(string&nbsp;name,{<a href="#MeshFem">MeshFem</a>&nbsp;mf,V&nbsp;|&nbsp;V})<br>
&nbsp;<br>
`name`&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;parameter.&nbsp;`V`&nbsp;should&nbsp;contain&nbsp;the&nbsp;new&nbsp;parameter<br>
value&nbsp;(vector&nbsp;or&nbsp;float).&nbsp;If&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;is&nbsp;given,&nbsp;`V`&nbsp;should&nbsp;hold&nbsp;the&nbsp;field<br>
values&nbsp;over&nbsp;that&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;(i.e.&nbsp;its&nbsp;last&nbsp;dimension&nbsp;should&nbsp;be&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MdBrick-nbdof">nbdof</a>()&nbsp;or<br>
1&nbsp;for&nbsp;constant&nbsp;field).</tt></dd></dl>

<dl><dt><a name="MdBrick-solve"><strong>solve</strong></a>(self, mds, *args)</dt><dd><tt>Run&nbsp;the&nbsp;standard&nbsp;getfem&nbsp;solver.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-solve">solve</a>(<a href="#MdState">MdState</a>&nbsp;mds[,...])<br>
&nbsp;<br>
Note&nbsp;that&nbsp;you&nbsp;should&nbsp;be&nbsp;able&nbsp;to&nbsp;use&nbsp;your&nbsp;own&nbsp;solver&nbsp;if&nbsp;you&nbsp;want&nbsp;(it&nbsp;is<br>
possible&nbsp;to&nbsp;obtain&nbsp;the&nbsp;tangent&nbsp;matrix&nbsp;and&nbsp;its&nbsp;right&nbsp;hand&nbsp;side&nbsp;with&nbsp;the<br>
<a href="#MdState">MdState</a>.tangent_matrix()&nbsp;etc.).<br>
&nbsp;<br>
Various&nbsp;options&nbsp;can&nbsp;be&nbsp;specified:<br>
&nbsp;<br>
-&nbsp;'noisy'&nbsp;or&nbsp;'very&nbsp;noisy'<br>
&nbsp;&nbsp;the&nbsp;solver&nbsp;will&nbsp;display&nbsp;some&nbsp;information&nbsp;showing&nbsp;the&nbsp;progress<br>
&nbsp;&nbsp;(residual&nbsp;values&nbsp;etc.).<br>
-&nbsp;'max_iter',&nbsp;NIT<br>
&nbsp;&nbsp;set&nbsp;the&nbsp;maximum&nbsp;iterations&nbsp;numbers.<br>
-&nbsp;'max_res',&nbsp;RES<br>
&nbsp;&nbsp;set&nbsp;the&nbsp;target&nbsp;residual&nbsp;value.<br>
-&nbsp;'lsolver',&nbsp;SOLVERNAME<br>
&nbsp;&nbsp;select&nbsp;explicitely&nbsp;the&nbsp;solver&nbsp;used&nbsp;for&nbsp;the&nbsp;linear&nbsp;systems&nbsp;(the<br>
&nbsp;&nbsp;default&nbsp;value&nbsp;is&nbsp;'auto',&nbsp;which&nbsp;lets&nbsp;getfem&nbsp;choose&nbsp;itself).<br>
&nbsp;&nbsp;Possible&nbsp;values&nbsp;are&nbsp;'superlu',&nbsp;'mumps'&nbsp;(if&nbsp;supported),<br>
&nbsp;&nbsp;'cg/ildlt',&nbsp;'gmres/ilu'&nbsp;and&nbsp;'gmres/ilut'.</tt></dd></dl>

<dl><dt><a name="MdBrick-subclass"><strong>subclass</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;typename&nbsp;of&nbsp;the&nbsp;brick.</tt></dd></dl>

<dl><dt><a name="MdBrick-tresca"><strong>tresca</strong></a>(self, mds, mft)</dt><dd><tt>Compute&nbsp;the&nbsp;Tresca&nbsp;stress&nbsp;criterion&nbsp;on&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mft`.<br>
&nbsp;<br>
Synopsis:&nbsp;T&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-tresca">tresca</a>(<a href="#MdState">MdState</a>&nbsp;mds,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mft)<br>
&nbsp;<br>
Only&nbsp;available&nbsp;on&nbsp;bricks&nbsp;where&nbsp;it&nbsp;has&nbsp;a&nbsp;meaning:&nbsp;linearized&nbsp;elasticity,<br>
plasticity,&nbsp;nonlinear&nbsp;elasticity.</tt></dd></dl>

<dl><dt><a name="MdBrick-von_mises"><strong>von_mises</strong></a>(self, mds, mfvm)</dt><dd><tt>Compute&nbsp;the&nbsp;Von&nbsp;Mises&nbsp;stress&nbsp;on&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mfvm`.<br>
&nbsp;<br>
Synopsis:&nbsp;VM&nbsp;=&nbsp;<a href="#MdBrick">MdBrick</a>.<a href="#MdBrick-von_mises">von_mises</a>(<a href="#MdState">MdState</a>&nbsp;mds,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfvm)<br>
&nbsp;<br>
Only&nbsp;available&nbsp;on&nbsp;bricks&nbsp;where&nbsp;it&nbsp;has&nbsp;a&nbsp;meaning:&nbsp;linearized&nbsp;elasticity,<br>
plasticity,&nbsp;nonlinear&nbsp;elasticity.&nbsp;Note&nbsp;that&nbsp;in&nbsp;2D&nbsp;it&nbsp;is&nbsp;not&nbsp;the&nbsp;"real"&nbsp;Von<br>
Mises&nbsp;(which&nbsp;should&nbsp;take&nbsp;into&nbsp;account&nbsp;the&nbsp;'plane&nbsp;stress'&nbsp;or&nbsp;'plane&nbsp;strain'<br>
aspect),&nbsp;but&nbsp;a&nbsp;pure&nbsp;2D&nbsp;Von&nbsp;Mises.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="MdState">class <strong>MdState</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Getfem&nbsp;<a href="#MdState">MdState</a>&nbsp;Object.<br>
&nbsp;<br>
A&nbsp;model&nbsp;state&nbsp;is&nbsp;an&nbsp;object&nbsp;which&nbsp;store&nbsp;the&nbsp;state&nbsp;data&nbsp;for&nbsp;a&nbsp;chain&nbsp;of<br>
model&nbsp;bricks.&nbsp;This&nbsp;includes&nbsp;the&nbsp;global&nbsp;tangent&nbsp;matrix,&nbsp;the&nbsp;right&nbsp;hand<br>
side&nbsp;and&nbsp;the&nbsp;constraints.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="MdState-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="MdState-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;<a href="#MdState">MdState</a>&nbsp;objects.<br>
There&nbsp;are&nbsp;two&nbsp;sorts&nbsp;of&nbsp;model&nbsp;states,&nbsp;the&nbsp;'real'&nbsp;and&nbsp;the&nbsp;'complex'<br>
model&nbsp;states.<br>
&nbsp;<br>
*&nbsp;MDS&nbsp;=&nbsp;<a href="#MdState">MdState</a>(<a href="#MdBrick">MdBrick</a>&nbsp;B)<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;modelstate&nbsp;for&nbsp;the&nbsp;brick&nbsp;`B`.&nbsp;Selects&nbsp;the&nbsp;real&nbsp;or&nbsp;complex&nbsp;state<br>
&nbsp;&nbsp;from&nbsp;the&nbsp;complexity&nbsp;of&nbsp;`B`.<br>
*&nbsp;MDS&nbsp;=&nbsp;<a href="#MdState">MdState</a>('real')<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;model&nbsp;state&nbsp;for&nbsp;real&nbsp;unknowns.<br>
*&nbsp;MDS&nbsp;=&nbsp;<a href="#MdState">MdState</a>('complex')<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;model&nbsp;state&nbsp;for&nbsp;complex&nbsp;unknowns.</tt></dd></dl>

<dl><dt><a name="MdState-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="MdState-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="MdState-clear"><strong>clear</strong></a>(self)</dt><dd><tt>Clear&nbsp;the&nbsp;model&nbsp;state.</tt></dd></dl>

<dl><dt><a name="MdState-compute_reduced_residual"><strong>compute_reduced_residual</strong></a>(self)</dt><dd><tt>Compute&nbsp;the&nbsp;reduced&nbsp;residual&nbsp;from&nbsp;the&nbsp;residual&nbsp;and&nbsp;constraints.</tt></dd></dl>

<dl><dt><a name="MdState-compute_reduced_system"><strong>compute_reduced_system</strong></a>(self)</dt><dd><tt>Compute&nbsp;the&nbsp;reduced&nbsp;system&nbsp;from&nbsp;the&nbsp;tangent&nbsp;matrix&nbsp;and&nbsp;constraints.</tt></dd></dl>

<dl><dt><a name="MdState-compute_residual"><strong>compute_residual</strong></a>(self, B)</dt><dd><tt>Compute&nbsp;the&nbsp;residual&nbsp;for&nbsp;the&nbsp;brick&nbsp;`B`.</tt></dd></dl>

<dl><dt><a name="MdState-compute_tangent_matrix"><strong>compute_tangent_matrix</strong></a>(self, B)</dt><dd><tt>Update&nbsp;the&nbsp;tangent&nbsp;matrix&nbsp;from&nbsp;the&nbsp;brick&nbsp;`B`.</tt></dd></dl>

<dl><dt><a name="MdState-constraints_matrix"><strong>constraints_matrix</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;constraints&nbsp;matrix&nbsp;stored&nbsp;in&nbsp;the&nbsp;model&nbsp;state.</tt></dd></dl>

<dl><dt><a name="MdState-constraints_nullspace"><strong>constraints_nullspace</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;nullspace&nbsp;of&nbsp;the&nbsp;constraints&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="MdState-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="MdState-is_complex"><strong>is_complex</strong></a>(self)</dt><dd><tt>Return&nbsp;0&nbsp;is&nbsp;the&nbsp;model&nbsp;state&nbsp;is&nbsp;real,&nbsp;1&nbsp;if&nbsp;it&nbsp;is&nbsp;complex.</tt></dd></dl>

<dl><dt><a name="MdState-memsize"><strong>memsize</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;(in&nbsp;bytes)&nbsp;used&nbsp;by&nbsp;the&nbsp;model&nbsp;state.</tt></dd></dl>

<dl><dt><a name="MdState-reduced_residual"><strong>reduced_residual</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;residual&nbsp;on&nbsp;the&nbsp;reduced&nbsp;system.</tt></dd></dl>

<dl><dt><a name="MdState-reduced_tangent_matrix"><strong>reduced_tangent_matrix</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;reduced&nbsp;tangent&nbsp;matrix&nbsp;(i.e.&nbsp;the&nbsp;tangent&nbsp;matrix&nbsp;after&nbsp;elimination<br>
of&nbsp;the&nbsp;constraints).</tt></dd></dl>

<dl><dt><a name="MdState-residual"><strong>residual</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;residual.</tt></dd></dl>

<dl><dt><a name="MdState-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="MdState-set_state"><strong>set_state</strong></a>(self, U)</dt><dd><tt>Update&nbsp;the&nbsp;internal&nbsp;state&nbsp;with&nbsp;the&nbsp;vector&nbsp;`U`.</tt></dd></dl>

<dl><dt><a name="MdState-state"><strong>state</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;vector&nbsp;of&nbsp;unknowns,&nbsp;which&nbsp;contains&nbsp;the&nbsp;solution&nbsp;after<br>
<a href="#MdBrick">MdBrick</a>.solve().</tt></dd></dl>

<dl><dt><a name="MdState-tangent_matrix"><strong>tangent_matrix</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;tangent&nbsp;matrix&nbsp;stored&nbsp;in&nbsp;the&nbsp;model&nbsp;state.</tt></dd></dl>

<dl><dt><a name="MdState-unreduce"><strong>unreduce</strong></a>(self, U)</dt><dd><tt>Reinsert&nbsp;the&nbsp;constraint&nbsp;eliminated&nbsp;from&nbsp;the&nbsp;system.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Mesh">class <strong>Mesh</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Getfem&nbsp;<a href="#Mesh">Mesh</a>&nbsp;Object.<br>
&nbsp;<br>
Thos&nbsp;object&nbsp;is&nbsp;able&nbsp;to&nbsp;store&nbsp;any&nbsp;element&nbsp;in&nbsp;any&nbsp;dimension&nbsp;even&nbsp;<br>
if&nbsp;you&nbsp;mix&nbsp;elements&nbsp;with&nbsp;different&nbsp;dimensions.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Mesh-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="Mesh-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;<a href="#Mesh">Mesh</a>&nbsp;objects.<br>
&nbsp;<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('empty',&nbsp;int&nbsp;dim)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;new&nbsp;empty&nbsp;mesh.<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('cartesian',&nbsp;vec&nbsp;X[,&nbsp;vec&nbsp;Y[,&nbsp;vec&nbsp;Z,..]])<br>
&nbsp;&nbsp;Build&nbsp;quickly&nbsp;a&nbsp;regular&nbsp;mesh&nbsp;of&nbsp;quadrangles,&nbsp;cubes,&nbsp;etc.<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('triangles_grid',&nbsp;vec&nbsp;X,&nbsp;vec&nbsp;Y)<br>
&nbsp;&nbsp;Build&nbsp;quickly&nbsp;a&nbsp;regular&nbsp;mesh&nbsp;of&nbsp;triangles.&nbsp;This&nbsp;is&nbsp;a&nbsp;very&nbsp;limited&nbsp;and<br>
&nbsp;&nbsp;somehow&nbsp;deprecated&nbsp;function&nbsp;(See&nbsp;also&nbsp;``<a href="#Mesh">Mesh</a>('ptND')``,<br>
&nbsp;&nbsp;``<a href="#Mesh">Mesh</a>('regular_simplices')``&nbsp;and&nbsp;``<a href="#Mesh">Mesh</a>('cartesian')``).<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('regular_simplices',&nbsp;vec&nbsp;X[,&nbsp;vec&nbsp;Y[,&nbsp;vec&nbsp;Z,...]]['degree',&nbsp;int&nbsp;k]['noised'])<br>
&nbsp;&nbsp;<a href="#Mesh">Mesh</a>&nbsp;a&nbsp;n-dimensionnal&nbsp;parallelepipeded&nbsp;with&nbsp;simplices&nbsp;(triangles,<br>
&nbsp;&nbsp;tetrahedrons&nbsp;etc)&nbsp;.&nbsp;The&nbsp;optional&nbsp;degree&nbsp;may&nbsp;be&nbsp;used&nbsp;to&nbsp;build&nbsp;meshes&nbsp;with<br>
&nbsp;&nbsp;non&nbsp;linear&nbsp;geometric&nbsp;transformations.<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('curved',&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m0,&nbsp;vec&nbsp;F)<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;curved&nbsp;(n+1)-dimensions&nbsp;mesh&nbsp;from&nbsp;a&nbsp;n-dimensions&nbsp;mesh&nbsp;`m0`.&nbsp;The<br>
&nbsp;&nbsp;points&nbsp;of&nbsp;the&nbsp;new&nbsp;mesh&nbsp;have&nbsp;one&nbsp;additional&nbsp;coordinate,&nbsp;given&nbsp;by&nbsp;the&nbsp;vector<br>
&nbsp;&nbsp;`F`.&nbsp;This&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;obtain&nbsp;meshes&nbsp;for&nbsp;shells.&nbsp;`m0`&nbsp;may&nbsp;be&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a><br>
&nbsp;&nbsp;object,&nbsp;in&nbsp;that&nbsp;case&nbsp;its&nbsp;linked&nbsp;mesh&nbsp;will&nbsp;be&nbsp;used.<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('prismatic',&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m0,&nbsp;int&nbsp;NLAY)<br>
&nbsp;&nbsp;Extrude&nbsp;a&nbsp;prismatic&nbsp;<a href="#Mesh">Mesh</a>&nbsp;`M`&nbsp;from&nbsp;a&nbsp;<a href="#Mesh">Mesh</a>&nbsp;`m0`.&nbsp;In&nbsp;the&nbsp;additional&nbsp;dimension<br>
&nbsp;&nbsp;there&nbsp;are&nbsp;`NLAY`&nbsp;layers&nbsp;of&nbsp;elements&nbsp;built&nbsp;from&nbsp;``0``&nbsp;to&nbsp;``1``.<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('pt2D',&nbsp;mat&nbsp;P,&nbsp;ivec&nbsp;T[,&nbsp;int&nbsp;n])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;mesh&nbsp;from&nbsp;a&nbsp;2D&nbsp;triangulation.&nbsp;Each&nbsp;column&nbsp;of&nbsp;`P`&nbsp;contains&nbsp;a&nbsp;point<br>
&nbsp;&nbsp;coordinate,&nbsp;and&nbsp;each&nbsp;column&nbsp;of&nbsp;`T`&nbsp;contains&nbsp;the&nbsp;point&nbsp;indices&nbsp;of&nbsp;a<br>
&nbsp;&nbsp;triangle.&nbsp;`n`&nbsp;is&nbsp;optional&nbsp;and&nbsp;is&nbsp;a&nbsp;zone&nbsp;number.&nbsp;If&nbsp;`n`&nbsp;is&nbsp;specified&nbsp;then<br>
&nbsp;&nbsp;only&nbsp;the&nbsp;zone&nbsp;number&nbsp;`n`&nbsp;is&nbsp;converted&nbsp;(in&nbsp;that&nbsp;case,&nbsp;`T`&nbsp;is&nbsp;expected&nbsp;to<br>
&nbsp;&nbsp;have&nbsp;4&nbsp;rows,&nbsp;the&nbsp;fourth&nbsp;containing&nbsp;these&nbsp;zone&nbsp;numbers).<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('ptND',&nbsp;mat&nbsp;P,&nbsp;imat&nbsp;T)<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;mesh&nbsp;from&nbsp;a&nbsp;N-dimensional&nbsp;"triangulation".&nbsp;Similar&nbsp;function&nbsp;to<br>
&nbsp;&nbsp;'pt2D',&nbsp;for&nbsp;building&nbsp;simplexes&nbsp;meshes&nbsp;from&nbsp;a&nbsp;triangulation&nbsp;given&nbsp;in&nbsp;`T`,<br>
&nbsp;&nbsp;and&nbsp;a&nbsp;list&nbsp;of&nbsp;points&nbsp;given&nbsp;in&nbsp;`P`.&nbsp;The&nbsp;dimension&nbsp;of&nbsp;the&nbsp;mesh&nbsp;will&nbsp;be&nbsp;the<br>
&nbsp;&nbsp;number&nbsp;of&nbsp;rows&nbsp;of&nbsp;`P`,&nbsp;and&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;simplexes&nbsp;will&nbsp;be&nbsp;the<br>
&nbsp;&nbsp;number&nbsp;of&nbsp;rows&nbsp;of&nbsp;`T`.<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('load',&nbsp;string&nbsp;filename)<br>
&nbsp;&nbsp;Load&nbsp;a&nbsp;mesh&nbsp;from&nbsp;a&nbsp;GETFEM++&nbsp;ascii&nbsp;mesh&nbsp;file.&nbsp;See&nbsp;also&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-save">save</a>(filename).<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('from_string',&nbsp;string&nbsp;s)<br>
&nbsp;&nbsp;Load&nbsp;a&nbsp;mesh&nbsp;from&nbsp;a&nbsp;string&nbsp;description.<br>
&nbsp;<br>
&nbsp;&nbsp;For&nbsp;example,&nbsp;a&nbsp;string&nbsp;returned&nbsp;by&nbsp;``<a href="#Mesh">Mesh</a>.<a href="#Mesh-char">char</a>()``.<br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('import',&nbsp;string&nbsp;format,&nbsp;string&nbsp;filename)<br>
&nbsp;&nbsp;Import&nbsp;a&nbsp;mesh.&nbsp;`format`&nbsp;may&nbsp;be:&nbsp;-&nbsp;'gmsh'&nbsp;for&nbsp;a&nbsp;mesh&nbsp;created&nbsp;with&nbsp;`gmsh<br>
&nbsp;&nbsp;&lt;<a href="http://www.geuz.org/gmsh&gt;`_">http://www.geuz.org/gmsh&gt;`_</a><br>
&nbsp;&nbsp;-&nbsp;'gid'&nbsp;for&nbsp;a&nbsp;mesh&nbsp;created&nbsp;with&nbsp;`GiD&nbsp;&lt;<a href="http://gid.cimne.upc.es&gt;`_">http://gid.cimne.upc.es&gt;`_</a><br>
&nbsp;&nbsp;-&nbsp;'am_fmt'&nbsp;for&nbsp;a&nbsp;mesh&nbsp;created&nbsp;with&nbsp;`emc2<br>
&nbsp;&nbsp;&lt;<a href="http://pauillac.inria.fr/cdrom/www/emc2/fra.htm&gt;`_">http://pauillac.inria.fr/cdrom/www/emc2/fra.htm&gt;`_</a><br>
*&nbsp;M&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>('clone',&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m2)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;copy&nbsp;of&nbsp;a&nbsp;mesh.</tt></dd></dl>

<dl><dt><a name="Mesh-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Mesh-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Mesh-add_convex"><strong>add_convex</strong></a>(self, GT, PTS)</dt><dd><tt>Add&nbsp;a&nbsp;new&nbsp;convex&nbsp;into&nbsp;the&nbsp;mesh.<br>
&nbsp;<br>
Synopsis:&nbsp;CVIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-add_convex">add_convex</a>(<a href="#GeoTrans">GeoTrans</a>&nbsp;GT,&nbsp;mat&nbsp;PTS)<br>
&nbsp;<br>
The&nbsp;convex&nbsp;structure&nbsp;(triangle,&nbsp;prism,...)&nbsp;is&nbsp;given&nbsp;by&nbsp;`GT`&nbsp;(obtained&nbsp;with<br>
<a href="#GeoTrans">GeoTrans</a>('...')),&nbsp;and&nbsp;its&nbsp;points&nbsp;are&nbsp;given&nbsp;by&nbsp;the&nbsp;columns&nbsp;of&nbsp;`PTS`.&nbsp;On&nbsp;return,<br>
`CVIDs`&nbsp;contains&nbsp;the&nbsp;convex&nbsp;#ids.&nbsp;`PTS`&nbsp;might&nbsp;be&nbsp;a&nbsp;3-dimensional&nbsp;array&nbsp;in<br>
order&nbsp;to&nbsp;insert&nbsp;more&nbsp;than&nbsp;one&nbsp;convex&nbsp;(or&nbsp;a&nbsp;two&nbsp;dimensional&nbsp;array&nbsp;correctly<br>
shaped&nbsp;according&nbsp;to&nbsp;Fortran&nbsp;ordering).</tt></dd></dl>

<dl><dt><a name="Mesh-add_point"><strong>add_point</strong></a>(self, PTS)</dt><dd><tt>Insert&nbsp;new&nbsp;points&nbsp;in&nbsp;the&nbsp;mesh&nbsp;and&nbsp;return&nbsp;their&nbsp;#ids.<br>
&nbsp;<br>
Synopsis:&nbsp;PIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-add_point">add_point</a>(mat&nbsp;PTS)<br>
&nbsp;<br>
`PTS`&nbsp;should&nbsp;be&nbsp;an&nbsp;``nxm``&nbsp;matrix&nbsp;,&nbsp;where&nbsp;``n``&nbsp;is&nbsp;the&nbsp;mesh&nbsp;dimension,&nbsp;and<br>
``m``&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;points&nbsp;that&nbsp;will&nbsp;be&nbsp;added&nbsp;to&nbsp;the&nbsp;mesh.&nbsp;On&nbsp;output,<br>
`PIDs`&nbsp;contains&nbsp;the&nbsp;point&nbsp;#ids&nbsp;of&nbsp;these&nbsp;new&nbsp;points.<br>
&nbsp;<br>
Remark:&nbsp;if&nbsp;some&nbsp;points&nbsp;are&nbsp;already&nbsp;part&nbsp;of&nbsp;the&nbsp;mesh&nbsp;(with&nbsp;a&nbsp;small&nbsp;tolerance&nbsp;of<br>
approximately&nbsp;``1e-8``),&nbsp;they&nbsp;won't&nbsp;be&nbsp;inserted&nbsp;again,&nbsp;and&nbsp;`PIDs`&nbsp;will&nbsp;contain<br>
the&nbsp;previously&nbsp;assigned&nbsp;#ids&nbsp;of&nbsp;these&nbsp;points.</tt></dd></dl>

<dl><dt><a name="Mesh-char"><strong>char</strong></a>(self)</dt><dd><tt>Output&nbsp;a&nbsp;string&nbsp;description&nbsp;of&nbsp;the&nbsp;mesh.</tt></dd></dl>

<dl><dt><a name="Mesh-convex_area"><strong>convex_area</strong></a>(self, CVIDs<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;an&nbsp;estimation&nbsp;of&nbsp;the&nbsp;area&nbsp;of&nbsp;each&nbsp;convex.</tt></dd></dl>

<dl><dt><a name="Mesh-curved_edges"><strong>curved_edges</strong></a>(self, N, CVLST<font color="#909090">=None</font>)</dt><dd><tt>[OBSOLETE&nbsp;FUNCTION!&nbsp;will&nbsp;be&nbsp;removed&nbsp;in&nbsp;a&nbsp;future&nbsp;release]<br>
&nbsp;<br>
Synopsis:&nbsp;[E,C]&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-curved_edges">curved_edges</a>(int&nbsp;N&nbsp;[,&nbsp;CVLST])<br>
&nbsp;<br>
More&nbsp;sophisticated&nbsp;version&nbsp;of&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-edges">edges</a>()&nbsp;designed&nbsp;for&nbsp;curved&nbsp;elements.&nbsp;This<br>
one&nbsp;will&nbsp;return&nbsp;N&nbsp;(N&gt;=2)&nbsp;points&nbsp;of&nbsp;the&nbsp;(curved)&nbsp;edges.&nbsp;With&nbsp;N==2,&nbsp;this&nbsp;is<br>
equivalent&nbsp;to&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-edges">edges</a>().&nbsp;Since&nbsp;the&nbsp;points&nbsp;are&nbsp;no&nbsp;more&nbsp;always&nbsp;part&nbsp;of&nbsp;the<br>
mesh,&nbsp;their&nbsp;coordinates&nbsp;are&nbsp;returned&nbsp;instead&nbsp;of&nbsp;points&nbsp;number,&nbsp;in&nbsp;the&nbsp;array&nbsp;E<br>
which&nbsp;is&nbsp;a&nbsp;[&nbsp;mesh_dim&nbsp;x&nbsp;2&nbsp;x&nbsp;nb_edges&nbsp;]&nbsp;array.&nbsp;If&nbsp;the&nbsp;optional&nbsp;output&nbsp;argument<br>
C&nbsp;is&nbsp;specified,&nbsp;it&nbsp;will&nbsp;contain&nbsp;the&nbsp;convex&nbsp;number&nbsp;associated&nbsp;with&nbsp;each&nbsp;edge.</tt></dd></dl>

<dl><dt><a name="Mesh-cvid"><strong>cvid</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;all&nbsp;convex&nbsp;#id.<br>
&nbsp;<br>
Synopsis:&nbsp;CVid&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-cvid">cvid</a>()<br>
&nbsp;<br>
Note&nbsp;that&nbsp;their&nbsp;numbering&nbsp;is&nbsp;not&nbsp;supposed&nbsp;to&nbsp;be&nbsp;contiguous&nbsp;from&nbsp;0&nbsp;to<br>
<a href="#Mesh">Mesh</a>.<a href="#Mesh-nbcvs">nbcvs</a>()-1,&nbsp;especially&nbsp;if&nbsp;some&nbsp;points&nbsp;have&nbsp;been&nbsp;removed&nbsp;from&nbsp;the&nbsp;mesh.&nbsp;You<br>
can&nbsp;use&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-optimize_structure">optimize_structure</a>()&nbsp;to&nbsp;enforce&nbsp;a&nbsp;contiguous&nbsp;numbering.</tt></dd></dl>

<dl><dt><a name="Mesh-cvid_from_pid"><strong>cvid_from_pid</strong></a>(self, PIDs, share<font color="#909090">=False</font>)</dt><dd><tt>Search&nbsp;convex&nbsp;#ids&nbsp;related&nbsp;with&nbsp;the&nbsp;point&nbsp;#ids&nbsp;given&nbsp;in&nbsp;`PIDs`.<br>
&nbsp;<br>
Synopsis:&nbsp;CVIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-cvid_from_pid">cvid_from_pid</a>(ivec&nbsp;PIDs[,&nbsp;bool&nbsp;share=False])<br>
&nbsp;<br>
If&nbsp;`share=False`,&nbsp;search&nbsp;convex&nbsp;whose&nbsp;vertex&nbsp;#ids&nbsp;are&nbsp;in&nbsp;`PIDs`.&nbsp;If<br>
`share=True`,&nbsp;search&nbsp;convex&nbsp;#ids&nbsp;that&nbsp;share&nbsp;the&nbsp;point&nbsp;#ids&nbsp;given&nbsp;in&nbsp;`PIDs`.<br>
`CVIDs`&nbsp;is&nbsp;a&nbsp;vector&nbsp;(possibly&nbsp;empty).</tt></dd></dl>

<dl><dt><a name="Mesh-cvstruct"><strong>cvstruct</strong></a>(self, CVIDs<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;an&nbsp;array&nbsp;of&nbsp;the&nbsp;convex&nbsp;structures.<br>
&nbsp;<br>
Synopsis:&nbsp;(S,&nbsp;CV2S)&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-cvstruct">cvstruct</a>([,&nbsp;ivec&nbsp;CVIDs])<br>
&nbsp;<br>
If&nbsp;`CVIDs`&nbsp;is&nbsp;not&nbsp;given,&nbsp;all&nbsp;convexes&nbsp;are&nbsp;considered.&nbsp;Each&nbsp;convex&nbsp;structure&nbsp;is<br>
listed&nbsp;once&nbsp;in&nbsp;`S`,&nbsp;and&nbsp;`CV2S`&nbsp;maps&nbsp;the&nbsp;convexes&nbsp;indice&nbsp;in&nbsp;`CVIDs`&nbsp;to&nbsp;the<br>
indice&nbsp;of&nbsp;its&nbsp;structure&nbsp;in&nbsp;`S`.</tt></dd></dl>

<dl><dt><a name="Mesh-del_convex"><strong>del_convex</strong></a>(self, CVIDs)</dt><dd><tt>Remove&nbsp;one&nbsp;or&nbsp;more&nbsp;convexes&nbsp;from&nbsp;the&nbsp;mesh.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-del_convex">del_convex</a>(mat&nbsp;CVIDs)<br>
&nbsp;<br>
`CVIDs`&nbsp;should&nbsp;contain&nbsp;the&nbsp;convexes&nbsp;#ids,&nbsp;such&nbsp;as&nbsp;the&nbsp;ones&nbsp;returned&nbsp;by&nbsp;the<br>
'add&nbsp;convex'&nbsp;command.</tt></dd></dl>

<dl><dt><a name="Mesh-del_convex_of_dim"><strong>del_convex_of_dim</strong></a>(self, DIMs)</dt><dd><tt>Remove&nbsp;all&nbsp;convexes&nbsp;of&nbsp;dimension&nbsp;listed&nbsp;in&nbsp;`DIMs`.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-del_convex_of_dim">del_convex_of_dim</a>(ivec&nbsp;DIMs)<br>
&nbsp;<br>
For&nbsp;example;&nbsp;``<a href="#Mesh">Mesh</a>.<a href="#Mesh-del_convex_of_dim">del_convex_of_dim</a>(&nbsp;[1,2])``&nbsp;remove&nbsp;all&nbsp;line&nbsp;segments,<br>
triangles&nbsp;and&nbsp;quadrangles.</tt></dd></dl>

<dl><dt><a name="Mesh-del_point"><strong>del_point</strong></a>(self, PIDs)</dt><dd><tt>Removes&nbsp;one&nbsp;or&nbsp;more&nbsp;points&nbsp;from&nbsp;the&nbsp;mesh.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-del_point">del_point</a>(ivec&nbsp;PIDs)<br>
&nbsp;<br>
`PIDs`&nbsp;should&nbsp;contain&nbsp;the&nbsp;point&nbsp;#ids,&nbsp;such&nbsp;as&nbsp;the&nbsp;one&nbsp;returned&nbsp;by&nbsp;the&nbsp;'add<br>
point'&nbsp;command.</tt></dd></dl>

<dl><dt><a name="Mesh-delete_region"><strong>delete_region</strong></a>(self, RIDs)</dt><dd><tt>Remove&nbsp;the&nbsp;regions&nbsp;whose&nbsp;#ids&nbsp;are&nbsp;listed&nbsp;in&nbsp;`RIDs`</tt></dd></dl>

<dl><dt><a name="Mesh-dim"><strong>dim</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;mesh&nbsp;(2&nbsp;for&nbsp;a&nbsp;2D&nbsp;mesh,&nbsp;etc).</tt></dd></dl>

<dl><dt><a name="Mesh-edges"><strong>edges</strong></a>(self, CVLST<font color="#909090">=None</font>, *args)</dt><dd><tt>[OBSOLETE&nbsp;FUNCTION!&nbsp;will&nbsp;be&nbsp;removed&nbsp;in&nbsp;a&nbsp;future&nbsp;release]<br>
&nbsp;<br>
Synopsis:&nbsp;[E,C]&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-edges">edges</a>([,&nbsp;CVLST][,'merge'])<br>
&nbsp;<br>
Return&nbsp;the&nbsp;list&nbsp;of&nbsp;edges&nbsp;of&nbsp;mesh&nbsp;M&nbsp;for&nbsp;the&nbsp;convexes&nbsp;listed&nbsp;in&nbsp;the&nbsp;row&nbsp;vector<br>
CVLST.&nbsp;E&nbsp;is&nbsp;a&nbsp;2&nbsp;x&nbsp;nb_edges&nbsp;matrix&nbsp;containing&nbsp;point&nbsp;indices.&nbsp;If&nbsp;CVLST&nbsp;is<br>
omitted,&nbsp;then&nbsp;the&nbsp;edges&nbsp;of&nbsp;all&nbsp;convexes&nbsp;are&nbsp;returned.&nbsp;If&nbsp;CVLST&nbsp;has&nbsp;two&nbsp;rows<br>
then&nbsp;the&nbsp;first&nbsp;row&nbsp;is&nbsp;supposed&nbsp;to&nbsp;contain&nbsp;convex&nbsp;numbers,&nbsp;and&nbsp;the&nbsp;second&nbsp;face<br>
numbers,&nbsp;of&nbsp;which&nbsp;the&nbsp;edges&nbsp;will&nbsp;be&nbsp;returned.&nbsp;If&nbsp;'merge'&nbsp;is&nbsp;indicated,&nbsp;all<br>
common&nbsp;edges&nbsp;of&nbsp;convexes&nbsp;are&nbsp;merged&nbsp;in&nbsp;a&nbsp;single&nbsp;edge.&nbsp;If&nbsp;the&nbsp;optional&nbsp;output<br>
argument&nbsp;C&nbsp;is&nbsp;specified,&nbsp;it&nbsp;will&nbsp;contain&nbsp;the&nbsp;convex&nbsp;number&nbsp;associated&nbsp;with<br>
each&nbsp;edge.</tt></dd></dl>

<dl><dt><a name="Mesh-export_to_dx"><strong>export_to_dx</strong></a>(self, filename, *args)</dt><dd><tt>Exports&nbsp;a&nbsp;mesh&nbsp;to&nbsp;an&nbsp;OpenDX&nbsp;file.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-export_to_dx">export_to_dx</a>(string&nbsp;filename,&nbsp;...<br>
[,'ascii'][,'append'][,'as',string&nbsp;name,[,'serie',string<br>
serie_name]][,'edges'])<br>
&nbsp;<br>
See&nbsp;also&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#Mesh-export_to_dx">export_to_dx</a>(),&nbsp;<a href="#Slice">Slice</a>.<a href="#Mesh-export_to_dx">export_to_dx</a>().</tt></dd></dl>

<dl><dt><a name="Mesh-export_to_pos"><strong>export_to_pos</strong></a>(self, filename)</dt><dd><tt>Exports&nbsp;a&nbsp;mesh&nbsp;to&nbsp;a&nbsp;POS&nbsp;file&nbsp;.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-export_to_pos">export_to_pos</a>(string&nbsp;filename)<br>
&nbsp;<br>
See&nbsp;also&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#Mesh-export_to_pos">export_to_pos</a>(),&nbsp;<a href="#Slice">Slice</a>.<a href="#Mesh-export_to_pos">export_to_pos</a>().</tt></dd></dl>

<dl><dt><a name="Mesh-export_to_vtk"><strong>export_to_vtk</strong></a>(self, filename, *args)</dt><dd><tt>Exports&nbsp;a&nbsp;mesh&nbsp;to&nbsp;a&nbsp;VTK&nbsp;file&nbsp;.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-export_to_vtk">export_to_vtk</a>(string&nbsp;filename,&nbsp;...&nbsp;[,'ascii'][,'quality'])<br>
&nbsp;<br>
If&nbsp;'quality'&nbsp;is&nbsp;specified,&nbsp;an&nbsp;estimation&nbsp;of&nbsp;the&nbsp;quality&nbsp;of&nbsp;each&nbsp;convex&nbsp;will&nbsp;be<br>
written&nbsp;to&nbsp;the&nbsp;file.&nbsp;See&nbsp;also&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#Mesh-export_to_vtk">export_to_vtk</a>(),&nbsp;<a href="#Slice">Slice</a>.<a href="#Mesh-export_to_vtk">export_to_vtk</a>().</tt></dd></dl>

<dl><dt><a name="Mesh-faces_from_cvid"><strong>faces_from_cvid</strong></a>(self, CVIDs<font color="#909090">=None</font>, *args)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;convexes&nbsp;faces&nbsp;from&nbsp;a&nbsp;list&nbsp;of&nbsp;convex&nbsp;#id.<br>
&nbsp;<br>
Synopsis:&nbsp;CVFIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-faces_from_cvid">faces_from_cvid</a>([,&nbsp;ivec&nbsp;CVIDs][,&nbsp;'merge'])<br>
&nbsp;<br>
`CVFIDs`&nbsp;is&nbsp;a&nbsp;two-rows&nbsp;matrix,&nbsp;the&nbsp;first&nbsp;row&nbsp;lists&nbsp;convex&nbsp;#ids,&nbsp;and&nbsp;the&nbsp;second<br>
lists&nbsp;face&nbsp;numbers.&nbsp;If&nbsp;`CVIDs`&nbsp;is&nbsp;not&nbsp;given,&nbsp;all&nbsp;convexes&nbsp;are&nbsp;considered.&nbsp;The<br>
optional&nbsp;argument&nbsp;'merge'&nbsp;merges&nbsp;faces&nbsp;shared&nbsp;by&nbsp;the&nbsp;convex&nbsp;of&nbsp;`CVIDs`.</tt></dd></dl>

<dl><dt><a name="Mesh-faces_from_pid"><strong>faces_from_pid</strong></a>(self, PIDs)</dt><dd><tt>Return&nbsp;the&nbsp;convex&nbsp;faces&nbsp;whose&nbsp;vertex&nbsp;#ids&nbsp;are&nbsp;in&nbsp;`PIDs`.<br>
&nbsp;<br>
Synopsis:&nbsp;CVFIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-faces_from_pid">faces_from_pid</a>(ivec&nbsp;PIDs)<br>
&nbsp;<br>
For&nbsp;a&nbsp;convex&nbsp;face&nbsp;to&nbsp;be&nbsp;returned,&nbsp;EACH&nbsp;of&nbsp;its&nbsp;points&nbsp;have&nbsp;to&nbsp;be&nbsp;listed&nbsp;in<br>
`PIDs`.&nbsp;On&nbsp;output,&nbsp;the&nbsp;first&nbsp;row&nbsp;of&nbsp;`CVf`&nbsp;contains&nbsp;the&nbsp;convex&nbsp;number,&nbsp;and&nbsp;the<br>
second&nbsp;row&nbsp;contains&nbsp;the&nbsp;face&nbsp;number&nbsp;(local&nbsp;number&nbsp;in&nbsp;the&nbsp;convex).</tt></dd></dl>

<dl><dt><a name="Mesh-geotrans"><strong>geotrans</strong></a>(self, CVIDs<font color="#909090">=None</font>)</dt><dd><tt>Returns&nbsp;an&nbsp;array&nbsp;of&nbsp;the&nbsp;geometric&nbsp;transformations.<br>
&nbsp;<br>
Synopsis:&nbsp;(GT,&nbsp;CV2GT)&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-geotrans">geotrans</a>([,&nbsp;ivec&nbsp;CVIDs])<br>
&nbsp;<br>
See&nbsp;also&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-cvstruct">cvstruct</a>().</tt></dd></dl>

<dl><dt><a name="Mesh-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Mesh-max_cvid"><strong>max_cvid</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;maximum&nbsp;#id&nbsp;of&nbsp;all&nbsp;convexes&nbsp;in&nbsp;the&nbsp;mesh&nbsp;(see&nbsp;'max&nbsp;pid').</tt></dd></dl>

<dl><dt><a name="Mesh-max_pid"><strong>max_pid</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;maximum&nbsp;#id&nbsp;of&nbsp;all&nbsp;points&nbsp;in&nbsp;the&nbsp;mesh&nbsp;(see&nbsp;'max&nbsp;cvid').</tt></dd></dl>

<dl><dt><a name="Mesh-memsize"><strong>memsize</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;(in&nbsp;bytes)&nbsp;used&nbsp;by&nbsp;the&nbsp;mesh.</tt></dd></dl>

<dl><dt><a name="Mesh-merge"><strong>merge</strong></a>(self, m2)</dt><dd><tt>Merge&nbsp;with&nbsp;the&nbsp;<a href="#Mesh">Mesh</a>&nbsp;`m2`.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-merge">merge</a>(<a href="#Mesh">Mesh</a>&nbsp;m2)<br>
&nbsp;<br>
Overlapping&nbsp;points&nbsp;won't&nbsp;be&nbsp;duplicated.&nbsp;If&nbsp;`m2`&nbsp;is&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;object,&nbsp;its<br>
linked&nbsp;mesh&nbsp;will&nbsp;be&nbsp;used.</tt></dd></dl>

<dl><dt><a name="Mesh-nbcvs"><strong>nbcvs</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;number&nbsp;of&nbsp;convexes&nbsp;of&nbsp;the&nbsp;mesh.</tt></dd></dl>

<dl><dt><a name="Mesh-nbpts"><strong>nbpts</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;number&nbsp;of&nbsp;points&nbsp;of&nbsp;the&nbsp;mesh.</tt></dd></dl>

<dl><dt><a name="Mesh-normal_of_face"><strong>normal_of_face</strong></a>(self, cv, f, nfpt<font color="#909090">=None</font>)</dt><dd><tt>Evaluates&nbsp;the&nbsp;normal&nbsp;of&nbsp;convex&nbsp;`cv`,&nbsp;face&nbsp;`f`&nbsp;at&nbsp;the&nbsp;`nfpt`&nbsp;point&nbsp;of&nbsp;the&nbsp;face.<br>
&nbsp;<br>
Synopsis:&nbsp;N&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-normal_of_face">normal_of_face</a>(int&nbsp;cv,&nbsp;int&nbsp;f[,&nbsp;int&nbsp;nfpt])<br>
&nbsp;<br>
If&nbsp;`nfpt`&nbsp;is&nbsp;not&nbsp;specified,&nbsp;then&nbsp;the&nbsp;normal&nbsp;is&nbsp;evaluated&nbsp;at&nbsp;each&nbsp;geometrical<br>
node&nbsp;of&nbsp;the&nbsp;face.</tt></dd></dl>

<dl><dt><a name="Mesh-normal_of_faces"><strong>normal_of_faces</strong></a>(self, CVFIDs)</dt><dd><tt>Evaluates&nbsp;(at&nbsp;face&nbsp;centers)&nbsp;the&nbsp;normals&nbsp;of&nbsp;convexes.<br>
&nbsp;<br>
Synopsis:&nbsp;N&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-normal_of_faces">normal_of_faces</a>(imat&nbsp;CVFIDs)<br>
&nbsp;<br>
`CVFIDs`&nbsp;is&nbsp;supposed&nbsp;to&nbsp;contain&nbsp;convex&nbsp;numbers&nbsp;in&nbsp;its&nbsp;first&nbsp;row&nbsp;and&nbsp;convex<br>
face&nbsp;number&nbsp;in&nbsp;its&nbsp;second&nbsp;row.</tt></dd></dl>

<dl><dt><a name="Mesh-optimize_structure"><strong>optimize_structure</strong></a>(self)</dt><dd><tt>Reset&nbsp;point&nbsp;and&nbsp;convex&nbsp;numbering.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-optimize_structure">optimize_structure</a>()<br>
&nbsp;<br>
After&nbsp;optimisation,&nbsp;the&nbsp;points&nbsp;(resp.&nbsp;convexes)&nbsp;will&nbsp;be&nbsp;consecutively&nbsp;numbered<br>
from&nbsp;``0``&nbsp;to&nbsp;``<a href="#Mesh">Mesh</a>.<a href="#Mesh-max_pid">max_pid</a>()-1``&nbsp;(resp.&nbsp;``<a href="#Mesh">Mesh</a>.<a href="#Mesh-max_cvid">max_cvid</a>()-1``).</tt></dd></dl>

<dl><dt><a name="Mesh-orphaned_pid"><strong>orphaned_pid</strong></a>(self)</dt><dd><tt>Search&nbsp;point&nbsp;#id&nbsp;which&nbsp;are&nbsp;not&nbsp;linked&nbsp;to&nbsp;a&nbsp;convex.</tt></dd></dl>

<dl><dt><a name="Mesh-outer_faces"><strong>outer_faces</strong></a>(self, CVIDs<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;the&nbsp;faces&nbsp;which&nbsp;are&nbsp;not&nbsp;shared&nbsp;by&nbsp;two&nbsp;convexes.<br>
&nbsp;<br>
Synopsis:&nbsp;CVFIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-outer_faces">outer_faces</a>([,&nbsp;CVIDs])<br>
&nbsp;<br>
If&nbsp;`CVIDs`&nbsp;is&nbsp;not&nbsp;given,&nbsp;it&nbsp;basically&nbsp;returns&nbsp;the&nbsp;mesh&nbsp;boundary.&nbsp;If&nbsp;`CVIDs`&nbsp;is<br>
given,&nbsp;it&nbsp;returns&nbsp;the&nbsp;boundary&nbsp;of&nbsp;the&nbsp;convex&nbsp;set&nbsp;whose&nbsp;#ids&nbsp;are&nbsp;listed&nbsp;in<br>
`CVIDs`.</tt></dd></dl>

<dl><dt><a name="Mesh-pid"><strong>pid</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;points&nbsp;#id&nbsp;of&nbsp;the&nbsp;mesh.<br>
&nbsp;<br>
Synopsis:&nbsp;Pid&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-pid">pid</a>()<br>
&nbsp;<br>
Note&nbsp;that&nbsp;their&nbsp;numbering&nbsp;is&nbsp;not&nbsp;supposed&nbsp;to&nbsp;be&nbsp;contiguous&nbsp;from&nbsp;0&nbsp;to<br>
<a href="#Mesh">Mesh</a>.<a href="#Mesh-nbpts">nbpts</a>()-1,&nbsp;especially&nbsp;if&nbsp;some&nbsp;points&nbsp;have&nbsp;been&nbsp;removed&nbsp;from&nbsp;the&nbsp;mesh.&nbsp;You<br>
can&nbsp;use&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-optimize_structure">optimize_structure</a>()&nbsp;to&nbsp;enforce&nbsp;a&nbsp;contiguous&nbsp;numbering.</tt></dd></dl>

<dl><dt><a name="Mesh-pid_from_coords"><strong>pid_from_coords</strong></a>(self, PTS, radius<font color="#909090">=0</font>)</dt><dd><tt>Search&nbsp;point&nbsp;#id&nbsp;whose&nbsp;coordinates&nbsp;are&nbsp;listed&nbsp;in&nbsp;`PTS`.<br>
&nbsp;<br>
Synopsis:&nbsp;PIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-pid_from_coords">pid_from_coords</a>(mat&nbsp;PTS[,&nbsp;scalar&nbsp;radius=0])<br>
&nbsp;<br>
`PTS`&nbsp;is&nbsp;an&nbsp;array&nbsp;containing&nbsp;a&nbsp;list&nbsp;of&nbsp;point&nbsp;coordinates.&nbsp;On&nbsp;return,&nbsp;`PIDs`&nbsp;is<br>
a&nbsp;vector&nbsp;containing&nbsp;points&nbsp;#id&nbsp;for&nbsp;each&nbsp;point&nbsp;found&nbsp;in&nbsp;`eps`&nbsp;range,&nbsp;and&nbsp;-1&nbsp;for<br>
those&nbsp;which&nbsp;where&nbsp;not&nbsp;found&nbsp;in&nbsp;the&nbsp;mesh.</tt></dd></dl>

<dl><dt><a name="Mesh-pid_from_cvid"><strong>pid_from_cvid</strong></a>(self, CVIDs<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;the&nbsp;points&nbsp;attached&nbsp;to&nbsp;each&nbsp;convex&nbsp;of&nbsp;the&nbsp;mesh.<br>
&nbsp;<br>
Synopsis:&nbsp;(Pid,&nbsp;IDx)&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-pid_from_cvid">pid_from_cvid</a>([,imat&nbsp;CVIDs])<br>
&nbsp;<br>
If&nbsp;`CVIDs`&nbsp;is&nbsp;omitted,&nbsp;all&nbsp;the&nbsp;convexes&nbsp;will&nbsp;be&nbsp;considered&nbsp;(equivalent&nbsp;to<br>
`CVIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-max_cvid">max_cvid</a>()`).&nbsp;`IDx`&nbsp;is&nbsp;a&nbsp;vector,&nbsp;length(IDx)&nbsp;=&nbsp;length(CVIDs)+1.<br>
`Pid`&nbsp;is&nbsp;a&nbsp;vector&nbsp;containing&nbsp;the&nbsp;concatenated&nbsp;list&nbsp;of&nbsp;#id&nbsp;of&nbsp;points&nbsp;of&nbsp;each<br>
convex&nbsp;in&nbsp;`CVIDs`.&nbsp;Each&nbsp;entry&nbsp;of&nbsp;`IDx`&nbsp;is&nbsp;the&nbsp;position&nbsp;of&nbsp;the&nbsp;corresponding<br>
convex&nbsp;point&nbsp;list&nbsp;in&nbsp;`Pid`.&nbsp;Hence,&nbsp;for&nbsp;example,&nbsp;the&nbsp;list&nbsp;of&nbsp;#id&nbsp;of&nbsp;points&nbsp;of<br>
the&nbsp;second&nbsp;convex&nbsp;is&nbsp;Pid[IDx(2):IDx(3)].<br>
&nbsp;<br>
If&nbsp;`CVIDs`&nbsp;contains&nbsp;convex&nbsp;#id&nbsp;which&nbsp;do&nbsp;not&nbsp;exist&nbsp;in&nbsp;the&nbsp;mesh,&nbsp;their&nbsp;point<br>
list&nbsp;will&nbsp;be&nbsp;empty.</tt></dd></dl>

<dl><dt><a name="Mesh-pid_in_cvids"><strong>pid_in_cvids</strong></a>(self, CVIDs)</dt><dd><tt>Search&nbsp;point&nbsp;#id&nbsp;listed&nbsp;in&nbsp;`CVIDs`.<br>
&nbsp;<br>
Synopsis:&nbsp;PIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-pid_in_cvids">pid_in_cvids</a>(imat&nbsp;CVIDs)<br>
&nbsp;<br>
`PIDs`&nbsp;is&nbsp;a&nbsp;vector&nbsp;containing&nbsp;points&nbsp;#id.</tt></dd></dl>

<dl><dt><a name="Mesh-pid_in_faces"><strong>pid_in_faces</strong></a>(self, CVFIDs)</dt><dd><tt>Search&nbsp;point&nbsp;#id&nbsp;listed&nbsp;in&nbsp;`CVFIDs`.<br>
&nbsp;<br>
Synopsis:&nbsp;PIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-pid_in_faces">pid_in_faces</a>(imat&nbsp;CVFIDs)<br>
&nbsp;<br>
`CVFIDs`&nbsp;is&nbsp;a&nbsp;two-rows&nbsp;matrix,&nbsp;the&nbsp;first&nbsp;row&nbsp;lists&nbsp;convex&nbsp;#ids,&nbsp;and&nbsp;the&nbsp;second<br>
lists&nbsp;face&nbsp;numbers.&nbsp;On&nbsp;return,&nbsp;`PIDs`&nbsp;is&nbsp;a&nbsp;vector&nbsp;containing&nbsp;points&nbsp;#id.</tt></dd></dl>

<dl><dt><a name="Mesh-pid_in_regions"><strong>pid_in_regions</strong></a>(self, RIDs)</dt><dd><tt>Search&nbsp;point&nbsp;#id&nbsp;listed&nbsp;in&nbsp;`RIDs`.<br>
&nbsp;<br>
Synopsis:&nbsp;PIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-pid_in_regions">pid_in_regions</a>(imat&nbsp;RIDs)<br>
&nbsp;<br>
`PIDs`&nbsp;is&nbsp;a&nbsp;vector&nbsp;containing&nbsp;points&nbsp;#id.</tt></dd></dl>

<dl><dt><a name="Mesh-pts"><strong>pts</strong></a>(self, PIDs<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;point&nbsp;coordinates&nbsp;of&nbsp;the&nbsp;mesh.<br>
&nbsp;<br>
Synopsis:&nbsp;P&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-pts">pts</a>([,&nbsp;ivec&nbsp;PIDs])<br>
&nbsp;<br>
Each&nbsp;column&nbsp;of&nbsp;the&nbsp;returned&nbsp;matrix&nbsp;contains&nbsp;the&nbsp;coordinates&nbsp;of&nbsp;one&nbsp;point.&nbsp;If<br>
the&nbsp;optional&nbsp;argument&nbsp;`PIDs`&nbsp;was&nbsp;given,&nbsp;only&nbsp;the&nbsp;points&nbsp;whose&nbsp;#id&nbsp;is&nbsp;listed&nbsp;in<br>
this&nbsp;vector&nbsp;are&nbsp;returned.&nbsp;Otherwise,&nbsp;the&nbsp;returned&nbsp;matrix&nbsp;will&nbsp;have<br>
<a href="#Mesh">Mesh</a>.<a href="#Mesh-max_pid">max_pid</a>()&nbsp;columns,&nbsp;which&nbsp;might&nbsp;be&nbsp;greater&nbsp;than&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-nbpts">nbpts</a>()&nbsp;(if&nbsp;some<br>
points&nbsp;of&nbsp;the&nbsp;mesh&nbsp;have&nbsp;been&nbsp;destroyed&nbsp;and&nbsp;no&nbsp;call&nbsp;to<br>
<a href="#Mesh">Mesh</a>.<a href="#Mesh-optimize_structure">optimize_structure</a>()&nbsp;have&nbsp;been&nbsp;issued).&nbsp;The&nbsp;columns&nbsp;corresponding&nbsp;to<br>
deleted&nbsp;points&nbsp;will&nbsp;be&nbsp;filled&nbsp;with&nbsp;NaN.&nbsp;You&nbsp;can&nbsp;use&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-pid">pid</a>()&nbsp;to&nbsp;filter&nbsp;such<br>
invalid&nbsp;points.</tt></dd></dl>

<dl><dt><a name="Mesh-quality"><strong>quality</strong></a>(self, CVIDs<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;an&nbsp;estimation&nbsp;of&nbsp;the&nbsp;quality&nbsp;of&nbsp;each&nbsp;convex&nbsp;(0&nbsp;&lt;=&nbsp;Q&nbsp;&lt;=&nbsp;1).</tt></dd></dl>

<dl><dt><a name="Mesh-refine"><strong>refine</strong></a>(self, CVIDs<font color="#909090">=None</font>)</dt><dd><tt>Use&nbsp;a&nbsp;Bank&nbsp;strategy&nbsp;for&nbsp;mesh&nbsp;refinement.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-refine">refine</a>([,&nbsp;ivec&nbsp;CVIDs])<br>
&nbsp;<br>
If&nbsp;`CVIDs`&nbsp;is&nbsp;not&nbsp;given,&nbsp;the&nbsp;whole&nbsp;mesh&nbsp;is&nbsp;refined.&nbsp;Note&nbsp;that&nbsp;the&nbsp;regions,&nbsp;and<br>
the&nbsp;finite&nbsp;element&nbsp;methods&nbsp;and&nbsp;integration&nbsp;methods&nbsp;of&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;and&nbsp;<a href="#MeshIm">MeshIm</a><br>
objects&nbsp;linked&nbsp;to&nbsp;this&nbsp;mesh&nbsp;will&nbsp;be&nbsp;automagically&nbsp;refined.</tt></dd></dl>

<dl><dt><a name="Mesh-region"><strong>region</strong></a>(self, RIDs)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;convexes/faces&nbsp;on&nbsp;the&nbsp;regions&nbsp;`RIDs`.<br>
&nbsp;<br>
Synopsis:&nbsp;CVFIDs&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-region">region</a>(ivec&nbsp;RIDs)<br>
&nbsp;<br>
On&nbsp;output,&nbsp;the&nbsp;first&nbsp;row&nbsp;of&nbsp;`CVFIDs`&nbsp;contains&nbsp;the&nbsp;convex&nbsp;numbers,&nbsp;and&nbsp;the<br>
second&nbsp;row&nbsp;contains&nbsp;the&nbsp;face&nbsp;numbers&nbsp;(and&nbsp;-1&nbsp;when&nbsp;the&nbsp;whole&nbsp;convex&nbsp;is&nbsp;in&nbsp;the<br>
regions).</tt></dd></dl>

<dl><dt><a name="Mesh-region_intersect"><strong>region_intersect</strong></a>(self, r1, r2)</dt><dd><tt>Replace&nbsp;the&nbsp;region&nbsp;number&nbsp;`r1`&nbsp;with&nbsp;its&nbsp;intersection&nbsp;with&nbsp;region&nbsp;number&nbsp;`r2`.</tt></dd></dl>

<dl><dt><a name="Mesh-region_merge"><strong>region_merge</strong></a>(self, r1, r2)</dt><dd><tt>Merge&nbsp;region&nbsp;number&nbsp;`r2`&nbsp;into&nbsp;region&nbsp;number&nbsp;`r1`.</tt></dd></dl>

<dl><dt><a name="Mesh-region_substract"><strong>region_substract</strong></a>(self, r1, r2)</dt><dd><tt>Replace&nbsp;the&nbsp;region&nbsp;number&nbsp;`r1`&nbsp;with&nbsp;its&nbsp;difference&nbsp;with&nbsp;region&nbsp;number&nbsp;`r2`.</tt></dd></dl>

<dl><dt><a name="Mesh-regions"><strong>regions</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;valid&nbsp;regions&nbsp;stored&nbsp;in&nbsp;the&nbsp;mesh.</tt></dd></dl>

<dl><dt><a name="Mesh-save"><strong>save</strong></a>(self, filename)</dt><dd><tt>Save&nbsp;the&nbsp;mesh&nbsp;object&nbsp;to&nbsp;an&nbsp;ascii&nbsp;file.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-save">save</a>(string&nbsp;filename)<br>
&nbsp;<br>
This&nbsp;mesh&nbsp;can&nbsp;be&nbsp;restored&nbsp;with&nbsp;<a href="#Mesh">Mesh</a>('load',&nbsp;filename).</tt></dd></dl>

<dl><dt><a name="Mesh-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Mesh-set_pts"><strong>set_pts</strong></a>(self, PTS)</dt><dd><tt>Replace&nbsp;the&nbsp;coordinates&nbsp;of&nbsp;the&nbsp;mesh&nbsp;points&nbsp;with&nbsp;those&nbsp;given&nbsp;in&nbsp;`PTS`.</tt></dd></dl>

<dl><dt><a name="Mesh-set_region"><strong>set_region</strong></a>(self, rnum, CVFIDs)</dt><dd><tt>Assigns&nbsp;the&nbsp;region&nbsp;number&nbsp;`rnum`&nbsp;to&nbsp;the&nbsp;convex&nbsp;faces&nbsp;stored&nbsp;in&nbsp;each&nbsp;column&nbsp;of<br>
the&nbsp;matrix&nbsp;`CVFIDs`.&nbsp;The&nbsp;first&nbsp;row&nbsp;of&nbsp;`CVFIDs`&nbsp;contains&nbsp;a&nbsp;convex&nbsp;#ids,&nbsp;and<br>
the&nbsp;second&nbsp;row&nbsp;contains&nbsp;a&nbsp;face&nbsp;number&nbsp;in&nbsp;the&nbsp;convex&nbsp;(or&nbsp;``-1``&nbsp;for&nbsp;the&nbsp;whole<br>
convex&nbsp;(regions&nbsp;are&nbsp;usually&nbsp;used&nbsp;to&nbsp;store&nbsp;a&nbsp;list&nbsp;of&nbsp;convex&nbsp;faces,&nbsp;but&nbsp;you&nbsp;may<br>
also&nbsp;use&nbsp;them&nbsp;to&nbsp;store&nbsp;a&nbsp;list&nbsp;of&nbsp;convexes).</tt></dd></dl>

<dl><dt><a name="Mesh-transform"><strong>transform</strong></a>(self, T)</dt><dd><tt>Applies&nbsp;the&nbsp;matrix&nbsp;`T`&nbsp;to&nbsp;each&nbsp;point&nbsp;of&nbsp;the&nbsp;mesh.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-transform">transform</a>(mat&nbsp;T)<br>
&nbsp;<br>
Note&nbsp;that&nbsp;`T`&nbsp;is&nbsp;not&nbsp;required&nbsp;to&nbsp;be&nbsp;a&nbsp;``NxN``&nbsp;matrix&nbsp;(with&nbsp;``N&nbsp;=<br>
<a href="#Mesh">Mesh</a>.<a href="#Mesh-dim">dim</a>()``).&nbsp;Hence&nbsp;it&nbsp;is&nbsp;possible&nbsp;to&nbsp;transform&nbsp;a&nbsp;2D&nbsp;mesh&nbsp;into&nbsp;a&nbsp;3D&nbsp;one&nbsp;(and<br>
reciprocally).</tt></dd></dl>

<dl><dt><a name="Mesh-translate"><strong>translate</strong></a>(self, V)</dt><dd><tt>Translates&nbsp;each&nbsp;point&nbsp;of&nbsp;the&nbsp;mesh&nbsp;from&nbsp;`V`.</tt></dd></dl>

<dl><dt><a name="Mesh-triangulated_surface"><strong>triangulated_surface</strong></a>(self, Nrefine, CVLIST<font color="#909090">=None</font>)</dt><dd><tt>[OBSOLETE&nbsp;FUNCTION!&nbsp;will&nbsp;be&nbsp;removed&nbsp;in&nbsp;a&nbsp;future&nbsp;release]<br>
&nbsp;<br>
Synopsis:&nbsp;[mat&nbsp;T]&nbsp;=&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-triangulated_surface">triangulated_surface</a>(int&nbsp;Nrefine&nbsp;[,CVLIST])<br>
&nbsp;<br>
Similar&nbsp;function&nbsp;to&nbsp;<a href="#Mesh">Mesh</a>.<a href="#Mesh-curved_edges">curved_edges</a>()&nbsp;:&nbsp;split&nbsp;(if&nbsp;necessary,&nbsp;i.e.&nbsp;if&nbsp;the<br>
geometric&nbsp;transformation&nbsp;if&nbsp;non-linear)&nbsp;each&nbsp;face&nbsp;into&nbsp;sub-triangles&nbsp;and<br>
return&nbsp;their&nbsp;coordinates&nbsp;in&nbsp;T&nbsp;(see&nbsp;also&nbsp;compute_eval&nbsp;on&nbsp;P1&nbsp;tri&nbsp;mesh(mf,&nbsp;U,&nbsp;))</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="MeshFem">class <strong>MeshFem</strong></a></font></td></tr>
    
<tr><td bgcolor="#ffc8d8"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="MeshFem-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="MeshFem-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;objects.<br>
&nbsp;<br>
*&nbsp;<a href="#MeshFem">MeshFem</a>('load',&nbsp;string&nbsp;fname[,&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m])<br>
&nbsp;&nbsp;Load&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;from&nbsp;a&nbsp;file.&nbsp;If&nbsp;the&nbsp;mesh&nbsp;`m`&nbsp;is&nbsp;not&nbsp;supplied&nbsp;(this&nbsp;kind&nbsp;of<br>
&nbsp;&nbsp;file&nbsp;does&nbsp;not&nbsp;store&nbsp;the&nbsp;mesh),&nbsp;then&nbsp;it&nbsp;is&nbsp;read&nbsp;from&nbsp;the&nbsp;file&nbsp;`fname`&nbsp;and<br>
&nbsp;&nbsp;its&nbsp;descriptor&nbsp;is&nbsp;returned&nbsp;as&nbsp;the&nbsp;second&nbsp;output&nbsp;argument.<br>
*&nbsp;<a href="#MeshFem">MeshFem</a>('from_string',&nbsp;string&nbsp;[,&nbsp;mesh&nbsp;M])<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;object&nbsp;from&nbsp;its&nbsp;string&nbsp;description.&nbsp;See&nbsp;also<br>
&nbsp;&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-char">char</a>()<br>
*&nbsp;<a href="#MeshFem">MeshFem</a>('clone',&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf2)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;copy&nbsp;of&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
*&nbsp;<a href="#MeshFem">MeshFem</a>('sum',&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf1,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf2[,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf3[,&nbsp;...]])<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;that&nbsp;combines&nbsp;two&nbsp;(or&nbsp;more)&nbsp;<a href="#MeshFem">MeshFem</a>'s.&nbsp;All&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;must<br>
&nbsp;&nbsp;share&nbsp;the&nbsp;same&nbsp;mesh&nbsp;(see&nbsp;<a href="#Fem">Fem</a>('interpolated_fem')&nbsp;to&nbsp;map&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;onto<br>
&nbsp;&nbsp;another).&nbsp;After&nbsp;that,&nbsp;you&nbsp;should&nbsp;not&nbsp;modify&nbsp;the&nbsp;FEM&nbsp;of&nbsp;`mf1`,&nbsp;`mf2`&nbsp;etc.<br>
*&nbsp;<a href="#MeshFem">MeshFem</a>('levelset',&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf,&nbsp;<a href="#LevelSet">LevelSet</a>&nbsp;ls)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;that&nbsp;is&nbsp;conformal&nbsp;to&nbsp;implicit&nbsp;surfaces&nbsp;defined&nbsp;by<br>
&nbsp;&nbsp;<a href="#LevelSet">LevelSet</a>'s.<br>
*&nbsp;<a href="#MeshFem">MeshFem</a>('partial',&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf,&nbsp;ivec&nbsp;DOFs[,ivec&nbsp;RCVs])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;restricted&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;by&nbsp;keeping&nbsp;only&nbsp;a&nbsp;subset&nbsp;of&nbsp;the&nbsp;degrees&nbsp;of<br>
&nbsp;&nbsp;freedom&nbsp;of&nbsp;`mf`.&nbsp;If&nbsp;`RCVs`&nbsp;is&nbsp;given,&nbsp;no&nbsp;FEM&nbsp;will&nbsp;be&nbsp;put&nbsp;on&nbsp;the&nbsp;convexes<br>
&nbsp;&nbsp;listed&nbsp;in&nbsp;`RCVs`.<br>
*&nbsp;<a href="#MeshFem">MeshFem</a>(&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m[,&nbsp;int&nbsp;Qdim=1])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;new&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;object.&nbsp;The&nbsp;`Qdim`&nbsp;parameter&nbsp;is&nbsp;optional.</tt></dd></dl>

<dl><dt><a name="MeshFem-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="MeshFem-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="MeshFem-basic_dof_from_cv"><strong>basic_dof_from_cv</strong></a>(self, CVids)</dt><dd><tt>Return&nbsp;the&nbsp;dof&nbsp;of&nbsp;the&nbsp;convexes&nbsp;listed&nbsp;in&nbsp;`CVids`.<br>
&nbsp;<br>
Synopsis:&nbsp;DOF&nbsp;=&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-basic_dof_from_cv">basic_dof_from_cv</a>(mat&nbsp;CVids)<br>
&nbsp;<br>
WARNING:&nbsp;the&nbsp;Degree&nbsp;of&nbsp;Freedom&nbsp;might&nbsp;be&nbsp;returned&nbsp;in&nbsp;ANY&nbsp;order,&nbsp;do&nbsp;not&nbsp;use&nbsp;this<br>
function&nbsp;in&nbsp;your&nbsp;assembly&nbsp;routines.&nbsp;Use&nbsp;'basic&nbsp;dof&nbsp;from&nbsp;cvid'&nbsp;instead,&nbsp;if&nbsp;you<br>
want&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;map&nbsp;a&nbsp;convex&nbsp;number&nbsp;with&nbsp;its&nbsp;associated&nbsp;degrees&nbsp;of&nbsp;freedom.<br>
One&nbsp;can&nbsp;also&nbsp;get&nbsp;the&nbsp;list&nbsp;of&nbsp;basic&nbsp;dof&nbsp;on&nbsp;a&nbsp;set&nbsp;on&nbsp;convex&nbsp;faces,&nbsp;by&nbsp;indicating<br>
on&nbsp;the&nbsp;second&nbsp;row&nbsp;of&nbsp;`CVids`&nbsp;the&nbsp;faces&nbsp;numbers&nbsp;(with&nbsp;respect&nbsp;to&nbsp;the&nbsp;convex<br>
number&nbsp;on&nbsp;the&nbsp;first&nbsp;row).</tt></dd></dl>

<dl><dt><a name="MeshFem-basic_dof_from_cvid"><strong>basic_dof_from_cvid</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;the&nbsp;degrees&nbsp;of&nbsp;freedom&nbsp;attached&nbsp;to&nbsp;each&nbsp;convex&nbsp;of&nbsp;the&nbsp;mesh.<br>
&nbsp;<br>
Synopsis:&nbsp;(DOFs,&nbsp;IDx)&nbsp;=&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-basic_dof_from_cvid">basic_dof_from_cvid</a>([,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
If&nbsp;`CVids`&nbsp;is&nbsp;omitted,&nbsp;all&nbsp;the&nbsp;convexes&nbsp;will&nbsp;be&nbsp;considered&nbsp;(equivalent&nbsp;to<br>
`CVids&nbsp;=&nbsp;1&nbsp;...&nbsp;<a href="#Mesh">Mesh</a>.max_cvid()`).&nbsp;`IDx`&nbsp;is&nbsp;a&nbsp;vector,&nbsp;`length(IDx)&nbsp;=<br>
length(CVids)+1`.&nbsp;`DOFs`&nbsp;is&nbsp;a&nbsp;vector&nbsp;containing&nbsp;the&nbsp;concatenated&nbsp;list&nbsp;of&nbsp;dof<br>
of&nbsp;each&nbsp;convex&nbsp;in&nbsp;`CVids`.&nbsp;Each&nbsp;entry&nbsp;of&nbsp;`IDx`&nbsp;is&nbsp;the&nbsp;position&nbsp;of&nbsp;the<br>
corresponding&nbsp;convex&nbsp;point&nbsp;list&nbsp;in&nbsp;`DOFs`.&nbsp;Hence,&nbsp;for&nbsp;example,&nbsp;the&nbsp;list&nbsp;of<br>
points&nbsp;of&nbsp;the&nbsp;second&nbsp;convex&nbsp;is&nbsp;DOFs[IDx(2):IDx(3)].&nbsp;If&nbsp;`CVids`&nbsp;contains<br>
convex&nbsp;#id&nbsp;which&nbsp;do&nbsp;not&nbsp;exist&nbsp;in&nbsp;the&nbsp;mesh,&nbsp;their&nbsp;point&nbsp;list&nbsp;will&nbsp;be&nbsp;empty.</tt></dd></dl>

<dl><dt><a name="MeshFem-basic_dof_nodes"><strong>basic_dof_nodes</strong></a>(self, DOFids<font color="#909090">=None</font>)</dt><dd><tt>Get&nbsp;location&nbsp;of&nbsp;basic&nbsp;degrees&nbsp;of&nbsp;freedom.<br>
&nbsp;<br>
Synopsis:&nbsp;DOFpts&nbsp;=&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-basic_dof_nodes">basic_dof_nodes</a>([,&nbsp;mat&nbsp;DOFids])<br>
&nbsp;<br>
Return&nbsp;the&nbsp;list&nbsp;of&nbsp;interpolation&nbsp;points&nbsp;for&nbsp;the&nbsp;specified&nbsp;dof&nbsp;#IDs&nbsp;in&nbsp;`DOFids`<br>
(if&nbsp;`DOFids`&nbsp;is&nbsp;omitted,&nbsp;all&nbsp;basic&nbsp;dof&nbsp;are&nbsp;considered).</tt></dd></dl>

<dl><dt><a name="MeshFem-basic_dof_on_region"><strong>basic_dof_on_region</strong></a>(self, Rs)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;basic&nbsp;dof&nbsp;(before&nbsp;the&nbsp;optional&nbsp;reduction)&nbsp;lying&nbsp;on&nbsp;one&nbsp;of<br>
the&nbsp;mesh&nbsp;regions&nbsp;listed&nbsp;in&nbsp;`Rs`.&nbsp;More&nbsp;precisely,&nbsp;this&nbsp;function&nbsp;returns&nbsp;the<br>
basic&nbsp;dof&nbsp;whose&nbsp;support&nbsp;is&nbsp;non-null&nbsp;on&nbsp;one&nbsp;of&nbsp;regions&nbsp;whose&nbsp;#ids&nbsp;are&nbsp;listed&nbsp;in<br>
`Rs`&nbsp;(note&nbsp;that&nbsp;for&nbsp;boundary&nbsp;regions,&nbsp;some&nbsp;dof&nbsp;nodes&nbsp;may&nbsp;not&nbsp;lie&nbsp;exactly&nbsp;on<br>
the&nbsp;boundary,&nbsp;for&nbsp;example&nbsp;the&nbsp;dof&nbsp;of&nbsp;Pk(n,0)&nbsp;lies&nbsp;on&nbsp;the&nbsp;center&nbsp;of&nbsp;the&nbsp;convex,<br>
but&nbsp;the&nbsp;base&nbsp;function&nbsp;in&nbsp;not&nbsp;null&nbsp;on&nbsp;the&nbsp;convex&nbsp;border).</tt></dd></dl>

<dl><dt><a name="MeshFem-char"><strong>char</strong></a>(self, opt<font color="#909090">=None</font>)</dt><dd><tt>Output&nbsp;a&nbsp;string&nbsp;description&nbsp;of&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-char">char</a>([,&nbsp;string&nbsp;opt])<br>
&nbsp;<br>
By&nbsp;default,&nbsp;it&nbsp;does&nbsp;not&nbsp;include&nbsp;the&nbsp;description&nbsp;of&nbsp;the&nbsp;linked&nbsp;mesh&nbsp;object,<br>
except&nbsp;if&nbsp;`opt`&nbsp;is&nbsp;'with_mesh'.</tt></dd></dl>

<dl><dt><a name="MeshFem-convex_index"><strong>convex_index</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;convexes&nbsp;who&nbsp;have&nbsp;a&nbsp;FEM.</tt></dd></dl>

<dl><dt><a name="MeshFem-dof_from_cv"><strong>dof_from_cv</strong></a>(self, CVids)</dt><dd><tt>Deprecated&nbsp;function.&nbsp;Use&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-basic_dof_from_cv">basic_dof_from_cv</a>()&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="MeshFem-dof_from_cvid"><strong>dof_from_cvid</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Deprecated&nbsp;function.&nbsp;Use&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-basic_dof_from_cvid">basic_dof_from_cvid</a>()&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="MeshFem-dof_from_im"><strong>dof_from_im</strong></a>(self, mim, p<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;a&nbsp;selection&nbsp;of&nbsp;dof&nbsp;who&nbsp;contribute&nbsp;significantly&nbsp;to&nbsp;the&nbsp;mass-matrix&nbsp;that<br>
would&nbsp;be&nbsp;computed&nbsp;with&nbsp;`mf`&nbsp;and&nbsp;the&nbsp;integration&nbsp;method&nbsp;`mim`.&nbsp;`p`&nbsp;represents<br>
the&nbsp;dimension&nbsp;on&nbsp;what&nbsp;the&nbsp;integration&nbsp;method&nbsp;operates&nbsp;(default&nbsp;`p&nbsp;=&nbsp;mesh<br>
dimension`).&nbsp;IMPORTANT:&nbsp;you&nbsp;still&nbsp;have&nbsp;to&nbsp;set&nbsp;a&nbsp;valid&nbsp;integration&nbsp;method&nbsp;on<br>
the&nbsp;convexes&nbsp;which&nbsp;are&nbsp;not&nbsp;crosses&nbsp;by&nbsp;the&nbsp;levelset!</tt></dd></dl>

<dl><dt><a name="MeshFem-dof_nodes"><strong>dof_nodes</strong></a>(self, DOFids<font color="#909090">=None</font>)</dt><dd><tt>Deprecated&nbsp;function.&nbsp;Use&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-basic_dof_nodes">basic_dof_nodes</a>()&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="MeshFem-dof_on_region"><strong>dof_on_region</strong></a>(self, Rs)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;dof&nbsp;(after&nbsp;the&nbsp;optional&nbsp;reduction)&nbsp;lying&nbsp;on&nbsp;one&nbsp;of&nbsp;the&nbsp;mesh<br>
regions&nbsp;listed&nbsp;in&nbsp;`Rs`.&nbsp;More&nbsp;precisely,&nbsp;this&nbsp;function&nbsp;returns&nbsp;the&nbsp;basic&nbsp;dof<br>
whose&nbsp;support&nbsp;is&nbsp;non-null&nbsp;on&nbsp;one&nbsp;of&nbsp;regions&nbsp;whose&nbsp;#ids&nbsp;are&nbsp;listed&nbsp;in&nbsp;`Rs`<br>
(note&nbsp;that&nbsp;for&nbsp;boundary&nbsp;regions,&nbsp;some&nbsp;dof&nbsp;nodes&nbsp;may&nbsp;not&nbsp;lie&nbsp;exactly&nbsp;on&nbsp;the<br>
boundary,&nbsp;for&nbsp;example&nbsp;the&nbsp;dof&nbsp;of&nbsp;Pk(n,0)&nbsp;lies&nbsp;on&nbsp;the&nbsp;center&nbsp;of&nbsp;the&nbsp;convex,&nbsp;but<br>
the&nbsp;base&nbsp;function&nbsp;in&nbsp;not&nbsp;null&nbsp;on&nbsp;the&nbsp;convex&nbsp;border).&nbsp;For&nbsp;a&nbsp;reduced&nbsp;mesh_fem<br>
a&nbsp;dof&nbsp;is&nbsp;lying&nbsp;on&nbsp;a&nbsp;region&nbsp;if&nbsp;its&nbsp;potential&nbsp;corresponding&nbsp;shape&nbsp;function&nbsp;is<br>
nonzero&nbsp;on&nbsp;this&nbsp;region.&nbsp;The&nbsp;extension&nbsp;matrix&nbsp;is&nbsp;used&nbsp;to&nbsp;make&nbsp;the<br>
correspondance&nbsp;between&nbsp;basic&nbsp;and&nbsp;reduced&nbsp;dofs.</tt></dd></dl>

<dl><dt><a name="MeshFem-dof_partition"><strong>dof_partition</strong></a>(self, DOFP)</dt><dd><tt>Change&nbsp;the&nbsp;'dof_partition'&nbsp;array.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-dof_partition">dof_partition</a>(ivec&nbsp;DOFP)<br>
&nbsp;<br>
`DOFP`&nbsp;is&nbsp;a&nbsp;vector&nbsp;holding&nbsp;a&nbsp;integer&nbsp;value&nbsp;for&nbsp;each&nbsp;convex&nbsp;of&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>.&nbsp;See<br>
<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-dof_partition">dof_partition</a>()&nbsp;for&nbsp;a&nbsp;description&nbsp;of&nbsp;"dof&nbsp;partition".</tt></dd></dl>

<dl><dt><a name="MeshFem-eval"><strong>eval</strong></a>(self, expression)</dt><dd><tt>interpolate&nbsp;an&nbsp;expression&nbsp;on&nbsp;the&nbsp;(lagrangian)&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
Examples:<br>
&nbsp;<br>
mf.<a href="#MeshFem-eval">eval</a>('x[0]*x[1]')&nbsp;interpolates&nbsp;the&nbsp;function&nbsp;'x*y'<br>
mf.<a href="#MeshFem-eval">eval</a>('[x[0],x[1]]')&nbsp;interpolates&nbsp;the&nbsp;vector&nbsp;field&nbsp;'[x,y]'</tt></dd></dl>

<dl><dt><a name="MeshFem-export_to_dx"><strong>export_to_dx</strong></a>(self, filename, *args)</dt><dd><tt>Export&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;and&nbsp;some&nbsp;fields&nbsp;to&nbsp;an&nbsp;OpenDX&nbsp;file.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-export_to_dx">export_to_dx</a>(string&nbsp;filename,&nbsp;...['as',&nbsp;string<br>
mesh_name][,'edges']['serie',string&nbsp;serie_name][,'ascii'][,'append'],&nbsp;U,<br>
'name'...)<br>
&nbsp;<br>
This&nbsp;function&nbsp;will&nbsp;fail&nbsp;if&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mixes&nbsp;different&nbsp;convex&nbsp;types&nbsp;(i.e.<br>
quads&nbsp;and&nbsp;triangles),&nbsp;or&nbsp;if&nbsp;OpenDX&nbsp;does&nbsp;not&nbsp;handle&nbsp;a&nbsp;specific&nbsp;element&nbsp;type<br>
(i.e.&nbsp;prism&nbsp;connections&nbsp;are&nbsp;not&nbsp;known&nbsp;by&nbsp;OpenDX).&nbsp;The&nbsp;FEM&nbsp;will&nbsp;be&nbsp;mapped&nbsp;to<br>
order&nbsp;1&nbsp;Pk&nbsp;(or&nbsp;Qk)&nbsp;FEMs.&nbsp;If&nbsp;you&nbsp;need&nbsp;to&nbsp;represent&nbsp;high-order&nbsp;FEMs&nbsp;or&nbsp;high-<br>
order&nbsp;geometric&nbsp;transformations,&nbsp;you&nbsp;should&nbsp;consider&nbsp;<a href="#Slice">Slice</a>.<a href="#MeshFem-export_to_dx">export_to_dx</a>().</tt></dd></dl>

<dl><dt><a name="MeshFem-export_to_pos"><strong>export_to_pos</strong></a>(self, filename, U1<font color="#909090">=None</font>, nameU1<font color="#909090">=None</font>, *args)</dt><dd><tt>Export&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;and&nbsp;some&nbsp;fields&nbsp;to&nbsp;a&nbsp;pos&nbsp;file.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-export_to_pos">export_to_pos</a>(string&nbsp;filename[,&nbsp;mat&nbsp;U1,&nbsp;string&nbsp;nameU1[,&nbsp;mat<br>
U2,&nbsp;string&nbsp;nameU2,...])<br>
&nbsp;<br>
The&nbsp;FEM&nbsp;and&nbsp;geometric&nbsp;transformations&nbsp;will&nbsp;be&nbsp;mapped&nbsp;to&nbsp;order&nbsp;1&nbsp;isoparametric<br>
Pk&nbsp;(or&nbsp;Qk)&nbsp;FEMs&nbsp;(as&nbsp;GMSH&nbsp;does&nbsp;not&nbsp;handle&nbsp;higher&nbsp;order&nbsp;elements).</tt></dd></dl>

<dl><dt><a name="MeshFem-export_to_vtk"><strong>export_to_vtk</strong></a>(self, filename, *args)</dt><dd><tt>Export&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;and&nbsp;some&nbsp;fields&nbsp;to&nbsp;a&nbsp;vtk&nbsp;file.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-export_to_vtk">export_to_vtk</a>(string&nbsp;filename,&nbsp;...&nbsp;['ascii'],&nbsp;U,&nbsp;'name'...)<br>
&nbsp;<br>
The&nbsp;FEM&nbsp;and&nbsp;geometric&nbsp;transformations&nbsp;will&nbsp;be&nbsp;mapped&nbsp;to&nbsp;order&nbsp;1&nbsp;or&nbsp;2<br>
isoparametric&nbsp;Pk&nbsp;(or&nbsp;Qk)&nbsp;FEMs&nbsp;(as&nbsp;VTK&nbsp;does&nbsp;not&nbsp;handle&nbsp;higher&nbsp;order&nbsp;elements).<br>
If&nbsp;you&nbsp;need&nbsp;to&nbsp;represent&nbsp;high-order&nbsp;FEMs&nbsp;or&nbsp;high-order&nbsp;geometric<br>
transformations,&nbsp;you&nbsp;should&nbsp;consider&nbsp;<a href="#Slice">Slice</a>.<a href="#MeshFem-export_to_vtk">export_to_vtk</a>().</tt></dd></dl>

<dl><dt><a name="MeshFem-extension_matrix"><strong>extension_matrix</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;optional&nbsp;extension&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="MeshFem-fem"><strong>fem</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;FEM&nbsp;used&nbsp;by&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;(FEMs,&nbsp;CV2F)&nbsp;=&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-fem">fem</a>([,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
`FEMs`&nbsp;is&nbsp;an&nbsp;array&nbsp;of&nbsp;all&nbsp;<a href="#Fem">Fem</a>&nbsp;objects&nbsp;found&nbsp;in&nbsp;the&nbsp;convexes&nbsp;given&nbsp;in&nbsp;`CVids`.<br>
If&nbsp;`CV2F`&nbsp;was&nbsp;supplied&nbsp;as&nbsp;an&nbsp;output&nbsp;argument,&nbsp;it&nbsp;contains,&nbsp;for&nbsp;each&nbsp;convex<br>
listed&nbsp;in&nbsp;`CVids`,&nbsp;the&nbsp;index&nbsp;of&nbsp;its&nbsp;correspounding&nbsp;FEM&nbsp;in&nbsp;`FEMs`.&nbsp;Convexes<br>
which&nbsp;are&nbsp;not&nbsp;part&nbsp;of&nbsp;the&nbsp;mesh,&nbsp;or&nbsp;convexes&nbsp;which&nbsp;do&nbsp;not&nbsp;have&nbsp;any&nbsp;FEM&nbsp;have<br>
their&nbsp;correspounding&nbsp;entry&nbsp;in&nbsp;`CV2F`&nbsp;set&nbsp;to&nbsp;-1.</tt></dd></dl>

<dl><dt><a name="MeshFem-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="MeshFem-has_linked_mesh_levelset"><strong>has_linked_mesh_levelset</strong></a>(self)</dt><dd><tt>???.</tt></dd></dl>

<dl><dt><a name="MeshFem-interpolate_convex_data"><strong>interpolate_convex_data</strong></a>(self, Ucv)</dt><dd><tt>Interpolate&nbsp;data&nbsp;given&nbsp;on&nbsp;each&nbsp;convex&nbsp;of&nbsp;the&nbsp;mesh&nbsp;to&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;dof.&nbsp;The<br>
<a href="#MeshFem">MeshFem</a>&nbsp;has&nbsp;to&nbsp;be&nbsp;lagrangian,&nbsp;and&nbsp;should&nbsp;be&nbsp;discontinuous&nbsp;(typically&nbsp;a<br>
FEM_PK(N,0)&nbsp;or&nbsp;FEM_QK(N,0)&nbsp;should&nbsp;be&nbsp;used).&nbsp;The&nbsp;last&nbsp;dimension&nbsp;of&nbsp;the&nbsp;input<br>
vector&nbsp;Ucv&nbsp;should&nbsp;have&nbsp;<a href="#Mesh">Mesh</a>.max_cvid()&nbsp;elements.&nbsp;Example&nbsp;of&nbsp;use:<br>
<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-interpolate_convex_data">interpolate_convex_data</a>(&nbsp;<a href="#Mesh">Mesh</a>.quality())</tt></dd></dl>

<dl><dt><a name="MeshFem-is_equivalent"><strong>is_equivalent</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Test&nbsp;if&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;is&nbsp;equivalent.<br>
&nbsp;<br>
Synopsis:&nbsp;bB&nbsp;=&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-is_equivalent">is_equivalent</a>([,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
See&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-is_lagrangian">is_lagrangian</a>()</tt></dd></dl>

<dl><dt><a name="MeshFem-is_lagrangian"><strong>is_lagrangian</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Test&nbsp;if&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;is&nbsp;Lagrangian.<br>
&nbsp;<br>
Synopsis:&nbsp;bB&nbsp;=&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-is_lagrangian">is_lagrangian</a>([,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
Lagrangian&nbsp;means&nbsp;that&nbsp;each&nbsp;base&nbsp;function&nbsp;Phi[i]&nbsp;is&nbsp;such&nbsp;that&nbsp;Phi[i](P[j])&nbsp;=<br>
delta(i,j),&nbsp;where&nbsp;P[j]&nbsp;is&nbsp;the&nbsp;dof&nbsp;location&nbsp;of&nbsp;the&nbsp;jth&nbsp;base&nbsp;function,&nbsp;and<br>
delta(i,j)&nbsp;=&nbsp;1&nbsp;if&nbsp;i==j,&nbsp;else&nbsp;0.<br>
&nbsp;<br>
If&nbsp;`CVids`&nbsp;is&nbsp;omitted,&nbsp;it&nbsp;returns&nbsp;1&nbsp;if&nbsp;all&nbsp;convexes&nbsp;in&nbsp;the&nbsp;mesh&nbsp;are<br>
Lagrangian.&nbsp;If&nbsp;`CVids`&nbsp;is&nbsp;used,&nbsp;it&nbsp;returns&nbsp;the&nbsp;convex&nbsp;indices&nbsp;(with&nbsp;respect&nbsp;to<br>
`CVids`)&nbsp;which&nbsp;are&nbsp;Lagrangian.</tt></dd></dl>

<dl><dt><a name="MeshFem-is_polynomial"><strong>is_polynomial</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Test&nbsp;if&nbsp;all&nbsp;base&nbsp;functions&nbsp;are&nbsp;polynomials.<br>
&nbsp;<br>
Synopsis:&nbsp;bB&nbsp;=&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-is_polynomial">is_polynomial</a>([,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
See&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-is_lagrangian">is_lagrangian</a>()</tt></dd></dl>

<dl><dt><a name="MeshFem-is_reduced"><strong>is_reduced</strong></a>(self)</dt><dd><tt>Return&nbsp;1&nbsp;if&nbsp;the&nbsp;optional&nbsp;reduction&nbsp;matrix&nbsp;is&nbsp;applied&nbsp;to&nbsp;the&nbsp;dofs.</tt></dd></dl>

<dl><dt><a name="MeshFem-linked_mesh"><strong>linked_mesh</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;<a href="#Mesh">Mesh</a>&nbsp;object&nbsp;linked&nbsp;to&nbsp;`mf`.</tt></dd></dl>

<dl><dt><a name="MeshFem-linked_mesh_levelset"><strong>linked_mesh_levelset</strong></a>(self)</dt><dd><tt>???</tt></dd></dl>

<dl><dt><a name="MeshFem-memsize"><strong>memsize</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;(in&nbsp;bytes)&nbsp;used&nbsp;by&nbsp;the&nbsp;mesh_fem&nbsp;object.<br>
&nbsp;<br>
Synopsis:&nbsp;z&nbsp;=&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-memsize">memsize</a>()<br>
&nbsp;<br>
The&nbsp;result&nbsp;does&nbsp;not&nbsp;take&nbsp;into&nbsp;account&nbsp;the&nbsp;linked&nbsp;mesh&nbsp;object.</tt></dd></dl>

<dl><dt><a name="MeshFem-nb_basic_dof"><strong>nb_basic_dof</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;number&nbsp;of&nbsp;basic&nbsp;degrees&nbsp;of&nbsp;freedom&nbsp;(dof)&nbsp;of&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>.</tt></dd></dl>

<dl><dt><a name="MeshFem-nbdof"><strong>nbdof</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;number&nbsp;of&nbsp;degrees&nbsp;of&nbsp;freedom&nbsp;(dof)&nbsp;of&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>.</tt></dd></dl>

<dl><dt><a name="MeshFem-non_conformal_basic_dof"><strong>non_conformal_basic_dof</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;partially&nbsp;linked&nbsp;degrees&nbsp;of&nbsp;freedom.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-non_conformal_basic_dof">non_conformal_basic_dof</a>([,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
Return&nbsp;the&nbsp;basic&nbsp;dof&nbsp;located&nbsp;on&nbsp;the&nbsp;border&nbsp;of&nbsp;a&nbsp;convex&nbsp;and&nbsp;which&nbsp;belong&nbsp;to<br>
only&nbsp;one&nbsp;convex,&nbsp;except&nbsp;the&nbsp;ones&nbsp;which&nbsp;are&nbsp;located&nbsp;on&nbsp;the&nbsp;border&nbsp;of&nbsp;the&nbsp;mesh.<br>
For&nbsp;example,&nbsp;if&nbsp;the&nbsp;convex&nbsp;'a'&nbsp;and&nbsp;'b'&nbsp;share&nbsp;a&nbsp;common&nbsp;face,&nbsp;'a'&nbsp;has&nbsp;a&nbsp;P1&nbsp;FEM,<br>
and&nbsp;'b'&nbsp;has&nbsp;a&nbsp;P2&nbsp;FEM,&nbsp;then&nbsp;the&nbsp;basic&nbsp;dof&nbsp;on&nbsp;the&nbsp;middle&nbsp;of&nbsp;the&nbsp;face&nbsp;will&nbsp;be<br>
returned&nbsp;by&nbsp;this&nbsp;function&nbsp;(this&nbsp;can&nbsp;be&nbsp;useful&nbsp;when&nbsp;searching&nbsp;the&nbsp;interfaces<br>
between&nbsp;classical&nbsp;FEM&nbsp;and&nbsp;hierarchical&nbsp;FEM).</tt></dd></dl>

<dl><dt><a name="MeshFem-non_conformal_dof"><strong>non_conformal_dof</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Deprecated&nbsp;function.&nbsp;Use&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-non_conformal_basic_dof">non_conformal_basic_dof</a>()&nbsp;instead.</tt></dd></dl>

<dl><dt><a name="MeshFem-qdim"><strong>qdim</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;dimension&nbsp;Q&nbsp;of&nbsp;the&nbsp;field&nbsp;interpolated&nbsp;by&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-qdim">qdim</a>()<br>
&nbsp;<br>
By&nbsp;default,&nbsp;Q=1&nbsp;(scalar&nbsp;field).&nbsp;This&nbsp;has&nbsp;an&nbsp;impact&nbsp;on&nbsp;the&nbsp;dof&nbsp;numbering.</tt></dd></dl>

<dl><dt><a name="MeshFem-reduction"><strong>reduction</strong></a>(self, s)</dt><dd><tt>Set&nbsp;or&nbsp;unset&nbsp;the&nbsp;use&nbsp;of&nbsp;the&nbsp;reduction/extension&nbsp;matrices.</tt></dd></dl>

<dl><dt><a name="MeshFem-reduction_matrices"><strong>reduction_matrices</strong></a>(self, R, E)</dt><dd><tt>Set&nbsp;the&nbsp;reduction&nbsp;and&nbsp;extension&nbsp;matrices&nbsp;and&nbsp;valid&nbsp;their&nbsp;use.</tt></dd></dl>

<dl><dt><a name="MeshFem-reduction_matrix"><strong>reduction_matrix</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;optional&nbsp;reduction&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="MeshFem-save"><strong>save</strong></a>(self, filename, opt<font color="#909090">=None</font>)</dt><dd><tt>Save&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;in&nbsp;a&nbsp;text&nbsp;file&nbsp;(and&nbsp;optionaly&nbsp;its&nbsp;linked&nbsp;mesh&nbsp;object&nbsp;if&nbsp;`opt`<br>
is&nbsp;the&nbsp;string&nbsp;'with_mesh').</tt></dd></dl>

<dl><dt><a name="MeshFem-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="MeshFem-set_classical_discontinuous_fem"><strong>set_classical_discontinuous_fem</strong></a>(self, K, IM_DEGREE<font color="#909090">=None</font>, *args)</dt><dd><tt>Assigns&nbsp;a&nbsp;classical&nbsp;(Lagrange&nbsp;polynomial)&nbsp;discontinuous&nbsp;fem&nbsp;or&nbsp;order&nbsp;K.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-set_classical_discontinuous_fem">set_classical_discontinuous_fem</a>(int&nbsp;K,&nbsp;[int&nbsp;IM_DEGREE&nbsp;[,ivec<br>
CVIDX]])<br>
&nbsp;<br>
Similar&nbsp;to&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-set_classical_fem">set_classical_fem</a>()&nbsp;except&nbsp;that&nbsp;FEM_PK_DISCONTINUOUS&nbsp;is<br>
used.</tt></dd></dl>

<dl><dt><a name="MeshFem-set_classical_fem"><strong>set_classical_fem</strong></a>(self, k, CVids<font color="#909090">=None</font>)</dt><dd><tt>Assign&nbsp;a&nbsp;classical&nbsp;(Lagrange&nbsp;polynomial)&nbsp;fem&nbsp;of&nbsp;order&nbsp;`k`&nbsp;to&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-set_classical_fem">set_classical_fem</a>(int&nbsp;k[,&nbsp;ivec&nbsp;CVids])<br>
&nbsp;<br>
Uses&nbsp;FEM_PK&nbsp;for&nbsp;simplexes,&nbsp;FEM_QK&nbsp;for&nbsp;parallelepipeds&nbsp;etc.</tt></dd></dl>

<dl><dt><a name="MeshFem-set_fem"><strong>set_fem</strong></a>(self, f, CVids<font color="#909090">=None</font>)</dt><dd><tt>Set&nbsp;the&nbsp;Finite&nbsp;Element&nbsp;Method.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-set_fem">set_fem</a>(<a href="#Fem">Fem</a>&nbsp;f[,&nbsp;ivec&nbsp;CVids])<br>
&nbsp;<br>
Assign&nbsp;a&nbsp;FEM&nbsp;`f`&nbsp;to&nbsp;all&nbsp;convexes&nbsp;whose&nbsp;#ids&nbsp;are&nbsp;listed&nbsp;in&nbsp;`CVids`.&nbsp;If&nbsp;`CVids`<br>
is&nbsp;not&nbsp;given,&nbsp;the&nbsp;integration&nbsp;is&nbsp;assigned&nbsp;to&nbsp;all&nbsp;convexes.&nbsp;See&nbsp;the&nbsp;help&nbsp;of<br>
<a href="#Fem">Fem</a>&nbsp;to&nbsp;obtain&nbsp;a&nbsp;list&nbsp;of&nbsp;available&nbsp;FEM&nbsp;methods.</tt></dd></dl>

<dl><dt><a name="MeshFem-set_qdim"><strong>set_qdim</strong></a>(self, Q)</dt><dd><tt>Change&nbsp;the&nbsp;`Q`&nbsp;dimension&nbsp;of&nbsp;the&nbsp;field&nbsp;that&nbsp;is&nbsp;interpolated&nbsp;by&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshFem">MeshFem</a>.<a href="#MeshFem-set_qdim">set_qdim</a>(int&nbsp;Q)<br>
&nbsp;<br>
`Q&nbsp;=&nbsp;1`&nbsp;means&nbsp;that&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;describes&nbsp;a&nbsp;scalar&nbsp;field,&nbsp;`Q&nbsp;=&nbsp;N`&nbsp;means&nbsp;that<br>
the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;describes&nbsp;a&nbsp;vector&nbsp;field&nbsp;of&nbsp;dimension&nbsp;N.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="MeshIm">class <strong>MeshIm</strong></a></font></td></tr>
    
<tr><td bgcolor="#ffc8d8"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="MeshIm-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="MeshIm-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;objects.<br>
&nbsp;<br>
*&nbsp;<a href="#MeshIm">MeshIm</a>('load',&nbsp;string&nbsp;fname[,&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m])<br>
&nbsp;&nbsp;Load&nbsp;a&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;from&nbsp;a&nbsp;file.&nbsp;If&nbsp;the&nbsp;mesh&nbsp;`m`&nbsp;is&nbsp;not&nbsp;supplied&nbsp;(this&nbsp;kind&nbsp;of<br>
&nbsp;&nbsp;file&nbsp;does&nbsp;not&nbsp;store&nbsp;the&nbsp;mesh),&nbsp;then&nbsp;it&nbsp;is&nbsp;read&nbsp;from&nbsp;the&nbsp;file&nbsp;and&nbsp;its<br>
&nbsp;&nbsp;descriptor&nbsp;is&nbsp;returned&nbsp;as&nbsp;the&nbsp;second&nbsp;output&nbsp;argument.<br>
*&nbsp;<a href="#MeshIm">MeshIm</a>('from_string',&nbsp;string&nbsp;s[,&nbsp;mesh&nbsp;M])<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;object&nbsp;from&nbsp;its&nbsp;string&nbsp;description.&nbsp;See&nbsp;also&nbsp;<a href="#MeshIm">MeshIm</a>.<a href="#MeshIm-char">char</a>()<br>
*&nbsp;<a href="#MeshIm">MeshIm</a>('clone',&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim2)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;copy&nbsp;of&nbsp;a&nbsp;<a href="#MeshIm">MeshIm</a>.<br>
*&nbsp;<a href="#MeshIm">MeshIm</a>('levelset',&nbsp;<a href="#LevelSet">LevelSet</a>&nbsp;ls,&nbsp;string&nbsp;where,&nbsp;<a href="#Integ">Integ</a>&nbsp;im[,&nbsp;<a href="#Integ">Integ</a>&nbsp;im_tip])<br>
&nbsp;&nbsp;Build&nbsp;an&nbsp;integration&nbsp;method&nbsp;conformal&nbsp;to&nbsp;a&nbsp;partition&nbsp;defined&nbsp;implicitely&nbsp;by<br>
&nbsp;&nbsp;a&nbsp;levelset.&nbsp;The&nbsp;`where`&nbsp;argument&nbsp;define&nbsp;the&nbsp;domain&nbsp;of&nbsp;integration&nbsp;with<br>
&nbsp;&nbsp;respect&nbsp;to&nbsp;the&nbsp;levelset,&nbsp;it&nbsp;has&nbsp;to&nbsp;be&nbsp;chosen&nbsp;among&nbsp;'ALL',&nbsp;'INSIDE',<br>
&nbsp;&nbsp;'OUTSIDE'&nbsp;and&nbsp;'BOUNDARY'.<br>
*&nbsp;<a href="#MeshIm">MeshIm</a>(<a href="#Mesh">Mesh</a>&nbsp;m,&nbsp;[{<a href="#Integ">Integ</a>&nbsp;im|int&nbsp;im_degree}])<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;new&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;object.&nbsp;For&nbsp;convenience,&nbsp;optional&nbsp;arguments&nbsp;(`im`&nbsp;or<br>
&nbsp;&nbsp;`im_degree`)&nbsp;can&nbsp;be&nbsp;provided,&nbsp;in&nbsp;that&nbsp;case&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#MeshIm">MeshIm</a>.<a href="#MeshIm-integ">integ</a>()&nbsp;is<br>
&nbsp;&nbsp;issued&nbsp;with&nbsp;these&nbsp;arguments.</tt></dd></dl>

<dl><dt><a name="MeshIm-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="MeshIm-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="MeshIm-char"><strong>char</strong></a>(self)</dt><dd><tt>Output&nbsp;a&nbsp;string&nbsp;description&nbsp;of&nbsp;the&nbsp;<a href="#MeshIm">MeshIm</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshIm">MeshIm</a>.<a href="#MeshIm-char">char</a>([,'with&nbsp;mesh'])<br>
&nbsp;<br>
By&nbsp;default,&nbsp;it&nbsp;does&nbsp;not&nbsp;include&nbsp;the&nbsp;description&nbsp;of&nbsp;the&nbsp;linked&nbsp;<a href="#Mesh">Mesh</a>&nbsp;object.</tt></dd></dl>

<dl><dt><a name="MeshIm-convex_index"><strong>convex_index</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;convexes&nbsp;who&nbsp;have&nbsp;a&nbsp;FEM.</tt></dd></dl>

<dl><dt><a name="MeshIm-eltm"><strong>eltm</strong></a>(self, em, cv, f<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;the&nbsp;elementary&nbsp;matrix&nbsp;(or&nbsp;tensor)&nbsp;integrated&nbsp;on&nbsp;the&nbsp;convex&nbsp;`cv`.<br>
&nbsp;<br>
Synopsis:&nbsp;M&nbsp;=&nbsp;<a href="#MeshIm">MeshIm</a>.<a href="#MeshIm-eltm">eltm</a>(<a href="#Eltm">Eltm</a>&nbsp;em,&nbsp;int&nbsp;cv&nbsp;[int&nbsp;f])<br>
&nbsp;<br>
**WARNING**&nbsp;Be&nbsp;sure&nbsp;that&nbsp;the&nbsp;fem&nbsp;used&nbsp;for&nbsp;the&nbsp;construction&nbsp;of&nbsp;`em`&nbsp;is<br>
compatible&nbsp;with&nbsp;the&nbsp;fem&nbsp;assigned&nbsp;to&nbsp;element&nbsp;`cv`&nbsp;!&nbsp;This&nbsp;is&nbsp;not&nbsp;checked&nbsp;by&nbsp;the<br>
function&nbsp;!&nbsp;If&nbsp;the&nbsp;argument&nbsp;`f`&nbsp;is&nbsp;given,&nbsp;then&nbsp;the&nbsp;elementary&nbsp;tensor&nbsp;is<br>
integrated&nbsp;on&nbsp;the&nbsp;face&nbsp;`f`&nbsp;of&nbsp;`cv`&nbsp;instead&nbsp;of&nbsp;the&nbsp;whole&nbsp;convex.</tt></dd></dl>

<dl><dt><a name="MeshIm-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="MeshIm-im_nodes"><strong>im_nodes</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;the&nbsp;coordinates&nbsp;of&nbsp;the&nbsp;integration&nbsp;points,&nbsp;with&nbsp;their&nbsp;weights.<br>
&nbsp;<br>
Synopsis:&nbsp;Ip&nbsp;=&nbsp;<a href="#MeshIm">MeshIm</a>.<a href="#MeshIm-im_nodes">im_nodes</a>([,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
`CVids`&nbsp;may&nbsp;be&nbsp;a&nbsp;list&nbsp;of&nbsp;convexes,&nbsp;or&nbsp;a&nbsp;list&nbsp;of&nbsp;convex&nbsp;faces,&nbsp;such&nbsp;as&nbsp;returned<br>
by&nbsp;<a href="#Mesh">Mesh</a>.region()</tt></dd></dl>

<dl><dt><a name="MeshIm-integ"><strong>integ</strong></a>(self, CVids<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;a&nbsp;list&nbsp;of&nbsp;integration&nbsp;methods&nbsp;used&nbsp;by&nbsp;the&nbsp;<a href="#MeshIm">MeshIm</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;(I,&nbsp;CV2I)&nbsp;=&nbsp;<a href="#MeshIm">MeshIm</a>.<a href="#MeshIm-integ">integ</a>([,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
`I`&nbsp;is&nbsp;an&nbsp;array&nbsp;of&nbsp;all&nbsp;<a href="#Integ">Integ</a>&nbsp;objects&nbsp;found&nbsp;in&nbsp;the&nbsp;convexes&nbsp;given&nbsp;in&nbsp;`CVids`.<br>
If&nbsp;`CV2I`&nbsp;was&nbsp;supplied&nbsp;as&nbsp;an&nbsp;output&nbsp;argument,&nbsp;it&nbsp;contains,&nbsp;for&nbsp;each&nbsp;convex<br>
listed&nbsp;in&nbsp;`CVids`,&nbsp;the&nbsp;index&nbsp;of&nbsp;its&nbsp;correspounding&nbsp;integration&nbsp;method&nbsp;in&nbsp;`I`.<br>
Convexes&nbsp;which&nbsp;are&nbsp;not&nbsp;part&nbsp;of&nbsp;the&nbsp;mesh,&nbsp;or&nbsp;convexes&nbsp;which&nbsp;do&nbsp;not&nbsp;have&nbsp;any<br>
integration&nbsp;method&nbsp;have&nbsp;their&nbsp;correspounding&nbsp;entry&nbsp;in&nbsp;`CV2I`&nbsp;set&nbsp;to&nbsp;-1.</tt></dd></dl>

<dl><dt><a name="MeshIm-linked_mesh"><strong>linked_mesh</strong></a>(self)</dt><dd><tt>Returns&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;<a href="#Mesh">Mesh</a>&nbsp;object&nbsp;linked&nbsp;to&nbsp;`mim`.</tt></dd></dl>

<dl><dt><a name="MeshIm-memsize"><strong>memsize</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;(in&nbsp;bytes)&nbsp;used&nbsp;by&nbsp;the&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;object.<br>
&nbsp;<br>
Synopsis:&nbsp;z&nbsp;=&nbsp;<a href="#MeshIm">MeshIm</a>.<a href="#MeshIm-memsize">memsize</a>()<br>
&nbsp;<br>
The&nbsp;result&nbsp;does&nbsp;not&nbsp;take&nbsp;into&nbsp;account&nbsp;the&nbsp;linked&nbsp;<a href="#Mesh">Mesh</a>&nbsp;object.</tt></dd></dl>

<dl><dt><a name="MeshIm-save"><strong>save</strong></a>(self, filename)</dt><dd><tt>Saves&nbsp;a&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;in&nbsp;a&nbsp;text&nbsp;file&nbsp;(and&nbsp;optionaly&nbsp;its&nbsp;linked&nbsp;mesh&nbsp;object).</tt></dd></dl>

<dl><dt><a name="MeshIm-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="MeshIm-set_integ"><strong>set_integ</strong></a>(self, *args)</dt><dd><tt>Set&nbsp;the&nbsp;integration&nbsp;method.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#MeshIm">MeshIm</a>.<a href="#MeshIm-set_integ">set_integ</a>({<a href="#Integ">Integ</a>&nbsp;im|int&nbsp;im_degree}[,&nbsp;ivec&nbsp;CVids])<br>
&nbsp;<br>
Assign&nbsp;an&nbsp;integration&nbsp;method&nbsp;to&nbsp;all&nbsp;convexes&nbsp;whose&nbsp;#ids&nbsp;are&nbsp;listed&nbsp;in&nbsp;`CVids`.<br>
If&nbsp;`CVids`&nbsp;is&nbsp;not&nbsp;given,&nbsp;the&nbsp;integration&nbsp;is&nbsp;assigned&nbsp;to&nbsp;all&nbsp;convexes.&nbsp;It&nbsp;is<br>
possible&nbsp;to&nbsp;assign&nbsp;a&nbsp;specific&nbsp;integration&nbsp;method&nbsp;with&nbsp;an&nbsp;integration&nbsp;method<br>
handle&nbsp;`im`&nbsp;obtained&nbsp;via&nbsp;<a href="#Integ">Integ</a>('IM_SOMETHING'),&nbsp;or&nbsp;to&nbsp;let&nbsp;getfem&nbsp;choose&nbsp;a<br>
suitable&nbsp;integration&nbsp;method&nbsp;with&nbsp;`im_degree`&nbsp;(choosen&nbsp;such&nbsp;that&nbsp;polynomials&nbsp;of<br>
`degree&nbsp;&lt;=&nbsp;im_degree`&nbsp;are&nbsp;exactly&nbsp;integrated.&nbsp;If&nbsp;`im_degree=-1`,&nbsp;then&nbsp;the<br>
dummy&nbsp;integration&nbsp;method&nbsp;IM_NONE&nbsp;will&nbsp;be&nbsp;used.)</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Model">class <strong>Model</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Getfem&nbsp;<a href="#Model">Model</a>&nbsp;Object.<br>
&nbsp;<br>
A&nbsp;model&nbsp;is&nbsp;an&nbsp;object&nbsp;which&nbsp;store&nbsp;all&nbsp;the&nbsp;state&nbsp;variable&nbsp;and&nbsp;the&nbsp;data&nbsp;of&nbsp;a<br>
model&nbsp;and&nbsp;a&nbsp;list&nbsp;of&nbsp;bricks.&nbsp;A&nbsp;brick&nbsp;is&nbsp;a&nbsp;component&nbsp;of&nbsp;the&nbsp;model,&nbsp;i.e.&nbsp;a<br>
term&nbsp;wich&nbsp;link&nbsp;some&nbsp;state&nbsp;variables.&nbsp;The&nbsp;model&nbsp;object&nbsp;&nbsp;includes&nbsp;the&nbsp;global<br>
tangent&nbsp;matrix,&nbsp;the&nbsp;right&nbsp;hand&nbsp;side&nbsp;and&nbsp;the&nbsp;constraints.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Model-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="Model-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;<a href="#Model">Model</a>&nbsp;objects.<br>
There&nbsp;are&nbsp;two&nbsp;sorts&nbsp;of&nbsp;model&nbsp;states,&nbsp;the&nbsp;'real'&nbsp;and&nbsp;the&nbsp;'complex'<br>
model&nbsp;states.<br>
&nbsp;<br>
*&nbsp;MDS&nbsp;=&nbsp;<a href="#Model">Model</a>('real')<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;model&nbsp;for&nbsp;real&nbsp;unknowns.<br>
*&nbsp;MDS&nbsp;=&nbsp;<a href="#Model">Model</a>('complex')<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;model&nbsp;for&nbsp;complex&nbsp;unknowns.</tt></dd></dl>

<dl><dt><a name="Model-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Model-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Model-add_data"><strong>add_data</strong></a>(self, name, size, niter<font color="#909090">=None</font>)</dt><dd><tt>Add&nbsp;a&nbsp;data&nbsp;to&nbsp;the&nbsp;model&nbsp;of&nbsp;constant&nbsp;size.&nbsp;`name`&nbsp;is&nbsp;the&nbsp;data&nbsp;name&nbsp;and&nbsp;`niter`<br>
is&nbsp;the&nbsp;optional&nbsp;number&nbsp;of&nbsp;copy&nbsp;of&nbsp;the&nbsp;data&nbsp;for&nbsp;time&nbsp;integration&nbsp;schemes.</tt></dd></dl>

<dl><dt><a name="Model-add_fem_data"><strong>add_fem_data</strong></a>(self, name, mf, qdim<font color="#909090">=None</font>, niter<font color="#909090">=None</font>)</dt><dd><tt>Add&nbsp;a&nbsp;data&nbsp;to&nbsp;the&nbsp;model&nbsp;linked&nbsp;to&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>.&nbsp;`name`&nbsp;is&nbsp;the&nbsp;data&nbsp;name,&nbsp;`qdim`<br>
is&nbsp;the&nbsp;optional&nbsp;dimension&nbsp;of&nbsp;the&nbsp;data&nbsp;over&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;and&nbsp;`niter`&nbsp;is&nbsp;the<br>
optional&nbsp;number&nbsp;of&nbsp;copy&nbsp;of&nbsp;the&nbsp;data&nbsp;for&nbsp;time&nbsp;integration&nbsp;schemes.</tt></dd></dl>

<dl><dt><a name="Model-add_fem_variable"><strong>add_fem_variable</strong></a>(self, name, mf, niter<font color="#909090">=None</font>)</dt><dd><tt>Add&nbsp;a&nbsp;variable&nbsp;to&nbsp;the&nbsp;model&nbsp;linked&nbsp;to&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>.&nbsp;`name`&nbsp;is&nbsp;the&nbsp;variable&nbsp;name<br>
and&nbsp;`niter`&nbsp;is&nbsp;the&nbsp;optional&nbsp;number&nbsp;of&nbsp;copy&nbsp;of&nbsp;the&nbsp;variable&nbsp;for&nbsp;time<br>
integration&nbsp;schemes.</tt></dd></dl>

<dl><dt><a name="Model-add_variable"><strong>add_variable</strong></a>(self, name, size, niter<font color="#909090">=None</font>)</dt><dd><tt>Add&nbsp;a&nbsp;variable&nbsp;to&nbsp;the&nbsp;model&nbsp;of&nbsp;constant&nbsp;size.&nbsp;`name`&nbsp;is&nbsp;the&nbsp;variable&nbsp;name&nbsp;and<br>
`niter`&nbsp;is&nbsp;the&nbsp;optional&nbsp;number&nbsp;of&nbsp;copy&nbsp;of&nbsp;the&nbsp;variable&nbsp;for&nbsp;time&nbsp;integration<br>
schemes.</tt></dd></dl>

<dl><dt><a name="Model-clear"><strong>clear</strong></a>(self)</dt><dd><tt>Clear&nbsp;the&nbsp;model.</tt></dd></dl>

<dl><dt><a name="Model-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Model-is_complex"><strong>is_complex</strong></a>(self)</dt><dd><tt>Return&nbsp;0&nbsp;is&nbsp;the&nbsp;model&nbsp;is&nbsp;real,&nbsp;1&nbsp;if&nbsp;it&nbsp;is&nbsp;complex.</tt></dd></dl>

<dl><dt><a name="Model-memsize"><strong>memsize</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;rough&nbsp;approximation&nbsp;of&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;(in&nbsp;bytes)&nbsp;used&nbsp;by&nbsp;the<br>
model.</tt></dd></dl>

<dl><dt><a name="Model-rhs"><strong>rhs</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;right&nbsp;hand&nbsp;side&nbsp;of&nbsp;the&nbsp;tangent&nbsp;problem.</tt></dd></dl>

<dl><dt><a name="Model-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Model-set_state"><strong>set_state</strong></a>(self, U)</dt><dd><tt>Update&nbsp;the&nbsp;internal&nbsp;state&nbsp;with&nbsp;the&nbsp;vector&nbsp;`U`.</tt></dd></dl>

<dl><dt><a name="Model-set_variable"><strong>set_variable</strong></a>(self, name, U, niter<font color="#909090">=None</font>)</dt><dd><tt>Set&nbsp;the&nbsp;value&nbsp;of&nbsp;a&nbsp;variable&nbsp;or&nbsp;data.</tt></dd></dl>

<dl><dt><a name="Model-state"><strong>state</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;vector&nbsp;of&nbsp;unknowns,&nbsp;which&nbsp;contains&nbsp;the&nbsp;solution&nbsp;after&nbsp;a&nbsp;solve.</tt></dd></dl>

<dl><dt><a name="Model-tangent_matrix"><strong>tangent_matrix</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;tangent&nbsp;matrix&nbsp;stored&nbsp;in&nbsp;the&nbsp;model&nbsp;.</tt></dd></dl>

<dl><dt><a name="Model-variable"><strong>variable</strong></a>(self, name, niter<font color="#909090">=None</font>)</dt><dd><tt>Gives&nbsp;the&nbsp;value&nbsp;of&nbsp;a&nbsp;variable&nbsp;or&nbsp;data.</tt></dd></dl>

<dl><dt><a name="Model-varlist"><strong>varlist</strong></a>(self)</dt><dd><tt>print&nbsp;to&nbsp;the&nbsp;output&nbsp;the&nbsp;list&nbsp;of&nbsp;variables&nbsp;and&nbsp;constants&nbsp;of&nbsp;the&nbsp;model.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Poly">class <strong>Poly</strong></a></font></td></tr>
    
<tr><td bgcolor="#ffc8d8"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"></td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Precond">class <strong>Precond</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Getfem&nbsp;preconditioner.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Precond-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="Precond-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;getfem&nbsp;preconditioners.<br>
&nbsp;<br>
The&nbsp;preconditioners&nbsp;may&nbsp;store&nbsp;REAL&nbsp;or&nbsp;COMPLEX&nbsp;values.&nbsp;They&nbsp;accept<br>
getfem&nbsp;sparse&nbsp;matrices&nbsp;and&nbsp;Matlab&nbsp;sparse&nbsp;matrices.<br>
&nbsp;<br>
*&nbsp;<a href="#Precond">Precond</a>('identity')<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;REAL&nbsp;identity&nbsp;precondioner.<br>
*&nbsp;<a href="#Precond">Precond</a>('cidentity')<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;COMPLEX&nbsp;identity&nbsp;precondioner.<br>
*&nbsp;<a href="#Precond">Precond</a>('diagonal',&nbsp;vec&nbsp;D)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;diagonal&nbsp;precondioner.<br>
*&nbsp;<a href="#Precond">Precond</a>('ildlt',&nbsp;<a href="#Spmat">Spmat</a>&nbsp;m)<br>
&nbsp;&nbsp;Create&nbsp;an&nbsp;ILDLT&nbsp;(Cholesky)&nbsp;preconditioner&nbsp;for&nbsp;the&nbsp;(symmetric)<br>
&nbsp;&nbsp;sparse&nbsp;matrix&nbsp;`m`.&nbsp;This&nbsp;preconditioner&nbsp;has&nbsp;the&nbsp;same&nbsp;sparsity<br>
&nbsp;&nbsp;pattern&nbsp;than&nbsp;`m`&nbsp;(no&nbsp;fill-in).<br>
*&nbsp;<a href="#Precond">Precond</a>('ilu',&nbsp;<a href="#Spmat">Spmat</a>&nbsp;m)<br>
&nbsp;&nbsp;Create&nbsp;an&nbsp;ILU&nbsp;(Incomplete&nbsp;LU)&nbsp;preconditioner&nbsp;for&nbsp;the&nbsp;sparse<br>
&nbsp;&nbsp;matrix&nbsp;`m`.&nbsp;This&nbsp;preconditioner&nbsp;has&nbsp;the&nbsp;same&nbsp;sparsity&nbsp;pattern<br>
&nbsp;&nbsp;than&nbsp;`m`&nbsp;(no&nbsp;fill-in).<br>
*&nbsp;<a href="#Precond">Precond</a>('ildltt',&nbsp;<a href="#Spmat">Spmat</a>&nbsp;m[,&nbsp;int&nbsp;fillin[,&nbsp;scalar&nbsp;threshold]])<br>
&nbsp;&nbsp;Create&nbsp;an&nbsp;ILDLT&nbsp;(Cholesky&nbsp;with&nbsp;filling)&nbsp;preconditioner&nbsp;for&nbsp;the<br>
&nbsp;&nbsp;(symmetric)&nbsp;sparse&nbsp;matrix&nbsp;`m`.&nbsp;The&nbsp;preconditioner&nbsp;may&nbsp;add&nbsp;at&nbsp;most<br>
&nbsp;&nbsp;`fillin`&nbsp;additional&nbsp;non-zero&nbsp;entries&nbsp;on&nbsp;each&nbsp;line.&nbsp;The&nbsp;default<br>
&nbsp;&nbsp;value&nbsp;for&nbsp;`fillin`&nbsp;is&nbsp;10,&nbsp;and&nbsp;the&nbsp;default&nbsp;threshold&nbsp;is1e-7.<br>
*&nbsp;<a href="#Precond">Precond</a>('ilut',&nbsp;<a href="#Spmat">Spmat</a>&nbsp;m[,&nbsp;int&nbsp;fillin[,&nbsp;scalar&nbsp;threshold]])<br>
&nbsp;&nbsp;Create&nbsp;an&nbsp;ILUT&nbsp;(Incomplete&nbsp;LU&nbsp;with&nbsp;filling)&nbsp;preconditioner&nbsp;for&nbsp;the<br>
&nbsp;&nbsp;sparse&nbsp;matrix&nbsp;`m`.&nbsp;The&nbsp;preconditioner&nbsp;may&nbsp;add&nbsp;at&nbsp;most&nbsp;`fillin`<br>
&nbsp;&nbsp;additional&nbsp;non-zero&nbsp;entries&nbsp;on&nbsp;each&nbsp;line.&nbsp;The&nbsp;default&nbsp;value&nbsp;for<br>
&nbsp;&nbsp;`fillin`&nbsp;is&nbsp;10,&nbsp;and&nbsp;the&nbsp;default&nbsp;threshold&nbsp;is&nbsp;1e-7.<br>
*&nbsp;<a href="#Precond">Precond</a>('superlu',&nbsp;<a href="#Spmat">Spmat</a>&nbsp;m)<br>
&nbsp;&nbsp;Uses&nbsp;SuperLU&nbsp;to&nbsp;build&nbsp;an&nbsp;exact&nbsp;factorization&nbsp;of&nbsp;the&nbsp;sparse&nbsp;matrix<br>
&nbsp;&nbsp;`m`.&nbsp;This&nbsp;preconditioner&nbsp;is&nbsp;only&nbsp;available&nbsp;if&nbsp;the&nbsp;getfem-interface<br>
&nbsp;&nbsp;was&nbsp;built&nbsp;with&nbsp;SuperLU&nbsp;support.&nbsp;Note&nbsp;that&nbsp;LU&nbsp;factorization&nbsp;is&nbsp;likely<br>
&nbsp;&nbsp;to&nbsp;eat&nbsp;all&nbsp;your&nbsp;memory&nbsp;for&nbsp;3D&nbsp;problems.&nbsp;*&nbsp;<a href="#Precond">Precond</a>('spmat',&nbsp;<a href="#Spmat">Spmat</a>&nbsp;M)<br>
&nbsp;&nbsp;???</tt></dd></dl>

<dl><dt><a name="Precond-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Precond-info"><strong>info</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;short&nbsp;informative&nbsp;string&nbsp;about&nbsp;the&nbsp;preconditioner.</tt></dd></dl>

<dl><dt><a name="Precond-is_complex"><strong>is_complex</strong></a>(self)</dt><dd><tt>Return&nbsp;1&nbsp;if&nbsp;the&nbsp;preconditioner&nbsp;stores&nbsp;complex&nbsp;values.</tt></dd></dl>

<dl><dt><a name="Precond-mult"><strong>mult</strong></a>(self, V)</dt><dd><tt>Apply&nbsp;the&nbsp;preconditioner&nbsp;to&nbsp;the&nbsp;supplied&nbsp;vector.</tt></dd></dl>

<dl><dt><a name="Precond-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Precond-size"><strong>size</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;dimensions&nbsp;of&nbsp;the&nbsp;preconditioner.</tt></dd></dl>

<dl><dt><a name="Precond-tmult"><strong>tmult</strong></a>(self, V)</dt><dd><tt>Apply&nbsp;the&nbsp;transposed&nbsp;preconditioner&nbsp;to&nbsp;the&nbsp;supplied&nbsp;vector.</tt></dd></dl>

<dl><dt><a name="Precond-type"><strong>type</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;string&nbsp;describing&nbsp;the&nbsp;type&nbsp;of&nbsp;the&nbsp;preconditioner&nbsp;('ilu',&nbsp;'ildlt',..).</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Slice">class <strong>Slice</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Mesh">Mesh</a>&nbsp;slices.<br>
&nbsp;<br>
The&nbsp;slices&nbsp;may&nbsp;be&nbsp;considered&nbsp;as&nbsp;a&nbsp;(non-conformal)&nbsp;mesh&nbsp;of&nbsp;simplexes<br>
which&nbsp;provides&nbsp;fast&nbsp;interpolation&nbsp;on&nbsp;a&nbsp;P1-discontinuous&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;&nbsp;&nbsp;&nbsp;<br>
It&nbsp;is&nbsp;used&nbsp;mainly&nbsp;for&nbsp;post-processing&nbsp;purposes.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Slice-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="Slice-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;<a href="#Slice">Slice</a>&nbsp;objects.<br>
&nbsp;<br>
-&nbsp;<a href="#Slice">Slice</a>(sliceop,&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m,&nbsp;int&nbsp;refine[,&nbsp;mat&nbsp;CVfids])<br>
-&nbsp;<a href="#Slice">Slice</a>(sliceop,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf,&nbsp;vec&nbsp;U,&nbsp;int&nbsp;refine[,&nbsp;mat&nbsp;CVfids])<br>
-&nbsp;<a href="#Slice">Slice</a>(sliceop,&nbsp;<a href="#Slice">Slice</a>&nbsp;sl)<br>
-&nbsp;<a href="#Slice">Slice</a>('streamlines',&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf,&nbsp;vec&nbsp;U,&nbsp;mat&nbsp;SEEDS)<br>
-&nbsp;<a href="#Slice">Slice</a>('points',&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m,&nbsp;mat&nbsp;PTS)<br>
-&nbsp;<a href="#Slice">Slice</a>('load',&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m)<br>
&nbsp;<br>
Creation&nbsp;of&nbsp;a&nbsp;mesh&nbsp;slice.&nbsp;<a href="#Mesh">Mesh</a>&nbsp;slices&nbsp;are&nbsp;very&nbsp;similar&nbsp;to&nbsp;a<br>
P1-discontinuous&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;on&nbsp;which&nbsp;interpolation&nbsp;is&nbsp;very&nbsp;fast.&nbsp;The<br>
slice&nbsp;is&nbsp;built&nbsp;from&nbsp;a&nbsp;mesh&nbsp;object,&nbsp;and&nbsp;a&nbsp;description&nbsp;of&nbsp;the<br>
slicing&nbsp;operation,&nbsp;for&nbsp;example:<br>
&nbsp;<br>
sl&nbsp;=&nbsp;<a href="#Slice">Slice</a>(('planar',+1,array([[0],[0]]),array([[0],[1]])),&nbsp;m,&nbsp;5);<br>
&nbsp;<br>
cuts&nbsp;the&nbsp;original&nbsp;mesh&nbsp;with&nbsp;the&nbsp;half&nbsp;space&nbsp;{y&gt;0}.&nbsp;Each&nbsp;convex&nbsp;of&nbsp;the<br>
original&nbsp;mesh&nbsp;`m`&nbsp;is&nbsp;simplexified&nbsp;(for&nbsp;example&nbsp;a&nbsp;quadrangle&nbsp;is<br>
splitted&nbsp;into&nbsp;2&nbsp;triangles),&nbsp;and&nbsp;each&nbsp;simplex&nbsp;is&nbsp;refined&nbsp;5&nbsp;times.<br>
&nbsp;<br>
Slicing&nbsp;operations&nbsp;can&nbsp;be:<br>
&nbsp;<br>
-&nbsp;cutting&nbsp;with&nbsp;a&nbsp;plane,&nbsp;a&nbsp;sphere&nbsp;or&nbsp;a&nbsp;cylinder<br>
-&nbsp;intersection&nbsp;or&nbsp;union&nbsp;of&nbsp;slices<br>
-&nbsp;isovalues&nbsp;surfaces/volumes<br>
-&nbsp;"points",&nbsp;"streamlines"&nbsp;(see&nbsp;below)<br>
&nbsp;<br>
If&nbsp;the&nbsp;first&nbsp;argument&nbsp;is&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf&nbsp;instead&nbsp;of&nbsp;a&nbsp;mesh,&nbsp;and&nbsp;if&nbsp;it<br>
is&nbsp;followed&nbsp;by&nbsp;a&nbsp;field&nbsp;`U`,&nbsp;then&nbsp;the&nbsp;deformation&nbsp;U&nbsp;will&nbsp;be&nbsp;applied<br>
to&nbsp;the&nbsp;mesh&nbsp;before&nbsp;the&nbsp;slicing&nbsp;operation.<br>
&nbsp;<br>
The&nbsp;first&nbsp;argument&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;slice.<br>
&nbsp;<br>
**Slicing&nbsp;operations:**<br>
&nbsp;<br>
They&nbsp;are&nbsp;specified&nbsp;with&nbsp;TUPLES,&nbsp;do&nbsp;not&nbsp;forget&nbsp;the&nbsp;extra&nbsp;parentheses!.<br>
The&nbsp;first&nbsp;element&nbsp;is&nbsp;the&nbsp;name&nbsp;of&nbsp;the&nbsp;operation,&nbsp;followed&nbsp;the&nbsp;slicing<br>
options.<br>
&nbsp;<br>
*&nbsp;('none')<br>
&nbsp;&nbsp;Does&nbsp;not&nbsp;cut&nbsp;the&nbsp;mesh.<br>
*&nbsp;('planar',&nbsp;int&nbsp;orient,&nbsp;vec&nbsp;p,&nbsp;vec&nbsp;n)<br>
&nbsp;&nbsp;Planar&nbsp;cut.&nbsp;`p`&nbsp;and&nbsp;`n`&nbsp;define&nbsp;a&nbsp;half-space,&nbsp;`p`&nbsp;being&nbsp;a&nbsp;point&nbsp;belong&nbsp;to<br>
&nbsp;&nbsp;the&nbsp;boundary&nbsp;of&nbsp;the&nbsp;half-space,&nbsp;and&nbsp;`n`&nbsp;being&nbsp;its&nbsp;normal.&nbsp;If&nbsp;`orient`&nbsp;is<br>
&nbsp;&nbsp;equal&nbsp;to&nbsp;-1&nbsp;(resp.&nbsp;0,&nbsp;+1),&nbsp;then&nbsp;the&nbsp;slicing&nbsp;operation&nbsp;will&nbsp;cut&nbsp;the&nbsp;mesh<br>
&nbsp;&nbsp;with&nbsp;the&nbsp;"interior"&nbsp;(resp.&nbsp;"boundary",&nbsp;"exterior")&nbsp;of&nbsp;the&nbsp;half-space.<br>
&nbsp;&nbsp;`orient`&nbsp;may&nbsp;also&nbsp;be&nbsp;set&nbsp;to&nbsp;+2&nbsp;which&nbsp;means&nbsp;that&nbsp;the&nbsp;mesh&nbsp;will&nbsp;be&nbsp;sliced,<br>
&nbsp;&nbsp;but&nbsp;both&nbsp;the&nbsp;outer&nbsp;and&nbsp;inner&nbsp;parts&nbsp;will&nbsp;be&nbsp;kept.<br>
*&nbsp;('ball',&nbsp;int&nbsp;orient,&nbsp;vec&nbsp;c,&nbsp;scalar&nbsp;r)<br>
&nbsp;&nbsp;Cut&nbsp;with&nbsp;a&nbsp;ball&nbsp;of&nbsp;center&nbsp;`c`&nbsp;and&nbsp;radius&nbsp;`r`.<br>
*&nbsp;('cylinder',&nbsp;int&nbsp;orient,&nbsp;vec&nbsp;p1,&nbsp;vec&nbsp;p2,&nbsp;scalar&nbsp;r)<br>
&nbsp;&nbsp;Cut&nbsp;with&nbsp;a&nbsp;cylinder&nbsp;whose&nbsp;axis&nbsp;is&nbsp;the&nbsp;line&nbsp;`(p1,p2)`&nbsp;and&nbsp;whose&nbsp;radius&nbsp;is<br>
&nbsp;&nbsp;`r`.<br>
*&nbsp;('isovalues',&nbsp;int&nbsp;orient,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf,&nbsp;vec&nbsp;U,&nbsp;scalar&nbsp;V)<br>
&nbsp;&nbsp;Cut&nbsp;using&nbsp;the&nbsp;isosurface&nbsp;of&nbsp;the&nbsp;field&nbsp;`U`&nbsp;(defined&nbsp;on&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mf`).<br>
&nbsp;&nbsp;The&nbsp;result&nbsp;is&nbsp;the&nbsp;set&nbsp;`{x&nbsp;such&nbsp;that&nbsp;U(x)&nbsp;&lt;=&nbsp;V}`&nbsp;or&nbsp;`{x&nbsp;such&nbsp;that<br>
&nbsp;&nbsp;U(x)=V}`&nbsp;or&nbsp;`{x&nbsp;such&nbsp;that&nbsp;U(x)&nbsp;&gt;=&nbsp;V}`&nbsp;depending&nbsp;on&nbsp;the&nbsp;value&nbsp;of<br>
&nbsp;&nbsp;`orient`.<br>
*&nbsp;('boundary'[,&nbsp;SLICEOP])<br>
&nbsp;&nbsp;Return&nbsp;the&nbsp;boundary&nbsp;of&nbsp;the&nbsp;result&nbsp;of&nbsp;SLICEOP,&nbsp;where&nbsp;SLICEOP&nbsp;is&nbsp;any<br>
&nbsp;&nbsp;slicing&nbsp;operation.&nbsp;If&nbsp;SLICEOP&nbsp;is&nbsp;not&nbsp;specified,&nbsp;then&nbsp;the&nbsp;whole&nbsp;mesh&nbsp;is<br>
&nbsp;&nbsp;considered&nbsp;(i.e.&nbsp;it&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;('boundary',{'none'})).<br>
*&nbsp;('explode',&nbsp;mat&nbsp;Coef)<br>
&nbsp;&nbsp;Build&nbsp;an&nbsp;'exploded'&nbsp;view&nbsp;of&nbsp;the&nbsp;mesh:&nbsp;each&nbsp;convex&nbsp;is&nbsp;shrinked&nbsp;(0&nbsp;&lt;&nbsp;Coef<br>
&nbsp;&nbsp;&lt;=&nbsp;1).&nbsp;In&nbsp;the&nbsp;case&nbsp;of&nbsp;3D&nbsp;convexes,&nbsp;only&nbsp;their&nbsp;faces&nbsp;are&nbsp;kept.<br>
*&nbsp;('union',&nbsp;SLICEOP1,&nbsp;SLICEOP2)<br>
*&nbsp;('intersection',&nbsp;SLICEOP1,&nbsp;SLICEOP2)<br>
*&nbsp;('diff',&nbsp;SLICEOP1,&nbsp;SLICEOP2)<br>
*&nbsp;('comp',&nbsp;SLICEOP)<br>
&nbsp;&nbsp;Boolean&nbsp;operations:&nbsp;returns&nbsp;the&nbsp;union,intersection,&nbsp;difference&nbsp;or<br>
&nbsp;&nbsp;complementary&nbsp;of&nbsp;slicing&nbsp;operations.<br>
*&nbsp;('mesh',&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m)<br>
&nbsp;&nbsp;Build&nbsp;a&nbsp;slice&nbsp;which&nbsp;is&nbsp;the&nbsp;intersection&nbsp;of&nbsp;the&nbsp;sliced&nbsp;mesh&nbsp;with&nbsp;another<br>
&nbsp;&nbsp;mesh.&nbsp;The&nbsp;slice&nbsp;is&nbsp;such&nbsp;that&nbsp;all&nbsp;of&nbsp;its&nbsp;simplexes&nbsp;are&nbsp;stricly&nbsp;contained<br>
&nbsp;&nbsp;into&nbsp;a&nbsp;convex&nbsp;of&nbsp;each&nbsp;mesh.<br>
&nbsp;<br>
&nbsp;&nbsp;EXAMPLE:<br>
&nbsp;<br>
&nbsp;&nbsp;sl&nbsp;=&nbsp;<a href="#Slice">Slice</a>(('intersection',('planar',+1,[0;0;0],[0;0;1]),<br>
&nbsp;&nbsp;...,('isovalues',-1,mf2,U2,0)),mf,U,5);<br>
&nbsp;<br>
**SPECIAL&nbsp;SLICES**:<br>
&nbsp;<br>
There&nbsp;are&nbsp;also&nbsp;some&nbsp;special&nbsp;calls&nbsp;to&nbsp;<a href="#Slice">Slice</a>(...)<br>
&nbsp;<br>
*&nbsp;<a href="#Slice">Slice</a>('streamlines',<a href="#MeshFem">MeshFem</a>&nbsp;mf,&nbsp;mat&nbsp;U,&nbsp;mat&nbsp;Seeds)<br>
&nbsp;&nbsp;compute&nbsp;streamlines&nbsp;of&nbsp;the&nbsp;(vector)&nbsp;field&nbsp;`U`,&nbsp;with&nbsp;seed&nbsp;points&nbsp;given&nbsp;by<br>
&nbsp;&nbsp;the&nbsp;columns&nbsp;of&nbsp;`Seeds`.<br>
*&nbsp;<a href="#Slice">Slice</a>('points',&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m,&nbsp;mat&nbsp;Pts)<br>
&nbsp;&nbsp;return&nbsp;the&nbsp;"slice"&nbsp;composed&nbsp;of&nbsp;points&nbsp;given&nbsp;by&nbsp;the&nbsp;columns&nbsp;of&nbsp;`Pts`<br>
&nbsp;&nbsp;(useful&nbsp;for&nbsp;interpolation&nbsp;on&nbsp;a&nbsp;given&nbsp;set&nbsp;of&nbsp;sparse&nbsp;points,&nbsp;see<br>
&nbsp;&nbsp;<a href="#-compute_interpolate_on">compute_interpolate_on</a>(mf,&nbsp;U,&nbsp;sl).<br>
*&nbsp;<a href="#Slice">Slice</a>('load',&nbsp;string&nbsp;filename[,&nbsp;<a href="#Mesh">Mesh</a>&nbsp;m])<br>
&nbsp;&nbsp;load&nbsp;the&nbsp;slice&nbsp;(and&nbsp;its&nbsp;linked&nbsp;mesh&nbsp;if&nbsp;it&nbsp;is&nbsp;not&nbsp;given&nbsp;as&nbsp;an&nbsp;argument)<br>
&nbsp;&nbsp;from&nbsp;a&nbsp;text&nbsp;file.</tt></dd></dl>

<dl><dt><a name="Slice-area"><strong>area</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;area&nbsp;of&nbsp;the&nbsp;slice.</tt></dd></dl>

<dl><dt><a name="Slice-cvs"><strong>cvs</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;convexes&nbsp;of&nbsp;the&nbsp;original&nbsp;mesh&nbsp;contained&nbsp;in&nbsp;the&nbsp;slice.</tt></dd></dl>

<dl><dt><a name="Slice-dim"><strong>dim</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;slice&nbsp;(2&nbsp;for&nbsp;a&nbsp;2D&nbsp;mesh,&nbsp;etc..).</tt></dd></dl>

<dl><dt><a name="Slice-edges"><strong>edges</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;edges&nbsp;of&nbsp;the&nbsp;linked&nbsp;mesh&nbsp;contained&nbsp;in&nbsp;the&nbsp;slice.<br>
&nbsp;<br>
Synopsis:&nbsp;(P,&nbsp;E1,&nbsp;E2)&nbsp;=&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-edges">edges</a>()<br>
&nbsp;<br>
`P`&nbsp;contains&nbsp;the&nbsp;list&nbsp;of&nbsp;all&nbsp;edge&nbsp;vertices,&nbsp;`E1`&nbsp;contains&nbsp;the&nbsp;indices&nbsp;of&nbsp;each<br>
mesh&nbsp;edge&nbsp;in&nbsp;`P`,&nbsp;and&nbsp;`E2`&nbsp;contains&nbsp;the&nbsp;indices&nbsp;of&nbsp;each&nbsp;"edges"&nbsp;which&nbsp;is&nbsp;on<br>
the&nbsp;border&nbsp;of&nbsp;the&nbsp;slice.&nbsp;This&nbsp;function&nbsp;is&nbsp;useless&nbsp;except&nbsp;for&nbsp;post-processing<br>
purposes.</tt></dd></dl>

<dl><dt><a name="Slice-export_to_dx"><strong>export_to_dx</strong></a>(self, filename, *args)</dt><dd><tt>Export&nbsp;a&nbsp;slice&nbsp;to&nbsp;OpenDX.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-export_to_dx">export_to_dx</a>(string&nbsp;filename,&nbsp;...)<br>
&nbsp;<br>
Following&nbsp;the&nbsp;file&nbsp;name,&nbsp;you&nbsp;may&nbsp;use&nbsp;any&nbsp;of&nbsp;the&nbsp;following&nbsp;options:<br>
&nbsp;<br>
-&nbsp;if&nbsp;'ascii'&nbsp;is&nbsp;not&nbsp;used,&nbsp;the&nbsp;file&nbsp;will&nbsp;contain&nbsp;binary&nbsp;data<br>
&nbsp;&nbsp;(non&nbsp;portable,&nbsp;but&nbsp;fast).<br>
-&nbsp;if&nbsp;'edges'&nbsp;is&nbsp;used,&nbsp;the&nbsp;edges&nbsp;of&nbsp;the&nbsp;original&nbsp;mesh&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;written&nbsp;instead&nbsp;of&nbsp;the&nbsp;slice&nbsp;content.<br>
-&nbsp;if&nbsp;'append'&nbsp;is&nbsp;used,&nbsp;the&nbsp;opendx&nbsp;file&nbsp;will&nbsp;not&nbsp;be&nbsp;overwritten,<br>
&nbsp;&nbsp;and&nbsp;the&nbsp;new&nbsp;data&nbsp;will&nbsp;be&nbsp;added&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;file.<br>
&nbsp;<br>
More&nbsp;than&nbsp;one&nbsp;dataset&nbsp;may&nbsp;be&nbsp;written,&nbsp;just&nbsp;list&nbsp;them.&nbsp;Each&nbsp;dataset&nbsp;consists&nbsp;of<br>
either:<br>
&nbsp;<br>
-&nbsp;a&nbsp;field&nbsp;interpolated&nbsp;on&nbsp;the&nbsp;slice&nbsp;(scalar,&nbsp;vector&nbsp;or&nbsp;tensor),<br>
&nbsp;&nbsp;followed&nbsp;by&nbsp;an&nbsp;optional&nbsp;name.<br>
-&nbsp;a&nbsp;mesh_fem&nbsp;and&nbsp;a&nbsp;field,&nbsp;followed&nbsp;by&nbsp;an&nbsp;optional&nbsp;name.</tt></dd></dl>

<dl><dt><a name="Slice-export_to_pov"><strong>export_to_pov</strong></a>(self, filename, *args)</dt><dd><tt>Export&nbsp;a&nbsp;the&nbsp;triangles&nbsp;of&nbsp;the&nbsp;slice&nbsp;to&nbsp;POV-RAY.</tt></dd></dl>

<dl><dt><a name="Slice-export_to_vtk"><strong>export_to_vtk</strong></a>(self, filename, *args)</dt><dd><tt>Export&nbsp;a&nbsp;slice&nbsp;to&nbsp;VTK.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-export_to_vtk">export_to_vtk</a>(string&nbsp;filename&nbsp;...&nbsp;[,&nbsp;'ascii'][,&nbsp;'edges']&nbsp;...)<br>
&nbsp;<br>
Following&nbsp;the&nbsp;`filename`,&nbsp;you&nbsp;may&nbsp;use&nbsp;any&nbsp;of&nbsp;the&nbsp;following&nbsp;options:<br>
&nbsp;<br>
-&nbsp;if&nbsp;'ascii'&nbsp;is&nbsp;not&nbsp;used,&nbsp;the&nbsp;file&nbsp;will&nbsp;contain&nbsp;binary&nbsp;data<br>
&nbsp;&nbsp;(non&nbsp;portable,&nbsp;but&nbsp;fast).<br>
-&nbsp;if&nbsp;'edges'&nbsp;is&nbsp;used,&nbsp;the&nbsp;edges&nbsp;of&nbsp;the&nbsp;original&nbsp;mesh&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;written&nbsp;instead&nbsp;of&nbsp;the&nbsp;slice&nbsp;content.<br>
&nbsp;<br>
More&nbsp;than&nbsp;one&nbsp;dataset&nbsp;may&nbsp;be&nbsp;written,&nbsp;just&nbsp;list&nbsp;them.&nbsp;Each&nbsp;dataset&nbsp;consists&nbsp;of<br>
either:<br>
&nbsp;<br>
-&nbsp;a&nbsp;field&nbsp;interpolated&nbsp;on&nbsp;the&nbsp;slice&nbsp;(scalar,&nbsp;vector&nbsp;or&nbsp;tensor),<br>
&nbsp;&nbsp;followed&nbsp;by&nbsp;an&nbsp;optional&nbsp;name.<br>
-&nbsp;a&nbsp;mesh_fem&nbsp;and&nbsp;a&nbsp;field,&nbsp;followed&nbsp;by&nbsp;an&nbsp;optional&nbsp;name.<br>
&nbsp;<br>
Examples:<br>
&nbsp;<br>
-&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-export_to_vtk">export_to_vtk</a>('test.vtk',Usl,'first_dataset',&nbsp;mf,<br>
&nbsp;&nbsp;U2,&nbsp;'second_dataset')<br>
-&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-export_to_vtk">export_to_vtk</a>('test.vtk','ascii',mf,U2)<br>
-&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-export_to_vtk">export_to_vtk</a>('test.vtk','edges','ascii',Uslice)</tt></dd></dl>

<dl><dt><a name="Slice-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Slice-interpolate_convex_data"><strong>interpolate_convex_data</strong></a>(self, Ucv)</dt><dd><tt>Interpolate&nbsp;data&nbsp;given&nbsp;on&nbsp;each&nbsp;convex&nbsp;of&nbsp;the&nbsp;mesh&nbsp;to&nbsp;the&nbsp;slice&nbsp;nodes.<br>
&nbsp;<br>
Synopsis:&nbsp;Usl&nbsp;=&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-interpolate_convex_data">interpolate_convex_data</a>(mat&nbsp;Ucv)<br>
&nbsp;<br>
The&nbsp;input&nbsp;array&nbsp;`Ucv`&nbsp;may&nbsp;have&nbsp;any&nbsp;number&nbsp;of&nbsp;dimensions,&nbsp;but&nbsp;its&nbsp;last<br>
dimension&nbsp;should&nbsp;be&nbsp;equal&nbsp;to&nbsp;<a href="#Mesh">Mesh</a>.max_cvid().<br>
&nbsp;<br>
Example&nbsp;of&nbsp;use:&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-interpolate_convex_data">interpolate_convex_data</a>(&nbsp;<a href="#Mesh">Mesh</a>.quality()).</tt></dd></dl>

<dl><dt><a name="Slice-linked_mesh"><strong>linked_mesh</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;mesh&nbsp;on&nbsp;which&nbsp;the&nbsp;slice&nbsp;was&nbsp;taken.</tt></dd></dl>

<dl><dt><a name="Slice-memsize"><strong>memsize</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;amount&nbsp;of&nbsp;memory&nbsp;(in&nbsp;bytes)&nbsp;used&nbsp;by&nbsp;the&nbsp;slice&nbsp;object.</tt></dd></dl>

<dl><dt><a name="Slice-mesh"><strong>mesh</strong></a>(self)</dt></dl>

<dl><dt><a name="Slice-nbpts"><strong>nbpts</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;number&nbsp;of&nbsp;points&nbsp;in&nbsp;the&nbsp;slice.</tt></dd></dl>

<dl><dt><a name="Slice-nbsplxs"><strong>nbsplxs</strong></a>(self, dim<font color="#909090">=None</font>)</dt><dd><tt>Return&nbsp;the&nbsp;number&nbsp;of&nbsp;simplexes&nbsp;in&nbsp;the&nbsp;slice.<br>
&nbsp;<br>
Synopsis:&nbsp;ns&nbsp;=&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-nbsplxs">nbsplxs</a>([,&nbsp;int&nbsp;dim])<br>
&nbsp;<br>
Since&nbsp;the&nbsp;slice&nbsp;may&nbsp;contain&nbsp;points&nbsp;(simplexes&nbsp;of&nbsp;dim&nbsp;0),&nbsp;segments&nbsp;(simplexes<br>
of&nbsp;dimension&nbsp;1),&nbsp;triangles&nbsp;etc.,&nbsp;the&nbsp;result&nbsp;is&nbsp;a&nbsp;vector&nbsp;of&nbsp;size&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-dim">dim</a>()+1<br>
,&nbsp;except&nbsp;if&nbsp;the&nbsp;optional&nbsp;argument&nbsp;`dim`&nbsp;is&nbsp;used.</tt></dd></dl>

<dl><dt><a name="Slice-pts"><strong>pts</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;point&nbsp;coordinates.</tt></dd></dl>

<dl><dt><a name="Slice-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Slice-set_pts"><strong>set_pts</strong></a>(self, P)</dt><dd><tt>Replace&nbsp;the&nbsp;points&nbsp;of&nbsp;the&nbsp;slice.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-set_pts">set_pts</a>(mat&nbsp;P)<br>
&nbsp;<br>
The&nbsp;new&nbsp;points&nbsp;`P`&nbsp;are&nbsp;stored&nbsp;in&nbsp;the&nbsp;columns&nbsp;the&nbsp;matrix.&nbsp;Note&nbsp;that&nbsp;you&nbsp;can&nbsp;use<br>
the&nbsp;function&nbsp;to&nbsp;apply&nbsp;a&nbsp;deformation&nbsp;to&nbsp;a&nbsp;slice,&nbsp;or&nbsp;to&nbsp;change&nbsp;the&nbsp;dimension&nbsp;of<br>
the&nbsp;slice&nbsp;(the&nbsp;number&nbsp;of&nbsp;rows&nbsp;of&nbsp;`P`&nbsp;is&nbsp;not&nbsp;required&nbsp;to&nbsp;be&nbsp;equal&nbsp;to<br>
<a href="#Slice">Slice</a>.<a href="#Slice-dim">dim</a>()).</tt></dd></dl>

<dl><dt><a name="Slice-splxs"><strong>splxs</strong></a>(self, dim)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;simplexes&nbsp;of&nbsp;dimension&nbsp;`dim`.<br>
&nbsp;<br>
Synopsis:&nbsp;(S,&nbsp;CV2S)&nbsp;=&nbsp;<a href="#Slice">Slice</a>.<a href="#Slice-splxs">splxs</a>(int&nbsp;dim)<br>
&nbsp;<br>
On&nbsp;output,&nbsp;S&nbsp;has&nbsp;'dim+1'&nbsp;rows,&nbsp;each&nbsp;column&nbsp;contains&nbsp;the&nbsp;point&nbsp;numbers&nbsp;of&nbsp;a<br>
simplex.&nbsp;The&nbsp;vector&nbsp;`CV2S`&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;find&nbsp;the&nbsp;list&nbsp;of&nbsp;simplexes&nbsp;for&nbsp;any<br>
convex&nbsp;stored&nbsp;in&nbsp;the&nbsp;slice.&nbsp;For&nbsp;example&nbsp;'S[:,CV2S[4]:CV2S[5]]'&nbsp;gives&nbsp;the&nbsp;list<br>
of&nbsp;simplexes&nbsp;for&nbsp;the&nbsp;fourth&nbsp;convex.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Spmat">class <strong>Spmat</strong></a></font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Getfem&nbsp;sparse&nbsp;matrix.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Spmat-__add__"><strong>__add__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Spmat-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="Spmat-__getitem__"><strong>__getitem__</strong></a>(self, key)</dt></dl>

<dl><dt><a name="Spmat-__init__"><strong>__init__</strong></a>(self, *args)</dt><dd><tt>General&nbsp;constructor&nbsp;for&nbsp;getfem&nbsp;sparse&nbsp;matrices.<br>
&nbsp;<br>
These&nbsp;sparse&nbsp;matrix&nbsp;can&nbsp;be&nbsp;stored&nbsp;as&nbsp;CSC&nbsp;(compressed&nbsp;column&nbsp;sparse),&nbsp;which<br>
is&nbsp;the&nbsp;format&nbsp;used&nbsp;by&nbsp;Matlab,&nbsp;or&nbsp;they&nbsp;can&nbsp;be&nbsp;stored&nbsp;as&nbsp;WSC&nbsp;(internal&nbsp;format<br>
to&nbsp;getfem).&nbsp;The&nbsp;CSC&nbsp;matrices&nbsp;are&nbsp;not&nbsp;writable&nbsp;(it&nbsp;would&nbsp;be&nbsp;very&nbsp;inefficient),<br>
but&nbsp;they&nbsp;are&nbsp;optimized&nbsp;for&nbsp;multiplication&nbsp;with&nbsp;vectors,&nbsp;and&nbsp;memory&nbsp;usage.<br>
The&nbsp;WSC&nbsp;are&nbsp;writable,&nbsp;they&nbsp;are&nbsp;very&nbsp;fast&nbsp;with&nbsp;respect&nbsp;to&nbsp;random&nbsp;read/write<br>
operation.&nbsp;However&nbsp;their&nbsp;memory&nbsp;overhead&nbsp;is&nbsp;higher&nbsp;than&nbsp;CSC&nbsp;matrices,&nbsp;and<br>
they&nbsp;are&nbsp;a&nbsp;little&nbsp;bit&nbsp;slower&nbsp;for&nbsp;matrix-vector&nbsp;multiplications.<br>
&nbsp;<br>
By&nbsp;default,&nbsp;all&nbsp;newly&nbsp;created&nbsp;matrices&nbsp;are&nbsp;build&nbsp;as&nbsp;WSC&nbsp;matrices.&nbsp;This&nbsp;can<br>
be&nbsp;changed&nbsp;later&nbsp;with&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-to_csc">to_csc</a>(...),&nbsp;or&nbsp;may&nbsp;be&nbsp;changed&nbsp;automatically<br>
by&nbsp;getfem&nbsp;(for&nbsp;example&nbsp;::LINSOLVE()&nbsp;converts&nbsp;the&nbsp;matrices&nbsp;to&nbsp;CSC).<br>
&nbsp;<br>
The&nbsp;matrices&nbsp;may&nbsp;store&nbsp;REAL&nbsp;or&nbsp;COMPLEX&nbsp;values.<br>
&nbsp;<br>
*&nbsp;<a href="#Spmat">Spmat</a>('empty',&nbsp;int&nbsp;m&nbsp;[,&nbsp;int&nbsp;n])<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;new&nbsp;empty&nbsp;(i.e.&nbsp;full&nbsp;of&nbsp;zeros)&nbsp;sparse&nbsp;matrix,&nbsp;of&nbsp;dimensions&nbsp;`m<br>
&nbsp;&nbsp;x&nbsp;n`.&nbsp;If&nbsp;`n`&nbsp;is&nbsp;omitted,&nbsp;the&nbsp;matrix&nbsp;dimension&nbsp;is&nbsp;`m&nbsp;x&nbsp;m`.<br>
*&nbsp;<a href="#Spmat">Spmat</a>('copy',&nbsp;mat&nbsp;K&nbsp;[,&nbsp;list&nbsp;I&nbsp;[,&nbsp;list&nbsp;J]])<br>
&nbsp;&nbsp;Duplicate&nbsp;a&nbsp;matrix&nbsp;K&nbsp;(which&nbsp;might&nbsp;be&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>).&nbsp;If&nbsp;(index)&nbsp;`I`&nbsp;and/or&nbsp;`J`<br>
&nbsp;&nbsp;are&nbsp;given,&nbsp;the&nbsp;matrix&nbsp;will&nbsp;be&nbsp;a&nbsp;submatrix&nbsp;of&nbsp;`K`.&nbsp;For&nbsp;example:<br>
&nbsp;<br>
&nbsp;&nbsp;M&nbsp;=&nbsp;<a href="#Spmat">Spmat</a>('copy',&nbsp;<a href="#Spmat">Spmat</a>('empty',50,50),&nbsp;range(40),&nbsp;[6,&nbsp;7,&nbsp;8,&nbsp;3,&nbsp;10])<br>
&nbsp;<br>
&nbsp;&nbsp;will&nbsp;return&nbsp;a&nbsp;40x5&nbsp;matrix.<br>
*&nbsp;<a href="#Spmat">Spmat</a>('identity',&nbsp;int&nbsp;n)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;`n&nbsp;x&nbsp;n`&nbsp;identity&nbsp;matrix.<br>
*&nbsp;<a href="#Spmat">Spmat</a>('mult',&nbsp;@spmat&nbsp;A,&nbsp;@spmat&nbsp;B)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;sparse&nbsp;matrix&nbsp;as&nbsp;the&nbsp;product&nbsp;of&nbsp;the&nbsp;sparse&nbsp;matrices&nbsp;`A`&nbsp;and<br>
&nbsp;&nbsp;`B`.&nbsp;It&nbsp;requires&nbsp;that&nbsp;`A`&nbsp;and&nbsp;`B`&nbsp;be&nbsp;both&nbsp;real&nbsp;or&nbsp;both&nbsp;complex,&nbsp;you&nbsp;may<br>
&nbsp;&nbsp;have&nbsp;to&nbsp;use&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-to_complex">to_complex</a>()<br>
*&nbsp;<a href="#Spmat">Spmat</a>('add',&nbsp;@spmat&nbsp;A,&nbsp;@spmat&nbsp;B)<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;sparse&nbsp;matrix&nbsp;as&nbsp;the&nbsp;sum&nbsp;of&nbsp;the&nbsp;sparse&nbsp;matrices&nbsp;`A`&nbsp;and&nbsp;`B`.<br>
&nbsp;&nbsp;Adding&nbsp;a&nbsp;real&nbsp;matrix&nbsp;with&nbsp;a&nbsp;complex&nbsp;matrix&nbsp;is&nbsp;possible.<br>
*&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-diag">diag</a>(&nbsp;mat&nbsp;D&nbsp;[,&nbsp;ivec&nbsp;E&nbsp;[,&nbsp;int&nbsp;n&nbsp;[,int&nbsp;m]]])<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;diagonal&nbsp;matrix.&nbsp;If&nbsp;`E`&nbsp;is&nbsp;given,&nbsp;`D`&nbsp;might&nbsp;be&nbsp;a&nbsp;matrix&nbsp;and<br>
&nbsp;&nbsp;each&nbsp;column&nbsp;of&nbsp;`E`&nbsp;will&nbsp;contain&nbsp;the&nbsp;sub-diagonal&nbsp;number&nbsp;that&nbsp;will&nbsp;be<br>
&nbsp;&nbsp;filled&nbsp;with&nbsp;the&nbsp;corresponding&nbsp;column&nbsp;of&nbsp;`D`.<br>
*&nbsp;<a href="#Spmat">Spmat</a>('load','hb'|'harwell-boeing',&nbsp;string&nbsp;filename)<br>
&nbsp;&nbsp;Read&nbsp;a&nbsp;sparse&nbsp;matrix&nbsp;from&nbsp;an&nbsp;Harwell-Boeing&nbsp;file.<br>
*&nbsp;<a href="#Spmat">Spmat</a>('load','mm'|'matrix-market',&nbsp;filename)<br>
&nbsp;&nbsp;Read&nbsp;a&nbsp;sparse&nbsp;matrix&nbsp;from&nbsp;a&nbsp;Matrix-Market&nbsp;file.</tt></dd></dl>

<dl><dt><a name="Spmat-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Multiplication&nbsp;of&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;with&nbsp;another&nbsp;<a href="#Spmat">Spmat</a>&nbsp;or&nbsp;a&nbsp;vector&nbsp;or&nbsp;a&nbsp;scalar.<br>
&nbsp;<br>
The&nbsp;result&nbsp;is&nbsp;another&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object.</tt></dd></dl>

<dl><dt><a name="Spmat-__neg__"><strong>__neg__</strong></a>(self)</dt></dl>

<dl><dt><a name="Spmat-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Spmat-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Spmat-__setitem__"><strong>__setitem__</strong></a>(self, key, keyval)</dt></dl>

<dl><dt><a name="Spmat-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Spmat-__sub__"><strong>__sub__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Spmat-add"><strong>add</strong></a>(self, I, J, V)</dt><dd><tt>Add&nbsp;`V`&nbsp;to&nbsp;the&nbsp;sub-matrix&nbsp;'M(I,J)'.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-add">add</a>(ivec&nbsp;I,&nbsp;ivec&nbsp;J,&nbsp;mat&nbsp;V)<br>
&nbsp;<br>
`V`&nbsp;might&nbsp;be&nbsp;a&nbsp;sparse&nbsp;matrix&nbsp;or&nbsp;a&nbsp;full&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Spmat-assign"><strong>assign</strong></a>(self, I, J, V)</dt><dd><tt>Copy&nbsp;V&nbsp;into&nbsp;the&nbsp;sub-matrix&nbsp;'M(I,J)'.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-assign">assign</a>(ivec&nbsp;I,&nbsp;ivec&nbsp;J,&nbsp;mat&nbsp;V)<br>
&nbsp;<br>
`V`&nbsp;might&nbsp;be&nbsp;a&nbsp;sparse&nbsp;matrix&nbsp;or&nbsp;a&nbsp;full&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Spmat-clear"><strong>clear</strong></a>(self, I<font color="#909090">=None</font>, *args)</dt><dd><tt>Erase&nbsp;the&nbsp;non-zero&nbsp;entries&nbsp;of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-clear">clear</a>([,&nbsp;list&nbsp;I[,&nbsp;list&nbsp;J]])<br>
&nbsp;<br>
The&nbsp;optional&nbsp;arguments&nbsp;`I`&nbsp;and&nbsp;`J`&nbsp;may&nbsp;be&nbsp;specified&nbsp;to&nbsp;clear&nbsp;a&nbsp;sub-matrix<br>
instead&nbsp;of&nbsp;the&nbsp;entire&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Spmat-conjugate"><strong>conjugate</strong></a>(self)</dt><dd><tt>Conjugate&nbsp;each&nbsp;element&nbsp;of&nbsp;the&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Spmat-csc_ind"><strong>csc_ind</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;two&nbsp;usual&nbsp;index&nbsp;arrays&nbsp;of&nbsp;CSC&nbsp;storage.<br>
&nbsp;<br>
Synopsis:&nbsp;(JC,&nbsp;IR)&nbsp;=&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-csc_ind">csc_ind</a>()<br>
&nbsp;<br>
If&nbsp;`M`&nbsp;is&nbsp;not&nbsp;stored&nbsp;as&nbsp;a&nbsp;CSC&nbsp;matrix,&nbsp;it&nbsp;is&nbsp;converted&nbsp;into&nbsp;CSC.</tt></dd></dl>

<dl><dt><a name="Spmat-csc_val"><strong>csc_val</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;array&nbsp;of&nbsp;values&nbsp;of&nbsp;all&nbsp;non-zero&nbsp;entries&nbsp;of&nbsp;`M`.<br>
&nbsp;<br>
Synopsis:&nbsp;V&nbsp;=&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-csc_val">csc_val</a>()<br>
&nbsp;<br>
If&nbsp;`M`&nbsp;is&nbsp;not&nbsp;stored&nbsp;as&nbsp;a&nbsp;CSC&nbsp;matrix,&nbsp;it&nbsp;is&nbsp;converted&nbsp;into&nbsp;CSC.</tt></dd></dl>

<dl><dt><a name="Spmat-diag"><strong>diag</strong></a>(self, D, E<font color="#909090">=None</font>)</dt><dd><tt>Change&nbsp;the&nbsp;diagonal&nbsp;(or&nbsp;sub-diagonals)&nbsp;of&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-diag">diag</a>(mat&nbsp;D&nbsp;[,&nbsp;ivec&nbsp;E])<br>
&nbsp;<br>
If&nbsp;`E`&nbsp;is&nbsp;given,&nbsp;`D`&nbsp;might&nbsp;be&nbsp;a&nbsp;matrix&nbsp;and&nbsp;each&nbsp;column&nbsp;of&nbsp;`E`&nbsp;will&nbsp;contain&nbsp;the<br>
sub-diagonal&nbsp;number&nbsp;that&nbsp;will&nbsp;be&nbsp;filled&nbsp;with&nbsp;the&nbsp;corresponding&nbsp;column&nbsp;of&nbsp;`D`.</tt></dd></dl>

<dl><dt><a name="Spmat-dirichlet_nullspace"><strong>dirichlet_nullspace</strong></a>(self, R)</dt><dd><tt>Solve&nbsp;the&nbsp;dirichlet&nbsp;conditions&nbsp;`M.U=R`.<br>
&nbsp;<br>
Synopsis:&nbsp;(N,&nbsp;U0)&nbsp;=&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-dirichlet_nullspace">dirichlet_nullspace</a>(vec&nbsp;R)<br>
&nbsp;<br>
A&nbsp;solution&nbsp;`U0`&nbsp;which&nbsp;has&nbsp;a&nbsp;minimum&nbsp;L2-norm&nbsp;is&nbsp;returned,&nbsp;with&nbsp;a&nbsp;sparse&nbsp;matrix<br>
`N`&nbsp;containing&nbsp;an&nbsp;orthogonal&nbsp;basis&nbsp;of&nbsp;the&nbsp;kernel&nbsp;of&nbsp;the&nbsp;(assembled)<br>
constraints&nbsp;matrix&nbsp;`M`&nbsp;(hence,&nbsp;the&nbsp;PDE&nbsp;linear&nbsp;system&nbsp;should&nbsp;be&nbsp;solved&nbsp;on&nbsp;this<br>
subspace):&nbsp;the&nbsp;initial&nbsp;problem<br>
&nbsp;<br>
`K.U&nbsp;=&nbsp;B`&nbsp;with&nbsp;constraints&nbsp;`M.U&nbsp;=&nbsp;R`<br>
&nbsp;<br>
is&nbsp;replaced&nbsp;by<br>
&nbsp;<br>
`(N'.K.N).UU&nbsp;=&nbsp;N'.B`&nbsp;with&nbsp;`U&nbsp;=&nbsp;N.UU&nbsp;+&nbsp;U0`</tt></dd></dl>

<dl><dt><a name="Spmat-full"><strong>full</strong></a>(self, I<font color="#909090">=None</font>, *args)</dt><dd><tt>Return&nbsp;a&nbsp;full&nbsp;(sub-)matrix.<br>
&nbsp;<br>
Synopsis:&nbsp;Sm&nbsp;=&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-full">full</a>([,&nbsp;list&nbsp;I[,&nbsp;list&nbsp;J]])<br>
&nbsp;<br>
The&nbsp;optional&nbsp;arguments&nbsp;`I`&nbsp;and&nbsp;`J`,&nbsp;are&nbsp;the&nbsp;sub-intervals&nbsp;for&nbsp;the&nbsp;rows&nbsp;and<br>
columns&nbsp;that&nbsp;are&nbsp;to&nbsp;be&nbsp;extracted.</tt></dd></dl>

<dl><dt><a name="Spmat-get"><strong>get</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Spmat-info"><strong>info</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;string&nbsp;contains&nbsp;a&nbsp;short&nbsp;summary&nbsp;on&nbsp;the&nbsp;sparse&nbsp;matrix&nbsp;(dimensions,<br>
filling,&nbsp;...).</tt></dd></dl>

<dl><dt><a name="Spmat-is_complex"><strong>is_complex</strong></a>(self)</dt><dd><tt>Return&nbsp;1&nbsp;if&nbsp;the&nbsp;matrix&nbsp;contains&nbsp;complex&nbsp;values.</tt></dd></dl>

<dl><dt><a name="Spmat-mult"><strong>mult</strong></a>(self, V)</dt><dd><tt>Product&nbsp;of&nbsp;the&nbsp;sparse&nbsp;matrix&nbsp;`M`&nbsp;with&nbsp;a&nbsp;vector&nbsp;`V`.<br>
&nbsp;<br>
Synopsis:&nbsp;MV&nbsp;=&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-mult">mult</a>(vec&nbsp;V)<br>
&nbsp;<br>
For&nbsp;matrix-matrix&nbsp;multiplications,&nbsp;see&nbsp;<a href="#Spmat">Spmat</a>('mult').</tt></dd></dl>

<dl><dt><a name="Spmat-nnz"><strong>nnz</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;number&nbsp;of&nbsp;non-null&nbsp;values&nbsp;stored&nbsp;in&nbsp;the&nbsp;sparse&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Spmat-save"><strong>save</strong></a>(self, format, filename)</dt><dd><tt>Export&nbsp;the&nbsp;sparse&nbsp;matrix.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-save">save</a>(string&nbsp;format,&nbsp;string&nbsp;filename)<br>
&nbsp;<br>
the&nbsp;format&nbsp;of&nbsp;the&nbsp;file&nbsp;may&nbsp;be&nbsp;'hb'&nbsp;for&nbsp;Harwell-Boeing,&nbsp;or&nbsp;'mm'&nbsp;for&nbsp;Matrix-<br>
Market.</tt></dd></dl>

<dl><dt><a name="Spmat-scale"><strong>scale</strong></a>(self, v)</dt><dd><tt>Multiplies&nbsp;the&nbsp;matrix&nbsp;by&nbsp;a&nbsp;scalar&nbsp;value&nbsp;`v`.</tt></dd></dl>

<dl><dt><a name="Spmat-set"><strong>set</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Spmat-size"><strong>size</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;vector&nbsp;where&nbsp;`ni`&nbsp;and&nbsp;`nj`&nbsp;are&nbsp;the&nbsp;dimensions&nbsp;of&nbsp;the&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Spmat-storage"><strong>storage</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;storage&nbsp;type&nbsp;currently&nbsp;used&nbsp;for&nbsp;the&nbsp;matrix.<br>
&nbsp;<br>
Synopsis:&nbsp;s&nbsp;=&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-storage">storage</a>()<br>
&nbsp;<br>
The&nbsp;storage&nbsp;is&nbsp;returned&nbsp;as&nbsp;a&nbsp;string,&nbsp;either&nbsp;'CSC'&nbsp;or&nbsp;'WSC'.</tt></dd></dl>

<dl><dt><a name="Spmat-tmult"><strong>tmult</strong></a>(self, V)</dt><dd><tt>Product&nbsp;of&nbsp;`M`&nbsp;transposed&nbsp;(conjugated&nbsp;if&nbsp;`M`&nbsp;is&nbsp;complex)&nbsp;with&nbsp;the&nbsp;vector&nbsp;`V`.</tt></dd></dl>

<dl><dt><a name="Spmat-to_complex"><strong>to_complex</strong></a>(self)</dt><dd><tt>Store&nbsp;complex&nbsp;numbers.</tt></dd></dl>

<dl><dt><a name="Spmat-to_csc"><strong>to_csc</strong></a>(self)</dt><dd><tt>Convert&nbsp;the&nbsp;matrix&nbsp;to&nbsp;CSC&nbsp;storage.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-to_csc">to_csc</a>()<br>
&nbsp;<br>
CSC&nbsp;storage&nbsp;is&nbsp;recommended&nbsp;for&nbsp;matrix-vector&nbsp;multiplications.</tt></dd></dl>

<dl><dt><a name="Spmat-to_wsc"><strong>to_wsc</strong></a>(self)</dt><dd><tt>Convert&nbsp;the&nbsp;matrix&nbsp;to&nbsp;WSC&nbsp;storage.<br>
&nbsp;<br>
Synopsis:&nbsp;<a href="#Spmat">Spmat</a>.<a href="#Spmat-to_wsc">to_wsc</a>()<br>
&nbsp;<br>
Read&nbsp;and&nbsp;write&nbsp;operation&nbsp;are&nbsp;quite&nbsp;fast&nbsp;with&nbsp;WSC&nbsp;storage.</tt></dd></dl>

<dl><dt><a name="Spmat-transconj"><strong>transconj</strong></a>(self)</dt><dd><tt>Transpose&nbsp;and&nbsp;conjugate&nbsp;the&nbsp;matrix.</tt></dd></dl>

<dl><dt><a name="Spmat-transpose"><strong>transpose</strong></a>(self)</dt><dd><tt>Transpose&nbsp;the&nbsp;matrix.</tt></dd></dl>

</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-asm"><strong>asm</strong></a>(what, *args)</dt></dl>
 <dl><dt><a name="-asm_bilaplacian"><strong>asm_bilaplacian</strong></a>(mim, mf_u, mf_d, a)</dt><dd><tt>Assembly&nbsp;of&nbsp;the&nbsp;matrix&nbsp;for&nbsp;the&nbsp;Bilaplacian&nbsp;problem.<br>
&nbsp;<br>
Synopsis:&nbsp;A&nbsp;=&nbsp;<a href="#-asm_bilaplacian">asm_bilaplacian</a>(<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_d,&nbsp;vec&nbsp;a)<br>
&nbsp;<br>
:math:`\Delta(a(x)\Delta&nbsp;u)&nbsp;=&nbsp;0`&nbsp;with&nbsp;`a`&nbsp;scalar.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-asm_boundary"><strong>asm_boundary</strong></a>(bnum, expr, mim<font color="#909090">=None</font>, mf<font color="#909090">=None</font>, data<font color="#909090">=None</font>, *args)</dt><dd><tt>Generic&nbsp;boundary&nbsp;assembly.<br>
&nbsp;<br>
Synopsis:&nbsp;(...)&nbsp;=&nbsp;<a href="#-asm_boundary">asm_boundary</a>(int&nbsp;bnum,&nbsp;string&nbsp;expr&nbsp;[,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a><br>
mf,&nbsp;data...])<br>
&nbsp;<br>
See&nbsp;the&nbsp;help&nbsp;for&nbsp;<a href="#-asm_volumic">asm_volumic</a>().</tt></dd></dl>
 <dl><dt><a name="-asm_boundary_qu_term"><strong>asm_boundary_qu_term</strong></a>(boundary_num, mim, mf_u, mf_d, q)</dt><dd><tt>Assembly&nbsp;of&nbsp;a&nbsp;boundary&nbsp;qu&nbsp;term.<br>
&nbsp;<br>
Synopsis:&nbsp;Q&nbsp;=&nbsp;<a href="#-asm_boundary_qu_term">asm_boundary_qu_term</a>(int&nbsp;boundary_num,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,<br>
<a href="#MeshFem">MeshFem</a>&nbsp;mf_d,&nbsp;mat&nbsp;q)<br>
&nbsp;<br>
`q`&nbsp;should&nbsp;be&nbsp;be&nbsp;a&nbsp;[Qdim&nbsp;x&nbsp;Qdim&nbsp;x&nbsp;N]&nbsp;array,&nbsp;where&nbsp;N&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;dof&nbsp;of<br>
`mf_d`,&nbsp;and&nbsp;Qdim&nbsp;is&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;unkown&nbsp;u&nbsp;(that&nbsp;is&nbsp;set&nbsp;when&nbsp;creating<br>
the&nbsp;<a href="#MeshFem">MeshFem</a>).<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-asm_boundary_source"><strong>asm_boundary_source</strong></a>(bnum, mim, mf_u, mf_d, G)</dt><dd><tt>Assembly&nbsp;of&nbsp;a&nbsp;boundary&nbsp;source&nbsp;term.<br>
&nbsp;<br>
Synopsis:&nbsp;B&nbsp;=&nbsp;<a href="#-asm_boundary_source">asm_boundary_source</a>(int&nbsp;bnum,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,&nbsp;<a href="#MeshFem">MeshFem</a><br>
mf_d,&nbsp;vec&nbsp;G)<br>
&nbsp;<br>
`G`&nbsp;should&nbsp;be&nbsp;a&nbsp;[Qdim&nbsp;x&nbsp;N]&nbsp;matrix,&nbsp;where&nbsp;N&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;dof&nbsp;of&nbsp;`mf_d`,&nbsp;and<br>
Qdim&nbsp;is&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;unkown&nbsp;u&nbsp;(that&nbsp;is&nbsp;set&nbsp;when&nbsp;creating&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>).<br>
&nbsp;<br>
Return&nbsp;a&nbsp;vec&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-asm_dirichlet"><strong>asm_dirichlet</strong></a>(bnum, mim, mf_u, mf_d, H, R, threshold<font color="#909090">=None</font>)</dt><dd><tt>Assembly&nbsp;of&nbsp;Dirichlet&nbsp;conditions&nbsp;of&nbsp;type&nbsp;`h.u&nbsp;=&nbsp;r`.<br>
&nbsp;<br>
Synopsis:&nbsp;(HH,&nbsp;RR)&nbsp;=&nbsp;<a href="#-asm_dirichlet">asm_dirichlet</a>(int&nbsp;bnum,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,&nbsp;<a href="#MeshFem">MeshFem</a><br>
mf_d,&nbsp;mat&nbsp;H,&nbsp;vec&nbsp;R&nbsp;[,&nbsp;threshold])<br>
&nbsp;<br>
Handle&nbsp;`h.u&nbsp;=&nbsp;r`&nbsp;where&nbsp;h&nbsp;is&nbsp;a&nbsp;square&nbsp;matrix&nbsp;(of&nbsp;any&nbsp;rank)&nbsp;whose&nbsp;size&nbsp;is&nbsp;equal<br>
to&nbsp;the&nbsp;dimension&nbsp;of&nbsp;the&nbsp;unkown&nbsp;u.&nbsp;This&nbsp;matrix&nbsp;is&nbsp;stored&nbsp;in&nbsp;`H`,&nbsp;one&nbsp;column&nbsp;per<br>
dof&nbsp;in&nbsp;`mf_d`,&nbsp;each&nbsp;column&nbsp;containing&nbsp;the&nbsp;values&nbsp;of&nbsp;the&nbsp;matrix&nbsp;h&nbsp;stored&nbsp;in<br>
fortran&nbsp;order:<br>
&nbsp;<br>
`H(:,j)&nbsp;=&nbsp;[h11(x_j)&nbsp;h21(x_j)&nbsp;h12(x_j)&nbsp;h22(x_j)]`<br>
&nbsp;<br>
if&nbsp;u&nbsp;is&nbsp;a&nbsp;2D&nbsp;vector&nbsp;field.<br>
&nbsp;<br>
Of&nbsp;course,&nbsp;if&nbsp;the&nbsp;unknown&nbsp;is&nbsp;a&nbsp;scalar&nbsp;field,&nbsp;you&nbsp;just&nbsp;have&nbsp;to&nbsp;set&nbsp;`H&nbsp;=&nbsp;ones(1,<br>
N)`,&nbsp;where&nbsp;N&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;dof&nbsp;of&nbsp;`mf_d`.<br>
&nbsp;<br>
This&nbsp;is&nbsp;basically&nbsp;the&nbsp;same&nbsp;than&nbsp;calling&nbsp;<a href="#-asm_boundary_qu_term">asm_boundary_qu_term</a>()&nbsp;for&nbsp;`H`&nbsp;and<br>
calling&nbsp;asm_neumann()&nbsp;for&nbsp;`R`,&nbsp;except&nbsp;that&nbsp;this&nbsp;function&nbsp;tries&nbsp;to&nbsp;produce&nbsp;a<br>
'better'&nbsp;(more&nbsp;diagonal)&nbsp;constraints&nbsp;matrix&nbsp;(when&nbsp;possible).<br>
&nbsp;<br>
See&nbsp;also&nbsp;<a href="#Spmat">Spmat</a>.Dirichlet_nullspace().</tt></dd></dl>
 <dl><dt><a name="-asm_extrapolation_matrix"><strong>asm_extrapolation_matrix</strong></a>(mf, mfe)</dt><dd><tt>Build&nbsp;the&nbsp;extrapolation&nbsp;matrix&nbsp;from&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;onto&nbsp;another&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;Me&nbsp;=&nbsp;<a href="#-asm_extrapolation_matrix">asm_extrapolation_matrix</a>(<a href="#MeshFem">MeshFem</a>&nbsp;mf,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfe)<br>
&nbsp;<br>
Return&nbsp;a&nbsp;matrix&nbsp;`Me`,&nbsp;such&nbsp;that&nbsp;`V&nbsp;=&nbsp;Me.U`&nbsp;is&nbsp;equal&nbsp;to<br>
<a href="#-compute_extrapolate_on">compute_extrapolate_on</a>(mf,&nbsp;U,&nbsp;mfe).&nbsp;Useful&nbsp;for&nbsp;repeated&nbsp;extrapolations.&nbsp;`Me`<br>
is&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-asm_helmholtz"><strong>asm_helmholtz</strong></a>(mim, mf_u, mf_d, k)</dt><dd><tt>Assembly&nbsp;of&nbsp;the&nbsp;matrix&nbsp;for&nbsp;the&nbsp;Helmholtz&nbsp;problem.<br>
&nbsp;<br>
Synopsis:&nbsp;A&nbsp;=&nbsp;<a href="#-asm_helmholtz">asm_helmholtz</a>(<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_d,&nbsp;vec&nbsp;k)<br>
&nbsp;<br>
:math:`\Delta&nbsp;u&nbsp;+&nbsp;k^2&nbsp;u`&nbsp;=&nbsp;0&nbsp;with&nbsp;`k`&nbsp;complex&nbsp;scalar.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-asm_interpolation_matrix"><strong>asm_interpolation_matrix</strong></a>(mf, mfi)</dt><dd><tt>Build&nbsp;the&nbsp;interpolation&nbsp;matrix&nbsp;from&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;onto&nbsp;another&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;Mi&nbsp;=&nbsp;<a href="#-asm_interpolation_matrix">asm_interpolation_matrix</a>(<a href="#MeshFem">MeshFem</a>&nbsp;mf,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfi)<br>
&nbsp;<br>
Return&nbsp;a&nbsp;matrix&nbsp;`Mi`,&nbsp;such&nbsp;that&nbsp;`V&nbsp;=&nbsp;Mi.U`&nbsp;is&nbsp;equal&nbsp;to<br>
<a href="#-compute_interpolate_on">compute_interpolate_on</a>(mf,&nbsp;U,&nbsp;mfi).&nbsp;Useful&nbsp;for&nbsp;repeated&nbsp;interpolations.&nbsp;Note<br>
that&nbsp;this&nbsp;is&nbsp;just&nbsp;interpolation,&nbsp;no&nbsp;elementary&nbsp;integrations&nbsp;are&nbsp;involved&nbsp;here,<br>
and&nbsp;`mfi`&nbsp;has&nbsp;to&nbsp;be&nbsp;lagrangian.&nbsp;In&nbsp;the&nbsp;more&nbsp;general&nbsp;case,&nbsp;you&nbsp;would&nbsp;have&nbsp;to&nbsp;do<br>
a&nbsp;L2&nbsp;projection&nbsp;via&nbsp;the&nbsp;mass&nbsp;matrix.<br>
&nbsp;<br>
`Mi`&nbsp;is&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-asm_laplacian"><strong>asm_laplacian</strong></a>(mim, mf_u, mf_d, a)</dt><dd><tt>Assembly&nbsp;of&nbsp;the&nbsp;matrix&nbsp;for&nbsp;the&nbsp;Laplacian&nbsp;problem.<br>
&nbsp;<br>
Synopsis:&nbsp;L&nbsp;=&nbsp;<a href="#-asm_laplacian">asm_laplacian</a>(<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_d,&nbsp;vec&nbsp;a)<br>
&nbsp;<br>
:math:`\nabla\cdot(a(x)\nabla&nbsp;u)`&nbsp;with&nbsp;`a`&nbsp;scalar.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-asm_linear_elasticity"><strong>asm_linear_elasticity</strong></a>(mim, mf_u, mf_d, lambda_d, mu_d)</dt><dd><tt>Assembles&nbsp;of&nbsp;the&nbsp;matrix&nbsp;for&nbsp;the&nbsp;linear&nbsp;(isotropic)&nbsp;elasticity&nbsp;problem.<br>
&nbsp;<br>
Synopsis:&nbsp;Le&nbsp;=&nbsp;<a href="#-asm_linear_elasticity">asm_linear_elasticity</a>(<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_d,<br>
vec&nbsp;lambda_d,&nbsp;vec&nbsp;mu_d)<br>
&nbsp;<br>
:math:`\nabla\cdot(C(x):\nabla&nbsp;u)`&nbsp;with&nbsp;:math:`C`&nbsp;defined&nbsp;via&nbsp;`lambda_d`<br>
and&nbsp;`mu_d`.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-asm_mass_matrix"><strong>asm_mass_matrix</strong></a>(mim, mf1, mf2<font color="#909090">=None</font>)</dt><dd><tt>Assembly&nbsp;of&nbsp;a&nbsp;mass&nbsp;matrix.<br>
&nbsp;<br>
Synopsis:&nbsp;M&nbsp;=&nbsp;<a href="#-asm_mass_matrix">asm_mass_matrix</a>(<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf1[,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf2])<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-asm_nonlinear_elasticity"><strong>asm_nonlinear_elasticity</strong></a>(mim, mf_u, U, law, mf_d, params, *args)</dt><dd><tt>Assembles&nbsp;terms&nbsp;(tangent&nbsp;matrix&nbsp;and&nbsp;right&nbsp;hand&nbsp;side)&nbsp;for&nbsp;nonlinear&nbsp;elasticity.<br>
&nbsp;<br>
Synopsis:&nbsp;TRHS&nbsp;=&nbsp;<a href="#-asm_nonlinear_elasticity">asm_nonlinear_elasticity</a>(<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,&nbsp;vec&nbsp;U,<br>
string&nbsp;law,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_d,&nbsp;mat&nbsp;params,&nbsp;{'tangent&nbsp;matrix'|'rhs'|'incompressible<br>
tangent&nbsp;matrix',&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_p,&nbsp;vec&nbsp;P|'incompressible&nbsp;rhs',&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_p,&nbsp;vec<br>
P})<br>
&nbsp;<br>
The&nbsp;solution&nbsp;`U`&nbsp;is&nbsp;required&nbsp;at&nbsp;the&nbsp;current&nbsp;time-step.&nbsp;The&nbsp;`law`&nbsp;may&nbsp;be<br>
choosen&nbsp;among:<br>
&nbsp;<br>
-&nbsp;'SaintVenant&nbsp;Kirchhoff':<br>
&nbsp;&nbsp;Linearized&nbsp;law,&nbsp;should&nbsp;be&nbsp;avoided).&nbsp;This&nbsp;law&nbsp;has&nbsp;the&nbsp;two&nbsp;usual<br>
&nbsp;&nbsp;Lame&nbsp;coefficients&nbsp;as&nbsp;parameters,&nbsp;called&nbsp;lambda&nbsp;and&nbsp;mu.<br>
-&nbsp;'Mooney&nbsp;Rivlin':<br>
&nbsp;&nbsp;Only&nbsp;for&nbsp;incompressibility.&nbsp;This&nbsp;law&nbsp;has&nbsp;two&nbsp;parameters,<br>
&nbsp;&nbsp;called&nbsp;C1&nbsp;and&nbsp;C2.<br>
-&nbsp;'Ciarlet&nbsp;Geymonat':<br>
&nbsp;&nbsp;This&nbsp;law&nbsp;has&nbsp;3&nbsp;parameters,&nbsp;called&nbsp;lambda,&nbsp;mu&nbsp;and&nbsp;gamma,&nbsp;with<br>
&nbsp;&nbsp;gamma&nbsp;chosen&nbsp;such&nbsp;that&nbsp;gamma&nbsp;is&nbsp;in&nbsp;]-lambda/2-mu,&nbsp;-mu[.<br>
&nbsp;<br>
The&nbsp;parameters&nbsp;of&nbsp;the&nbsp;material&nbsp;law&nbsp;are&nbsp;described&nbsp;on&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mf_d`.&nbsp;The<br>
matrix&nbsp;`params`&nbsp;should&nbsp;have&nbsp;`nbdof(mf_d)`&nbsp;columns,&nbsp;each&nbsp;row&nbsp;correspounds&nbsp;to&nbsp;a<br>
parameter.<br>
&nbsp;<br>
The&nbsp;last&nbsp;argument&nbsp;selects&nbsp;what&nbsp;is&nbsp;to&nbsp;be&nbsp;built:&nbsp;either&nbsp;the&nbsp;tangent&nbsp;matrix,&nbsp;or<br>
the&nbsp;right&nbsp;hand&nbsp;side.&nbsp;If&nbsp;the&nbsp;incompressibility&nbsp;is&nbsp;considered,&nbsp;it&nbsp;should&nbsp;be<br>
followed&nbsp;by&nbsp;a&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mf_p`,&nbsp;for&nbsp;the&nbsp;pression.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object&nbsp;(tangent&nbsp;matrix),&nbsp;vec&nbsp;object&nbsp;(right&nbsp;hand&nbsp;side),&nbsp;tuple&nbsp;of<br>
<a href="#Spmat">Spmat</a>&nbsp;objects&nbsp;(incompressible&nbsp;tangent&nbsp;matrix),&nbsp;or&nbsp;tuple&nbsp;of&nbsp;vec&nbsp;objects<br>
(incompressible&nbsp;right&nbsp;hand&nbsp;side).</tt></dd></dl>
 <dl><dt><a name="-asm_stokes"><strong>asm_stokes</strong></a>(mim, mf_u, mf_p, mf_d, nu)</dt><dd><tt>Assembly&nbsp;of&nbsp;matrices&nbsp;for&nbsp;the&nbsp;Stokes&nbsp;problem.<br>
&nbsp;<br>
Synopsis:&nbsp;(K,&nbsp;B)&nbsp;=&nbsp;<a href="#-asm_stokes">asm_stokes</a>(<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_p,&nbsp;<a href="#MeshFem">MeshFem</a><br>
mf_d,&nbsp;vec&nbsp;nu)<br>
&nbsp;<br>
:math:`-\nu(x)\Delta&nbsp;u&nbsp;+&nbsp;\nabla&nbsp;p&nbsp;=&nbsp;0`<br>
&nbsp;<br>
:math:`\nabla\cdot&nbsp;u&nbsp;=&nbsp;0`<br>
&nbsp;<br>
with&nbsp;:math:`\nu`&nbsp;(`nu`),&nbsp;the&nbsp;fluid's&nbsp;dynamic&nbsp;viscosity.<br>
&nbsp;<br>
On&nbsp;output,&nbsp;`K`&nbsp;is&nbsp;the&nbsp;usual&nbsp;linear&nbsp;elasticity&nbsp;stiffness&nbsp;matrix&nbsp;with<br>
:math:`\lambda&nbsp;=&nbsp;0`&nbsp;and&nbsp;:math:`2\mu&nbsp;=&nbsp;\nu`.&nbsp;`B`&nbsp;is&nbsp;a&nbsp;matrix&nbsp;corresponding<br>
to&nbsp;:math:`\int&nbsp;p\nabla\cdot\phi`.<br>
&nbsp;<br>
`K`&nbsp;and&nbsp;`B`&nbsp;are&nbsp;<a href="#Spmat">Spmat</a>&nbsp;object's.</tt></dd></dl>
 <dl><dt><a name="-asm_volumic"><strong>asm_volumic</strong></a>(CVLST<font color="#909090">=None</font>, *args)</dt><dd><tt>Generic&nbsp;assembly&nbsp;procedure&nbsp;for&nbsp;volumic&nbsp;assembly.<br>
&nbsp;<br>
Synopsis:&nbsp;(...)&nbsp;=&nbsp;<a href="#-asm_volumic">asm_volumic</a>([,CVLST],&nbsp;expr&nbsp;[,&nbsp;mesh_ims,&nbsp;mesh_fems,&nbsp;data...])<br>
&nbsp;<br>
The&nbsp;expression&nbsp;`expr`&nbsp;is&nbsp;evaluated&nbsp;over&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>'s&nbsp;listed&nbsp;in&nbsp;the&nbsp;arguments<br>
(with&nbsp;optional&nbsp;data)&nbsp;and&nbsp;assigned&nbsp;to&nbsp;the&nbsp;output&nbsp;arguments.&nbsp;For&nbsp;details&nbsp;about<br>
the&nbsp;syntax&nbsp;of&nbsp;assembly&nbsp;expressions,&nbsp;please&nbsp;refer&nbsp;to&nbsp;the&nbsp;getfem&nbsp;user&nbsp;manual&nbsp;(or<br>
look&nbsp;at&nbsp;the&nbsp;file&nbsp;getfem_assembling.h&nbsp;in&nbsp;the&nbsp;getfem++&nbsp;sources).<br>
&nbsp;<br>
For&nbsp;example,&nbsp;the&nbsp;L2&nbsp;norm&nbsp;of&nbsp;a&nbsp;field&nbsp;can&nbsp;be&nbsp;computed&nbsp;with<br>
&nbsp;<br>
compute_L2&nbsp;norm(mf,&nbsp;U,&nbsp;)&nbsp;or&nbsp;with:<br>
&nbsp;<br>
<a href="#-asm_volumic">asm_volumic</a>('u=data(#1);<br>
V()+=u(i).u(j).comp(Base(#1).Base(#1))(i,j)',mim,mf,U)<br>
&nbsp;<br>
The&nbsp;Laplacian&nbsp;stiffness&nbsp;matrix&nbsp;can&nbsp;be&nbsp;evaluated&nbsp;with<br>
&nbsp;<br>
<a href="#-asm_laplacian">asm_laplacian</a>(mim,&nbsp;mf,&nbsp;A)&nbsp;or&nbsp;equivalently&nbsp;with:<br>
&nbsp;<br>
<a href="#-asm_volumic">asm_volumic</a>('a=data(#2);M(#1,#1)+=sym(comp(Grad(#1).Grad(#1).Base(#2))(:,i,:,i<br>
,j).a(j))',&nbsp;mim,mf,&nbsp;A);</tt></dd></dl>
 <dl><dt><a name="-asm_volumic_source"><strong>asm_volumic_source</strong></a>(mim, mf_u, mf_d, fd)</dt><dd><tt>Assembly&nbsp;of&nbsp;a&nbsp;volumic&nbsp;source&nbsp;term.<br>
&nbsp;<br>
Synopsis:&nbsp;V&nbsp;=&nbsp;<a href="#-asm_volumic_source">asm_volumic_source</a>(<a href="#MeshIm">MeshIm</a>&nbsp;mim,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_u,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_d,&nbsp;vec<br>
fd)<br>
&nbsp;<br>
Output&nbsp;a&nbsp;vector&nbsp;`V`,&nbsp;assembled&nbsp;on&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mf_u`,&nbsp;using&nbsp;the&nbsp;data&nbsp;vector<br>
`fd`&nbsp;defined&nbsp;on&nbsp;the&nbsp;data&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mf_d`.&nbsp;`fd`&nbsp;may&nbsp;be&nbsp;real&nbsp;or&nbsp;complex-valued.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;vec&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-compute"><strong>compute</strong></a>(mf, U, what, *args)</dt></dl>
 <dl><dt><a name="-compute_H1_norm"><strong>compute_H1_norm</strong></a>(mf, U, mim, CVids<font color="#909090">=None</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;H1&nbsp;norm&nbsp;of&nbsp;`U`.<br>
&nbsp;<br>
Synopsis:&nbsp;n&nbsp;=&nbsp;compute_H1&nbsp;norm(mf,&nbsp;U,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim[,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
If&nbsp;`CVids`&nbsp;is&nbsp;given,&nbsp;the&nbsp;norm&nbsp;will&nbsp;be&nbsp;computed&nbsp;only&nbsp;on&nbsp;the&nbsp;listed&nbsp;convexes.</tt></dd></dl>
 <dl><dt><a name="-compute_H1_semi_norm"><strong>compute_H1_semi_norm</strong></a>(mf, U, mim, CVids<font color="#909090">=None</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;L2&nbsp;norm&nbsp;of&nbsp;grad(`U`).<br>
&nbsp;<br>
Synopsis:&nbsp;n&nbsp;=&nbsp;compute_H1&nbsp;semi&nbsp;norm(mf,&nbsp;U,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim[,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
If&nbsp;`CVids`&nbsp;is&nbsp;given,&nbsp;the&nbsp;norm&nbsp;will&nbsp;be&nbsp;computed&nbsp;only&nbsp;on&nbsp;the&nbsp;listed&nbsp;convexes.</tt></dd></dl>
 <dl><dt><a name="-compute_H2_norm"><strong>compute_H2_norm</strong></a>(mf, U, mim, CVids<font color="#909090">=None</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;H2&nbsp;norm&nbsp;of&nbsp;`U`.<br>
&nbsp;<br>
Synopsis:&nbsp;n&nbsp;=&nbsp;compute_H2&nbsp;norm(mf,&nbsp;U,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim[,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
If&nbsp;`CVids`&nbsp;is&nbsp;given,&nbsp;the&nbsp;norm&nbsp;will&nbsp;be&nbsp;computed&nbsp;only&nbsp;on&nbsp;the&nbsp;listed&nbsp;convexes.</tt></dd></dl>
 <dl><dt><a name="-compute_H2_semi_norm"><strong>compute_H2_semi_norm</strong></a>(mf, U, mim, CVids<font color="#909090">=None</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;L2&nbsp;norm&nbsp;of&nbsp;D^2(`U`).<br>
&nbsp;<br>
Synopsis:&nbsp;n&nbsp;=&nbsp;compute_H2&nbsp;semi&nbsp;norm(mf,&nbsp;U,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim[,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
If&nbsp;`CVids`&nbsp;is&nbsp;given,&nbsp;the&nbsp;norm&nbsp;will&nbsp;be&nbsp;computed&nbsp;only&nbsp;on&nbsp;the&nbsp;listed&nbsp;convexes.</tt></dd></dl>
 <dl><dt><a name="-compute_L2_norm"><strong>compute_L2_norm</strong></a>(mf, U, mim, CVids<font color="#909090">=None</font>)</dt><dd><tt>Compute&nbsp;the&nbsp;L2&nbsp;norm&nbsp;of&nbsp;the&nbsp;(real&nbsp;or&nbsp;complex)&nbsp;field&nbsp;`U`.<br>
&nbsp;<br>
Synopsis:&nbsp;n&nbsp;=&nbsp;compute_L2&nbsp;norm(mf,&nbsp;U,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim[,&nbsp;mat&nbsp;CVids])<br>
&nbsp;<br>
If&nbsp;`CVids`&nbsp;is&nbsp;given,&nbsp;the&nbsp;norm&nbsp;will&nbsp;be&nbsp;computed&nbsp;only&nbsp;on&nbsp;the&nbsp;listed&nbsp;convexes.</tt></dd></dl>
 <dl><dt><a name="-compute_error_estimate"><strong>compute_error_estimate</strong></a>(mf, U, mim)</dt><dd><tt>Compute&nbsp;an&nbsp;a&nbsp;posteriori&nbsp;error&nbsp;estimation.<br>
&nbsp;<br>
Synopsis:&nbsp;E&nbsp;=&nbsp;<a href="#-compute_error_estimate">compute_error_estimate</a>(mf,&nbsp;U,&nbsp;<a href="#MeshIm">MeshIm</a>&nbsp;mim)<br>
&nbsp;<br>
Currently&nbsp;there&nbsp;is&nbsp;only&nbsp;one&nbsp;which&nbsp;is&nbsp;available:&nbsp;for&nbsp;each&nbsp;convex,&nbsp;the&nbsp;jump&nbsp;of<br>
the&nbsp;normal&nbsp;derivative&nbsp;is&nbsp;integrated&nbsp;on&nbsp;its&nbsp;faces.</tt></dd></dl>
 <dl><dt><a name="-compute_extrapolate_on"><strong>compute_extrapolate_on</strong></a>(mf, U, mfe)</dt><dd><tt>Extrapolate&nbsp;a&nbsp;field&nbsp;on&nbsp;another&nbsp;<a href="#MeshFem">MeshFem</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;Ue&nbsp;=&nbsp;<a href="#-compute_extrapolate_on">compute_extrapolate_on</a>(mf,&nbsp;U,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mfe)<br>
&nbsp;<br>
If&nbsp;the&nbsp;mesh&nbsp;of&nbsp;`mfe`&nbsp;is&nbsp;stricly&nbsp;included&nbsp;in&nbsp;the&nbsp;mesh&nbsp;of&nbsp;`mf`,&nbsp;this&nbsp;function<br>
does&nbsp;stricly&nbsp;the&nbsp;same&nbsp;job&nbsp;as&nbsp;<a href="#-compute_interpolate_on">compute_interpolate_on</a>(mf,&nbsp;U,&nbsp;).&nbsp;However,&nbsp;if&nbsp;the<br>
mesh&nbsp;of&nbsp;`mfe`&nbsp;is&nbsp;not&nbsp;exactly&nbsp;included&nbsp;in&nbsp;`mf`&nbsp;(imagine&nbsp;interpolation&nbsp;between&nbsp;a<br>
curved&nbsp;refined&nbsp;mesh&nbsp;and&nbsp;a&nbsp;coarse&nbsp;mesh),&nbsp;then&nbsp;values&nbsp;which&nbsp;are&nbsp;slightly&nbsp;outside<br>
`mf`&nbsp;will&nbsp;be&nbsp;extrapolated.<br>
&nbsp;<br>
See&nbsp;also&nbsp;<a href="#-asm_extrapolation_matrix">asm_extrapolation_matrix</a>()</tt></dd></dl>
 <dl><dt><a name="-compute_gradient"><strong>compute_gradient</strong></a>(mf, U, mf_du)</dt><dd><tt>Compute&nbsp;the&nbsp;gradient&nbsp;of&nbsp;the&nbsp;field&nbsp;`U`&nbsp;defined&nbsp;on&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mf_du`.<br>
&nbsp;<br>
Synopsis:&nbsp;DU&nbsp;=&nbsp;<a href="#-compute_gradient">compute_gradient</a>(mf,&nbsp;U,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_du)<br>
&nbsp;<br>
The&nbsp;gradient&nbsp;is&nbsp;interpolated&nbsp;on&nbsp;the&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mf_du`,&nbsp;and&nbsp;returned&nbsp;in&nbsp;`DU`.&nbsp;For<br>
example,&nbsp;if&nbsp;`U`&nbsp;is&nbsp;defined&nbsp;on&nbsp;a&nbsp;P2&nbsp;<a href="#MeshFem">MeshFem</a>,&nbsp;`DU`&nbsp;should&nbsp;be&nbsp;evaluated&nbsp;on&nbsp;a<br>
P1-discontinuous&nbsp;<a href="#MeshFem">MeshFem</a>.&nbsp;`mf`&nbsp;and&nbsp;`mf_du`&nbsp;should&nbsp;share&nbsp;the&nbsp;same&nbsp;mesh.<br>
&nbsp;<br>
`U`&nbsp;may&nbsp;have&nbsp;any&nbsp;number&nbsp;of&nbsp;dimensions&nbsp;(i.e.&nbsp;this&nbsp;function&nbsp;is&nbsp;not&nbsp;restricted&nbsp;to<br>
the&nbsp;gradient&nbsp;of&nbsp;scalar&nbsp;fields,&nbsp;but&nbsp;may&nbsp;also&nbsp;be&nbsp;used&nbsp;for&nbsp;tensor&nbsp;fields).<br>
However&nbsp;the&nbsp;last&nbsp;dimension&nbsp;of&nbsp;`U`&nbsp;has&nbsp;to&nbsp;be&nbsp;equal&nbsp;to&nbsp;the&nbsp;number&nbsp;of&nbsp;dof&nbsp;of<br>
`mf`.&nbsp;For&nbsp;example,&nbsp;if&nbsp;`U`&nbsp;is&nbsp;a&nbsp;[3x3xNmf]&nbsp;array&nbsp;(where&nbsp;Nmf&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;dof<br>
of&nbsp;`mf`),&nbsp;`DU`&nbsp;will&nbsp;be&nbsp;a&nbsp;[Nx3x3[xQ]xNmf_du]&nbsp;array,&nbsp;where&nbsp;N&nbsp;is&nbsp;the&nbsp;dimension&nbsp;of<br>
the&nbsp;mesh,&nbsp;Nmf_du&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;dof&nbsp;of&nbsp;`mf_du`,&nbsp;and&nbsp;the&nbsp;optional&nbsp;Q&nbsp;dimension<br>
is&nbsp;inserted&nbsp;if&nbsp;`Qdim_mf&nbsp;!=&nbsp;Qdim_mf_du`,&nbsp;where&nbsp;Qdim_mf&nbsp;is&nbsp;the&nbsp;Qdim&nbsp;of&nbsp;`mf`&nbsp;and<br>
Qdim_mf_du&nbsp;is&nbsp;the&nbsp;Qdim&nbsp;of&nbsp;`mf_du`.</tt></dd></dl>
 <dl><dt><a name="-compute_hessian"><strong>compute_hessian</strong></a>(mf, U, mf_h)</dt><dd><tt>Compute&nbsp;the&nbsp;hessian&nbsp;of&nbsp;the&nbsp;field&nbsp;`U`&nbsp;defined&nbsp;on&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mf_h`.<br>
&nbsp;<br>
Synopsis:&nbsp;HU&nbsp;=&nbsp;<a href="#-compute_hessian">compute_hessian</a>(mf,&nbsp;U,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_h)<br>
&nbsp;<br>
See&nbsp;also&nbsp;<a href="#-compute_gradient">compute_gradient</a>(mf,&nbsp;U,&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;mf_du).</tt></dd></dl>
 <dl><dt><a name="-compute_interpolate_on"><strong>compute_interpolate_on</strong></a>(mf, U, *args)</dt><dd><tt>Interpolate&nbsp;a&nbsp;field&nbsp;on&nbsp;another&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;or&nbsp;a&nbsp;<a href="#Slice">Slice</a>.<br>
&nbsp;<br>
Synopsis:&nbsp;Ui&nbsp;=&nbsp;<a href="#-compute_interpolate_on">compute_interpolate_on</a>(mf,&nbsp;U,&nbsp;{<a href="#MeshFem">MeshFem</a>&nbsp;mfi&nbsp;|&nbsp;<a href="#Slice">Slice</a>&nbsp;sli})<br>
&nbsp;<br>
-&nbsp;Interpolation&nbsp;on&nbsp;another&nbsp;<a href="#MeshFem">MeshFem</a>&nbsp;`mfi`:<br>
&nbsp;&nbsp;`mfi`&nbsp;has&nbsp;to&nbsp;be&nbsp;Lagrangian.&nbsp;If&nbsp;`mf`&nbsp;and&nbsp;`mfi`&nbsp;share&nbsp;the&nbsp;same<br>
&nbsp;&nbsp;mesh&nbsp;object,&nbsp;the&nbsp;interpolation&nbsp;will&nbsp;be&nbsp;much&nbsp;faster.<br>
-&nbsp;Interpolation&nbsp;on&nbsp;a&nbsp;<a href="#Slice">Slice</a>&nbsp;`sli`:<br>
&nbsp;&nbsp;this&nbsp;is&nbsp;similar&nbsp;to&nbsp;interpolation&nbsp;on&nbsp;a&nbsp;refined&nbsp;P1-discontinuous<br>
&nbsp;&nbsp;mesh,&nbsp;but&nbsp;it&nbsp;is&nbsp;much&nbsp;faster.&nbsp;This&nbsp;can&nbsp;also&nbsp;be&nbsp;used&nbsp;with<br>
&nbsp;&nbsp;<a href="#Slice">Slice</a>('points')&nbsp;to&nbsp;obtain&nbsp;field&nbsp;values&nbsp;at&nbsp;a&nbsp;given&nbsp;set&nbsp;of<br>
&nbsp;&nbsp;points.<br>
&nbsp;<br>
See&nbsp;also&nbsp;<a href="#-asm_interpolation_matrix">asm_interpolation_matrix</a>()</tt></dd></dl>
 <dl><dt><a name="-factory"><strong>factory</strong></a>(id)</dt></dl>
 <dl><dt><a name="-generic_constructor"><strong>generic_constructor</strong></a>(self, clname, *args)</dt><dd><tt>Internal&nbsp;function&nbsp;--&nbsp;acts&nbsp;as&nbsp;a&nbsp;constructor&nbsp;for&nbsp;all&nbsp;getfem&nbsp;objects.</tt></dd></dl>
 <dl><dt><a name="-generic_destructor"><strong>generic_destructor</strong></a>(self, destructible<font color="#909090">=True</font>)</dt><dd><tt>Internal&nbsp;function&nbsp;--&nbsp;acts&nbsp;as&nbsp;a&nbsp;destructor&nbsp;for&nbsp;all&nbsp;getfem&nbsp;objects.</tt></dd></dl>
 <dl><dt><a name="-getfem"><strong>getfem</strong></a>(...)</dt><dd><tt>Execute&nbsp;a&nbsp;getfem&nbsp;command.</tt></dd></dl>
 <dl><dt><a name="-getfem_from_constructor"><strong>getfem_from_constructor</strong></a>(...)</dt><dd><tt>internal&nbsp;--&nbsp;Execute&nbsp;a&nbsp;getfem&nbsp;command&nbsp;for&nbsp;building&nbsp;a&nbsp;new&nbsp;object.</tt></dd></dl>
 <dl><dt><a name="-linsolve"><strong>linsolve</strong></a>(what, *args)</dt></dl>
 <dl><dt><a name="-linsolve_bicgstab"><strong>linsolve_bicgstab</strong></a>(M, b, P<font color="#909090">=None</font>, *args)</dt><dd><tt>Solve&nbsp;`M.X&nbsp;=&nbsp;b`&nbsp;with&nbsp;the&nbsp;bi-conjugated&nbsp;gradient&nbsp;stabilized&nbsp;method.<br>
&nbsp;<br>
Synopsis:&nbsp;X&nbsp;=&nbsp;<a href="#-linsolve_bicgstab">linsolve_bicgstab</a>(<a href="#Spmat">Spmat</a>&nbsp;M,&nbsp;vec&nbsp;b&nbsp;[,&nbsp;<a href="#Precond">Precond</a>&nbsp;P][,'noisy'][,'res',<br>
r][,'maxiter',&nbsp;n])<br>
&nbsp;<br>
Optionally&nbsp;using&nbsp;`P`&nbsp;as&nbsp;a&nbsp;preconditioner.</tt></dd></dl>
 <dl><dt><a name="-linsolve_cg"><strong>linsolve_cg</strong></a>(M, b, P<font color="#909090">=None</font>, *args)</dt><dd><tt>Solve&nbsp;`M.X&nbsp;=&nbsp;b`&nbsp;with&nbsp;the&nbsp;conjugated&nbsp;gradient&nbsp;method.<br>
&nbsp;<br>
Synopsis:&nbsp;X&nbsp;=&nbsp;<a href="#-linsolve_cg">linsolve_cg</a>(<a href="#Spmat">Spmat</a>&nbsp;M,&nbsp;vec&nbsp;b&nbsp;[,&nbsp;<a href="#Precond">Precond</a>&nbsp;P][,'noisy'][,'res',<br>
r][,'maxiter',&nbsp;n])<br>
&nbsp;<br>
Optionally&nbsp;using&nbsp;`P`&nbsp;as&nbsp;preconditioner.</tt></dd></dl>
 <dl><dt><a name="-linsolve_gmres"><strong>linsolve_gmres</strong></a>(M, b, restart<font color="#909090">=None</font>, *args)</dt><dd><tt>Solve&nbsp;`M.X&nbsp;=&nbsp;b`&nbsp;with&nbsp;the&nbsp;generalized&nbsp;minimum&nbsp;residuals&nbsp;method.<br>
&nbsp;<br>
Synopsis:&nbsp;X&nbsp;=&nbsp;<a href="#-linsolve_gmres">linsolve_gmres</a>(<a href="#Spmat">Spmat</a>&nbsp;M,&nbsp;vec&nbsp;b[,&nbsp;int&nbsp;restart][,&nbsp;<a href="#Precond">Precond</a><br>
P][,'noisy'][,'res',&nbsp;r][,'maxiter',&nbsp;n])<br>
&nbsp;<br>
Optionally&nbsp;using&nbsp;`P`&nbsp;as&nbsp;preconditioner.&nbsp;The&nbsp;default&nbsp;value&nbsp;of&nbsp;the&nbsp;restart<br>
parameter&nbsp;is&nbsp;50.</tt></dd></dl>
 <dl><dt><a name="-linsolve_lu"><strong>linsolve_lu</strong></a>(M, b)</dt><dd><tt>Alias&nbsp;for&nbsp;<a href="#-linsolve_superlu">linsolve_superlu</a>(...)</tt></dd></dl>
 <dl><dt><a name="-linsolve_superlu"><strong>linsolve_superlu</strong></a>(M, b)</dt><dd><tt>Solve&nbsp;`M.U&nbsp;=&nbsp;b`&nbsp;apply&nbsp;the&nbsp;SuperLU&nbsp;solver&nbsp;(sparse&nbsp;LU&nbsp;factorization).<br>
&nbsp;<br>
Synopsis:&nbsp;(U,&nbsp;cond)&nbsp;=&nbsp;<a href="#-linsolve_superlu">linsolve_superlu</a>(<a href="#Spmat">Spmat</a>&nbsp;M,&nbsp;vec&nbsp;b)<br>
&nbsp;<br>
The&nbsp;condition&nbsp;number&nbsp;estimate&nbsp;`cond`&nbsp;is&nbsp;returned&nbsp;with&nbsp;the&nbsp;solution&nbsp;`U`.</tt></dd></dl>
 <dl><dt><a name="-memstats"><strong>memstats</strong></a>()</dt></dl>
 <dl><dt><a name="-register_python_factory"><strong>register_python_factory</strong></a>(...)</dt><dd><tt>register&nbsp;(on&nbsp;initialization)&nbsp;the&nbsp;python&nbsp;function&nbsp;which&nbsp;is&nbsp;used&nbsp;to&nbsp;build&nbsp;objects&nbsp;from&nbsp;a&nbsp;GetfemObject&nbsp;type&nbsp;(internal&nbsp;function)</tt></dd></dl>
 <dl><dt><a name="-util"><strong>util</strong></a>(what, *args)</dt></dl>
 <dl><dt><a name="-util_trace_level"><strong>util_trace_level</strong></a>(level)</dt><dd><tt>Set&nbsp;the&nbsp;verbosity&nbsp;of&nbsp;some&nbsp;getfem++&nbsp;routines.<br>
&nbsp;<br>
Synopsis:&nbsp;util_('trace_level',int&nbsp;level)<br>
&nbsp;<br>
Typically&nbsp;the&nbsp;messages&nbsp;printed&nbsp;by&nbsp;the&nbsp;model&nbsp;bricks,&nbsp;0&nbsp;means&nbsp;no&nbsp;trace&nbsp;message<br>
(default&nbsp;is&nbsp;3).</tt></dd></dl>
 <dl><dt><a name="-util_warning_level"><strong>util_warning_level</strong></a>(level)</dt><dd><tt>Filter&nbsp;the&nbsp;less&nbsp;important&nbsp;warnings&nbsp;displayed&nbsp;by&nbsp;getfem.<br>
&nbsp;<br>
Synopsis:&nbsp;util_('warning_level',int&nbsp;level)<br>
&nbsp;<br>
0&nbsp;means&nbsp;no&nbsp;warnings,&nbsp;default&nbsp;level&nbsp;is&nbsp;3.</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>__version__</strong> = '$Revision: 2970 $'<br>
<strong>obj_count</strong> = {}</td></tr></table>
</body></html>